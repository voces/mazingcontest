var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target2) => __defProp(target2, "__esModule", {value: true});
var __name = (target2, value) => __defProp(target2, "name", {value, configurable: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target2, all) => {
  for (var name in all)
    __defProp(target2, name, {get: all[name], enumerable: true});
};
var __exportStar = (target2, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target2, key) && key !== "default")
        __defProp(target2, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target2;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/marked/lib/marked.js
var require_marked = __commonJS((exports2, module2) => {
  (function(global, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.marked = factory());
  })(exports2, function() {
    "use strict";
    function _defineProperties(target2, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target2, descriptor.key, descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _unsupportedIterableToArray(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _arrayLikeToArray(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o3, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
        arr2[i3] = arr[i3];
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o3[Symbol.iterator] == null) {
        if (Array.isArray(o3) || (it = _unsupportedIterableToArray(o3)) || allowArrayLike && o3 && typeof o3.length === "number") {
          if (it)
            o3 = it;
          var i3 = 0;
          return function() {
            if (i3 >= o3.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o3[i3++]
            };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      it = o3[Symbol.iterator]();
      return it.next.bind(it);
    }
    __name(_createForOfIteratorHelperLoose, "_createForOfIteratorHelperLoose");
    function createCommonjsModule(fn) {
      var module3 = {exports: {}};
      return fn(module3, module3.exports), module3.exports;
    }
    __name(createCommonjsModule, "createCommonjsModule");
    var defaults$5 = createCommonjsModule(function(module3) {
      function getDefaults2() {
        return {
          baseUrl: null,
          breaks: false,
          gfm: true,
          headerIds: true,
          headerPrefix: "",
          highlight: null,
          langPrefix: "language-",
          mangle: true,
          pedantic: false,
          renderer: null,
          sanitize: false,
          sanitizer: null,
          silent: false,
          smartLists: false,
          smartypants: false,
          tokenizer: null,
          walkTokens: null,
          xhtml: false
        };
      }
      __name(getDefaults2, "getDefaults");
      function changeDefaults2(newDefaults) {
        module3.exports.defaults = newDefaults;
      }
      __name(changeDefaults2, "changeDefaults");
      module3.exports = {
        defaults: getDefaults2(),
        getDefaults: getDefaults2,
        changeDefaults: changeDefaults2
      };
    });
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = /* @__PURE__ */ __name(function getEscapeReplacement2(ch) {
      return escapeReplacements[ch];
    }, "getEscapeReplacement");
    function escape$2(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    __name(escape$2, "escape$2");
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape$1(html) {
      return html.replace(unescapeTest, function(_2, n2) {
        n2 = n2.toLowerCase();
        if (n2 === "colon")
          return ":";
        if (n2.charAt(0) === "#") {
          return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
        }
        return "";
      });
    }
    __name(unescape$1, "unescape$1");
    var caret = /(^|[^\[])\^/g;
    function edit$1(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      var obj = {
        replace: /* @__PURE__ */ __name(function replace(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        }, "replace"),
        getRegex: /* @__PURE__ */ __name(function getRegex() {
          return new RegExp(regex, opt);
        }, "getRegex")
      };
      return obj;
    }
    __name(edit$1, "edit$1");
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl$1(sanitize2, base, href) {
      if (sanitize2) {
        var prot;
        try {
          prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e3) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e3) {
        return null;
      }
      return href;
    }
    __name(cleanUrl$1, "cleanUrl$1");
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim$1(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      var relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    __name(resolveUrl, "resolveUrl");
    var noopTest$1 = {
      exec: /* @__PURE__ */ __name(function noopTest2() {
      }, "noopTest")
    };
    function merge$2(obj) {
      var i3 = 1, target2, key;
      for (; i3 < arguments.length; i3++) {
        target2 = arguments[i3];
        for (key in target2) {
          if (Object.prototype.hasOwnProperty.call(target2, key)) {
            obj[key] = target2[key];
          }
        }
      }
      return obj;
    }
    __name(merge$2, "merge$2");
    function splitCells$1(tableRow, count) {
      var row = tableRow.replace(/\|/g, function(match, offset3, str) {
        var escaped = false, curr = offset3;
        while (--curr >= 0 && str[curr] === "\\") {
          escaped = !escaped;
        }
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      var i3 = 0;
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) {
          cells.push("");
        }
      }
      for (; i3 < cells.length; i3++) {
        cells[i3] = cells[i3].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    __name(splitCells$1, "splitCells$1");
    function rtrim$1(str, c3, invert) {
      var l3 = str.length;
      if (l3 === 0) {
        return "";
      }
      var suffLen = 0;
      while (suffLen < l3) {
        var currChar = str.charAt(l3 - suffLen - 1);
        if (currChar === c3 && !invert) {
          suffLen++;
        } else if (currChar !== c3 && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l3 - suffLen);
    }
    __name(rtrim$1, "rtrim$1");
    function findClosingBracket$1(str, b3) {
      if (str.indexOf(b3[1]) === -1) {
        return -1;
      }
      var l3 = str.length;
      var level = 0, i3 = 0;
      for (; i3 < l3; i3++) {
        if (str[i3] === "\\") {
          i3++;
        } else if (str[i3] === b3[0]) {
          level++;
        } else if (str[i3] === b3[1]) {
          level--;
          if (level < 0) {
            return i3;
          }
        }
      }
      return -1;
    }
    __name(findClosingBracket$1, "findClosingBracket$1");
    function checkSanitizeDeprecation$1(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    __name(checkSanitizeDeprecation$1, "checkSanitizeDeprecation$1");
    function repeatString$1(pattern, count) {
      if (count < 1) {
        return "";
      }
      var result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    __name(repeatString$1, "repeatString$1");
    var helpers = {
      escape: escape$2,
      unescape: unescape$1,
      edit: edit$1,
      cleanUrl: cleanUrl$1,
      resolveUrl,
      noopTest: noopTest$1,
      merge: merge$2,
      splitCells: splitCells$1,
      rtrim: rtrim$1,
      findClosingBracket: findClosingBracket$1,
      checkSanitizeDeprecation: checkSanitizeDeprecation$1,
      repeatString: repeatString$1
    };
    var defaults$4 = defaults$5.defaults;
    var rtrim = helpers.rtrim, splitCells = helpers.splitCells, _escape = helpers.escape, findClosingBracket = helpers.findClosingBracket;
    function outputLink(cap, link, raw) {
      var href = link.href;
      var title = link.title ? _escape(link.title) : null;
      var text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        return {
          type: "link",
          raw,
          href,
          title,
          text
        };
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: _escape(text)
        };
      }
    }
    __name(outputLink, "outputLink");
    function indentCodeCompensation(raw, text) {
      var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      var indentToCode = matchIndentToCode[1];
      return text.split("\n").map(function(node) {
        var matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        var indentInNode = matchIndentInNode[0];
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    __name(indentCodeCompensation, "indentCodeCompensation");
    var Tokenizer_1 = /* @__PURE__ */ function() {
      function Tokenizer(options) {
        this.options = options || defaults$4;
      }
      __name(Tokenizer, "Tokenizer");
      var _proto = Tokenizer.prototype;
      _proto.space = /* @__PURE__ */ __name(function space(src) {
        var cap = this.rules.block.newline.exec(src);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
          return {
            raw: "\n"
          };
        }
      }, "space");
      _proto.code = /* @__PURE__ */ __name(function code(src) {
        var cap = this.rules.block.code.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }, "code");
      _proto.fences = /* @__PURE__ */ __name(function fences(src) {
        var cap = this.rules.block.fences.exec(src);
        if (cap) {
          var raw = cap[0];
          var text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      }, "fences");
      _proto.heading = /* @__PURE__ */ __name(function heading(src) {
        var cap = this.rules.block.heading.exec(src);
        if (cap) {
          var text = cap[2].trim();
          if (/#$/.test(text)) {
            var trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text
          };
        }
      }, "heading");
      _proto.nptable = /* @__PURE__ */ __name(function nptable(src) {
        var cap = this.rules.block.nptable.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : [],
            raw: cap[0]
          };
          if (item.header.length === item.align.length) {
            var l3 = item.align.length;
            var i3;
            for (i3 = 0; i3 < l3; i3++) {
              if (/^ *-+: *$/.test(item.align[i3])) {
                item.align[i3] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i3])) {
                item.align[i3] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i3])) {
                item.align[i3] = "left";
              } else {
                item.align[i3] = null;
              }
            }
            l3 = item.cells.length;
            for (i3 = 0; i3 < l3; i3++) {
              item.cells[i3] = splitCells(item.cells[i3], item.header.length);
            }
            return item;
          }
        }
      }, "nptable");
      _proto.hr = /* @__PURE__ */ __name(function hr(src) {
        var cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }, "hr");
      _proto.blockquote = /* @__PURE__ */ __name(function blockquote(src) {
        var cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          var text = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            text
          };
        }
      }, "blockquote");
      _proto.list = /* @__PURE__ */ __name(function list(src) {
        var cap = this.rules.block.list.exec(src);
        if (cap) {
          var raw = cap[0];
          var bull = cap[2];
          var isordered = bull.length > 1;
          var list2 = {
            type: "list",
            raw,
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          var itemMatch = cap[0].match(this.rules.block.item);
          var next = false, item, space, bcurr, bnext, addBack, loose, istask, ischecked, endMatch;
          var l3 = itemMatch.length;
          bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
          for (var i3 = 0; i3 < l3; i3++) {
            item = itemMatch[i3];
            raw = item;
            if (!this.options.pedantic) {
              endMatch = item.match(new RegExp("\\n\\s*\\n {0," + (bcurr[0].length - 1) + "}\\S"));
              if (endMatch) {
                addBack = item.length - endMatch.index + itemMatch.slice(i3 + 1).join("\n").length;
                list2.raw = list2.raw.substring(0, list2.raw.length - addBack);
                item = item.substring(0, endMatch.index);
                raw = item;
                l3 = i3 + 1;
              }
            }
            if (i3 !== l3 - 1) {
              bnext = this.rules.block.listItemStart.exec(itemMatch[i3 + 1]);
              if (!this.options.pedantic ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
                itemMatch.splice(i3, 2, itemMatch[i3] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i3].match(/\n$/) ? "" : "\n") + itemMatch[i3 + 1]);
                i3--;
                l3--;
                continue;
              } else if (!this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                addBack = itemMatch.slice(i3 + 1).join("\n").length;
                list2.raw = list2.raw.substring(0, list2.raw.length - addBack);
                i3 = l3 - 1;
              }
              bcurr = bnext;
            }
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+[.)]) ?/, "");
            if (~item.indexOf("\n ")) {
              space -= item.length;
              item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
            }
            item = rtrim(item, "\n");
            if (i3 !== l3 - 1) {
              raw = raw + "\n";
            }
            loose = next || /\n\n(?!\s*$)/.test(raw);
            if (i3 !== l3 - 1) {
              next = raw.slice(-2) === "\n\n";
              if (!loose)
                loose = next;
            }
            if (loose) {
              list2.loose = true;
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.test(item);
              ischecked = void 0;
              if (istask) {
                ischecked = item[1] !== " ";
                item = item.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: istask,
              checked: ischecked,
              loose,
              text: item
            });
          }
          return list2;
        }
      }, "list");
      _proto.html = /* @__PURE__ */ __name(function html(src) {
        var cap = this.rules.block.html.exec(src);
        if (cap) {
          return {
            type: this.options.sanitize ? "paragraph" : "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
          };
        }
      }, "html");
      _proto.def = /* @__PURE__ */ __name(function def(src) {
        var cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }, "def");
      _proto.table = /* @__PURE__ */ __name(function table(src) {
        var cap = this.rules.block.table.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            var l3 = item.align.length;
            var i3;
            for (i3 = 0; i3 < l3; i3++) {
              if (/^ *-+: *$/.test(item.align[i3])) {
                item.align[i3] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i3])) {
                item.align[i3] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i3])) {
                item.align[i3] = "left";
              } else {
                item.align[i3] = null;
              }
            }
            l3 = item.cells.length;
            for (i3 = 0; i3 < l3; i3++) {
              item.cells[i3] = splitCells(item.cells[i3].replace(/^ *\| *| *\| *$/g, ""), item.header.length);
            }
            return item;
          }
        }
      }, "table");
      _proto.lheading = /* @__PURE__ */ __name(function lheading(src) {
        var cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1]
          };
        }
      }, "lheading");
      _proto.paragraph = /* @__PURE__ */ __name(function paragraph(src) {
        var cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          return {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
          };
        }
      }, "paragraph");
      _proto.text = /* @__PURE__ */ __name(function text(src) {
        var cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0]
          };
        }
      }, "text");
      _proto.escape = /* @__PURE__ */ __name(function escape3(src) {
        var cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: _escape(cap[1])
          };
        }
      }, "escape");
      _proto.tag = /* @__PURE__ */ __name(function tag(src, inLink, inRawBlock) {
        var cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!inLink && /^<a /i.test(cap[0])) {
            inLink = true;
          } else if (inLink && /^<\/a>/i.test(cap[0])) {
            inLink = false;
          }
          if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = true;
          } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink,
            inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
          };
        }
      }, "tag");
      _proto.link = /* @__PURE__ */ __name(function link(src) {
        var cap = this.rules.inline.link.exec(src);
        if (cap) {
          var trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            var lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              var start = cap[0].indexOf("!") === 0 ? 5 : 4;
              var linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          var href = cap[2];
          var title = "";
          if (this.options.pedantic) {
            var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0]);
        }
      }, "link");
      _proto.reflink = /* @__PURE__ */ __name(function reflink(src, links) {
        var cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            var text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0]);
        }
      }, "reflink");
      _proto.emStrong = /* @__PURE__ */ __name(function emStrong(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))
          return;
        var nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          var lLength = match[0].length - 1;
          var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          var endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            if (delimTotal + midDelimTotal - rLength <= 0 && !maskedSrc.slice(endReg.lastIndex).match(endReg)) {
              rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            }
            if (Math.min(lLength, rLength) % 2) {
              return {
                type: "em",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: src.slice(1, lLength + match.index + rLength)
              };
            }
            if (Math.min(lLength, rLength) % 2 === 0) {
              return {
                type: "strong",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: src.slice(2, lLength + match.index + rLength - 1)
              };
            }
          }
        }
      }, "emStrong");
      _proto.codespan = /* @__PURE__ */ __name(function codespan(src) {
        var cap = this.rules.inline.code.exec(src);
        if (cap) {
          var text = cap[2].replace(/\n/g, " ");
          var hasNonSpaceChars = /[^ ]/.test(text);
          var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = _escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }, "codespan");
      _proto.br = /* @__PURE__ */ __name(function br(src) {
        var cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }, "br");
      _proto.del = /* @__PURE__ */ __name(function del(src) {
        var cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2]
          };
        }
      }, "del");
      _proto.autolink = /* @__PURE__ */ __name(function autolink(src, mangle2) {
        var cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          var text, href;
          if (cap[2] === "@") {
            text = _escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = _escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      }, "autolink");
      _proto.url = /* @__PURE__ */ __name(function url(src, mangle2) {
        var cap;
        if (cap = this.rules.inline.url.exec(src)) {
          var text, href;
          if (cap[2] === "@") {
            text = _escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            var prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = _escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [{
              type: "text",
              raw: text,
              text
            }]
          };
        }
      }, "url");
      _proto.inlineText = /* @__PURE__ */ __name(function inlineText(src, inRawBlock, smartypants2) {
        var cap = this.rules.inline.text.exec(src);
        if (cap) {
          var text;
          if (inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
          } else {
            text = _escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }, "inlineText");
      return Tokenizer;
    }();
    var noopTest = helpers.noopTest, edit = helpers.edit, merge$1 = helpers.merge;
    var block$1 = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
      html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))",
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noopTest,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block$1._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block$1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block$1.def = edit(block$1.def).replace("label", block$1._label).replace("title", block$1._title).getRegex();
    block$1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block$1.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
    block$1.item = edit(block$1.item, "gm").replace(/bull/g, block$1.bullet).getRegex();
    block$1.listItemStart = edit(/^( *)(bull) */).replace("bull", block$1.bullet).getRegex();
    block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block$1.def.source + ")").getRegex();
    block$1._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block$1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block$1.html = edit(block$1.html, "i").replace("comment", block$1._comment).replace("tag", block$1._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block$1.paragraph = edit(block$1._paragraph).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block$1._tag).getRegex();
    block$1.blockquote = edit(block$1.blockquote).replace("paragraph", block$1.paragraph).getRegex();
    block$1.normal = merge$1({}, block$1);
    block$1.gfm = merge$1({}, block$1.normal, {
      nptable: "^ *([^|\\n ].*\\|.*)\\n {0,3}([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
      table: "^ *\\|(.+)\\n {0,3}\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block$1.gfm.nptable = edit(block$1.gfm.nptable).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block$1._tag).getRegex();
    block$1.gfm.table = edit(block$1.gfm.table).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block$1._tag).getRegex();
    block$1.pedantic = merge$1({}, block$1.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block$1._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      paragraph: edit(block$1.normal._paragraph).replace("hr", block$1.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block$1.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline$1 = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /\_\_[^_]*?\*[^_]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /\*\*[^*]*?\_[^*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline$1._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex();
    inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline$1.escapedEmSt = /\\\*|\\_/g;
    inline$1._comment = edit(block$1._comment).replace("(?:-->|$)", "-->").getRegex();
    inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();
    inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, "g").replace(/punct/g, inline$1._punctuation).getRegex();
    inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, "g").replace(/punct/g, inline$1._punctuation).getRegex();
    inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline$1.autolink = edit(inline$1.autolink).replace("scheme", inline$1._scheme).replace("email", inline$1._email).getRegex();
    inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline$1.tag = edit(inline$1.tag).replace("comment", inline$1._comment).replace("attribute", inline$1._attribute).getRegex();
    inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline$1.link = edit(inline$1.link).replace("label", inline$1._label).replace("href", inline$1._href).replace("title", inline$1._title).getRegex();
    inline$1.reflink = edit(inline$1.reflink).replace("label", inline$1._label).getRegex();
    inline$1.reflinkSearch = edit(inline$1.reflinkSearch, "g").replace("reflink", inline$1.reflink).replace("nolink", inline$1.nolink).getRegex();
    inline$1.normal = merge$1({}, inline$1);
    inline$1.pedantic = merge$1({}, inline$1.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline$1._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline$1._label).getRegex()
    });
    inline$1.gfm = merge$1({}, inline$1.normal, {
      escape: edit(inline$1.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
    });
    inline$1.gfm.url = edit(inline$1.gfm.url, "i").replace("email", inline$1.gfm._extended_email).getRegex();
    inline$1.breaks = merge$1({}, inline$1.gfm, {
      br: edit(inline$1.br).replace("{2,}", "*").getRegex(),
      text: edit(inline$1.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    var rules = {
      block: block$1,
      inline: inline$1
    };
    var defaults$3 = defaults$5.defaults;
    var block = rules.block, inline = rules.inline;
    var repeatString = helpers.repeatString;
    function smartypants(text) {
      return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    __name(smartypants, "smartypants");
    function mangle(text) {
      var out = "", i3, ch;
      var l3 = text.length;
      for (i3 = 0; i3 < l3; i3++) {
        ch = text.charCodeAt(i3);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    __name(mangle, "mangle");
    var Lexer_1 = /* @__PURE__ */ function() {
      function Lexer(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults$3;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        var rules2 = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules2.block = block.pedantic;
          rules2.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules2.block = block.gfm;
          if (this.options.breaks) {
            rules2.inline = inline.breaks;
          } else {
            rules2.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules2;
      }
      __name(Lexer, "Lexer");
      Lexer.lex = /* @__PURE__ */ __name(function lex(src, options) {
        var lexer = new Lexer(options);
        return lexer.lex(src);
      }, "lex");
      Lexer.lexInline = /* @__PURE__ */ __name(function lexInline(src, options) {
        var lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }, "lexInline");
      var _proto = Lexer.prototype;
      _proto.lex = /* @__PURE__ */ __name(function lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens, true);
        this.inline(this.tokens);
        return this.tokens;
      }, "lex");
      _proto.blockTokens = /* @__PURE__ */ __name(function blockTokens(src, tokens, top) {
        if (tokens === void 0) {
          tokens = [];
        }
        if (top === void 0) {
          top = true;
        }
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, "");
        }
        var token, i3, l3, lastToken;
        while (src) {
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.nptable(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.blockTokens(token.text, [], top);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            l3 = token.items.length;
            for (i3 = 0; i3 < l3; i3++) {
              token.items[i3].tokens = this.blockTokens(token.items[i3].text, [], false);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.def(src))) {
            src = src.substring(token.raw.length);
            if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.paragraph(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }, "blockTokens");
      _proto.inline = /* @__PURE__ */ __name(function inline2(tokens) {
        var i3, j3, k3, l22, row, token;
        var l3 = tokens.length;
        for (i3 = 0; i3 < l3; i3++) {
          token = tokens[i3];
          switch (token.type) {
            case "paragraph":
            case "text":
            case "heading": {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }
            case "table": {
              token.tokens = {
                header: [],
                cells: []
              };
              l22 = token.header.length;
              for (j3 = 0; j3 < l22; j3++) {
                token.tokens.header[j3] = [];
                this.inlineTokens(token.header[j3], token.tokens.header[j3]);
              }
              l22 = token.cells.length;
              for (j3 = 0; j3 < l22; j3++) {
                row = token.cells[j3];
                token.tokens.cells[j3] = [];
                for (k3 = 0; k3 < row.length; k3++) {
                  token.tokens.cells[j3][k3] = [];
                  this.inlineTokens(row[k3], token.tokens.cells[j3][k3]);
                }
              }
              break;
            }
            case "blockquote": {
              this.inline(token.tokens);
              break;
            }
            case "list": {
              l22 = token.items.length;
              for (j3 = 0; j3 < l22; j3++) {
                this.inline(token.items[j3].tokens);
              }
              break;
            }
          }
        }
        return tokens;
      }, "inline");
      _proto.inlineTokens = /* @__PURE__ */ __name(function inlineTokens(src, tokens, inLink, inRawBlock) {
        if (tokens === void 0) {
          tokens = [];
        }
        if (inLink === void 0) {
          inLink = false;
        }
        if (inRawBlock === void 0) {
          inRawBlock = false;
        }
        var token, lastToken;
        var maskedSrc = src;
        var match;
        var keepPrevChar, prevChar;
        if (this.tokens.links) {
          var links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
            src = src.substring(token.raw.length);
            inLink = token.inLink;
            inRawBlock = token.inRawBlock;
            var _lastToken = tokens[tokens.length - 1];
            if (_lastToken && token.type === "text" && _lastToken.type === "text") {
              _lastToken.raw += token.raw;
              _lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            var _lastToken2 = tokens[tokens.length - 1];
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
              tokens.push(token);
            } else if (_lastToken2 && token.type === "text" && _lastToken2.type === "text") {
              _lastToken2.raw += token.raw;
              _lastToken2.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }, "inlineTokens");
      _createClass(Lexer, null, [{
        key: "rules",
        get: /* @__PURE__ */ __name(function get() {
          return {
            block,
            inline
          };
        }, "get")
      }]);
      return Lexer;
    }();
    var defaults$2 = defaults$5.defaults;
    var cleanUrl = helpers.cleanUrl, escape$1 = helpers.escape;
    var Renderer_1 = /* @__PURE__ */ function() {
      function Renderer(options) {
        this.options = options || defaults$2;
      }
      __name(Renderer, "Renderer");
      var _proto = Renderer.prototype;
      _proto.code = /* @__PURE__ */ __name(function code(_code, infostring, escaped) {
        var lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(_code, lang);
          if (out != null && out !== _code) {
            escaped = true;
            _code = out;
          }
        }
        _code = _code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
      }, "code");
      _proto.blockquote = /* @__PURE__ */ __name(function blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      }, "blockquote");
      _proto.html = /* @__PURE__ */ __name(function html(_html) {
        return _html;
      }, "html");
      _proto.heading = /* @__PURE__ */ __name(function heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      }, "heading");
      _proto.hr = /* @__PURE__ */ __name(function hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }, "hr");
      _proto.list = /* @__PURE__ */ __name(function list(body, ordered, start) {
        var type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }, "list");
      _proto.listitem = /* @__PURE__ */ __name(function listitem(text) {
        return "<li>" + text + "</li>\n";
      }, "listitem");
      _proto.checkbox = /* @__PURE__ */ __name(function checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }, "checkbox");
      _proto.paragraph = /* @__PURE__ */ __name(function paragraph(text) {
        return "<p>" + text + "</p>\n";
      }, "paragraph");
      _proto.table = /* @__PURE__ */ __name(function table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }, "table");
      _proto.tablerow = /* @__PURE__ */ __name(function tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }, "tablerow");
      _proto.tablecell = /* @__PURE__ */ __name(function tablecell(content, flags) {
        var type = flags.header ? "th" : "td";
        var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }, "tablecell");
      _proto.strong = /* @__PURE__ */ __name(function strong(text) {
        return "<strong>" + text + "</strong>";
      }, "strong");
      _proto.em = /* @__PURE__ */ __name(function em(text) {
        return "<em>" + text + "</em>";
      }, "em");
      _proto.codespan = /* @__PURE__ */ __name(function codespan(text) {
        return "<code>" + text + "</code>";
      }, "codespan");
      _proto.br = /* @__PURE__ */ __name(function br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }, "br");
      _proto.del = /* @__PURE__ */ __name(function del(text) {
        return "<del>" + text + "</del>";
      }, "del");
      _proto.link = /* @__PURE__ */ __name(function link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<a href="' + escape$1(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }, "link");
      _proto.image = /* @__PURE__ */ __name(function image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        var out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }, "image");
      _proto.text = /* @__PURE__ */ __name(function text(_text) {
        return _text;
      }, "text");
      return Renderer;
    }();
    var TextRenderer_1 = /* @__PURE__ */ function() {
      function TextRenderer() {
      }
      __name(TextRenderer, "TextRenderer");
      var _proto = TextRenderer.prototype;
      _proto.strong = /* @__PURE__ */ __name(function strong(text) {
        return text;
      }, "strong");
      _proto.em = /* @__PURE__ */ __name(function em(text) {
        return text;
      }, "em");
      _proto.codespan = /* @__PURE__ */ __name(function codespan(text) {
        return text;
      }, "codespan");
      _proto.del = /* @__PURE__ */ __name(function del(text) {
        return text;
      }, "del");
      _proto.html = /* @__PURE__ */ __name(function html(text) {
        return text;
      }, "html");
      _proto.text = /* @__PURE__ */ __name(function text(_text) {
        return _text;
      }, "text");
      _proto.link = /* @__PURE__ */ __name(function link(href, title, text) {
        return "" + text;
      }, "link");
      _proto.image = /* @__PURE__ */ __name(function image(href, title, text) {
        return "" + text;
      }, "image");
      _proto.br = /* @__PURE__ */ __name(function br() {
        return "";
      }, "br");
      return TextRenderer;
    }();
    var Slugger_1 = /* @__PURE__ */ function() {
      function Slugger() {
        this.seen = {};
      }
      __name(Slugger, "Slugger");
      var _proto = Slugger.prototype;
      _proto.serialize = /* @__PURE__ */ __name(function serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }, "serialize");
      _proto.getNextSafeSlug = /* @__PURE__ */ __name(function getNextSafeSlug(originalSlug, isDryRun) {
        var slug = originalSlug;
        var occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }, "getNextSafeSlug");
      _proto.slug = /* @__PURE__ */ __name(function slug(value, options) {
        if (options === void 0) {
          options = {};
        }
        var slug2 = this.serialize(value);
        return this.getNextSafeSlug(slug2, options.dryrun);
      }, "slug");
      return Slugger;
    }();
    var defaults$1 = defaults$5.defaults;
    var unescape = helpers.unescape;
    var Parser_1 = /* @__PURE__ */ function() {
      function Parser(options) {
        this.options = options || defaults$1;
        this.options.renderer = this.options.renderer || new Renderer_1();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer_1();
        this.slugger = new Slugger_1();
      }
      __name(Parser, "Parser");
      Parser.parse = /* @__PURE__ */ __name(function parse(tokens, options) {
        var parser = new Parser(options);
        return parser.parse(tokens);
      }, "parse");
      Parser.parseInline = /* @__PURE__ */ __name(function parseInline(tokens, options) {
        var parser = new Parser(options);
        return parser.parseInline(tokens);
      }, "parseInline");
      var _proto = Parser.prototype;
      _proto.parse = /* @__PURE__ */ __name(function parse(tokens, top) {
        if (top === void 0) {
          top = true;
        }
        var out = "", i3, j3, k3, l22, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox;
        var l4 = tokens.length;
        for (i3 = 0; i3 < l4; i3++) {
          token = tokens[i3];
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l22 = token.header.length;
              for (j3 = 0; j3 < l22; j3++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j3]), {
                  header: true,
                  align: token.align[j3]
                });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l22 = token.cells.length;
              for (j3 = 0; j3 < l22; j3++) {
                row = token.tokens.cells[j3];
                cell = "";
                l3 = row.length;
                for (k3 = 0; k3 < l3; k3++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k3]), {
                    header: false,
                    align: token.align[k3]
                  });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l22 = token.items.length;
              body = "";
              for (j3 = 0; j3 < l22; j3++) {
                item = token.items[j3];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "text") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i3 + 1 < l4 && tokens[i3 + 1].type === "text") {
                token = tokens[++i3];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }, "parse");
      _proto.parseInline = /* @__PURE__ */ __name(function parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = "", i3, token;
        var l3 = tokens.length;
        for (i3 = 0; i3 < l3; i3++) {
          token = tokens[i3];
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }, "parseInline");
      return Parser;
    }();
    var merge = helpers.merge, checkSanitizeDeprecation = helpers.checkSanitizeDeprecation, escape2 = helpers.escape;
    var getDefaults = defaults$5.getDefaults, changeDefaults = defaults$5.changeDefaults, defaults = defaults$5.defaults;
    function marked2(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        var highlight = opt.highlight;
        var tokens;
        try {
          tokens = Lexer_1.lex(src, opt);
        } catch (e3) {
          return callback(e3);
        }
        var done = /* @__PURE__ */ __name(function done2(err) {
          var out;
          if (!err) {
            try {
              out = Parser_1.parse(tokens, opt);
            } catch (e3) {
              err = e3;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        }, "done");
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        var pending2 = 0;
        marked2.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending2++;
            setTimeout(function() {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending2--;
                if (pending2 === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending2 === 0) {
          done();
        }
        return;
      }
      try {
        var _tokens = Lexer_1.lex(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(_tokens, opt.walkTokens);
        }
        return Parser_1.parse(_tokens, opt);
      } catch (e3) {
        e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape2(e3.message + "", true) + "</pre>";
        }
        throw e3;
      }
    }
    __name(marked2, "marked");
    marked2.options = marked2.setOptions = function(opt) {
      merge(marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults;
    marked2.defaults = defaults;
    marked2.use = function(extension) {
      var opts = merge({}, extension);
      if (extension.renderer) {
        (function() {
          var renderer = marked2.defaults.renderer || new Renderer_1();
          var _loop = /* @__PURE__ */ __name(function _loop2(prop2) {
            var prevRenderer = renderer[prop2];
            renderer[prop2] = function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var ret = extension.renderer[prop2].apply(renderer, args);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args);
              }
              return ret;
            };
          }, "_loop");
          for (var prop in extension.renderer) {
            _loop(prop);
          }
          opts.renderer = renderer;
        })();
      }
      if (extension.tokenizer) {
        (function() {
          var tokenizer = marked2.defaults.tokenizer || new Tokenizer_1();
          var _loop2 = /* @__PURE__ */ __name(function _loop22(prop2) {
            var prevTokenizer = tokenizer[prop2];
            tokenizer[prop2] = function() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              var ret = extension.tokenizer[prop2].apply(tokenizer, args);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args);
              }
              return ret;
            };
          }, "_loop2");
          for (var prop in extension.tokenizer) {
            _loop2(prop);
          }
          opts.tokenizer = tokenizer;
        })();
      }
      if (extension.walkTokens) {
        var walkTokens = marked2.defaults.walkTokens;
        opts.walkTokens = function(token) {
          extension.walkTokens(token);
          if (walkTokens) {
            walkTokens(token);
          }
        };
      }
      marked2.setOptions(opts);
    };
    marked2.walkTokens = function(tokens, callback) {
      for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
        var token = _step.value;
        callback(token);
        switch (token.type) {
          case "table": {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done; ) {
              var cell = _step2.value;
              marked2.walkTokens(cell, callback);
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done; ) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                var _cell = _step4.value;
                marked2.walkTokens(_cell, callback);
              }
            }
            break;
          }
          case "list": {
            marked2.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (token.tokens) {
              marked2.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked2.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        var tokens = Lexer_1.lexInline(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser_1.parseInline(tokens, opt);
      } catch (e3) {
        e3.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape2(e3.message + "", true) + "</pre>";
        }
        throw e3;
      }
    };
    marked2.Parser = Parser_1;
    marked2.parser = Parser_1.parse;
    marked2.Renderer = Renderer_1;
    marked2.TextRenderer = TextRenderer_1;
    marked2.Lexer = Lexer_1;
    marked2.lexer = Lexer_1.lex;
    marked2.Tokenizer = Tokenizer_1;
    marked2.Slugger = Slugger_1;
    marked2.parse = marked2;
    var marked_1 = marked2;
    return marked_1;
  });
});

// src/server.ts
__markAsModule(exports);
__export(exports, {
  Game: () => MazingContest,
  Network: () => MazingContestNetwork,
  withGame: () => withMazingContest
});

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var o;
var r = {};
var f = [];
var e = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function c(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
__name(c, "c");
function s(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
__name(s, "s");
function a(n2, l3, u3) {
  var i3, t3, o3, r3 = arguments, f3 = {};
  for (o3 in l3)
    o3 == "key" ? i3 = l3[o3] : o3 == "ref" ? t3 = l3[o3] : f3[o3] = l3[o3];
  if (arguments.length > 3)
    for (u3 = [u3], o3 = 3; o3 < arguments.length; o3++)
      u3.push(r3[o3]);
  if (u3 != null && (f3.children = u3), typeof n2 == "function" && n2.defaultProps != null)
    for (o3 in n2.defaultProps)
      f3[o3] === void 0 && (f3[o3] = n2.defaultProps[o3]);
  return v(n2, f3, i3, t3, null);
}
__name(a, "a");
function v(l3, u3, i3, t3, o3) {
  var r3 = {type: l3, props: u3, key: i3, ref: t3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: o3 == null ? ++n.__v : o3};
  return n.vnode != null && n.vnode(r3), r3;
}
__name(v, "v");
function y(n2) {
  return n2.children;
}
__name(y, "y");
function p(n2, l3) {
  this.props = n2, this.context = l3;
}
__name(p, "p");
function d(n2, l3) {
  if (l3 == null)
    return n2.__ ? d(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if ((u3 = n2.__k[l3]) != null && u3.__e != null)
      return u3.__e;
  return typeof n2.type == "function" ? d(n2) : null;
}
__name(d, "d");
function _(n2) {
  var l3, u3;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if ((u3 = n2.__k[l3]) != null && u3.__e != null) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return _(n2);
  }
}
__name(_, "_");
function k(l3) {
  (!l3.__d && (l3.__d = true) && u.push(l3) && !b.__r++ || t !== n.debounceRendering) && ((t = n.debounceRendering) || i)(b);
}
__name(k, "k");
function b() {
  for (var n2; b.__r = u.length; )
    n2 = u.sort(function(n3, l3) {
      return n3.__v.__b - l3.__v.__b;
    }), u = [], n2.some(function(n3) {
      var l3, u3, i3, t3, o3, r3;
      n3.__d && (o3 = (t3 = (l3 = n3).__v).__e, (r3 = l3.__P) && (u3 = [], (i3 = c({}, t3)).__v = t3.__v + 1, I(r3, t3, i3, l3.__n, r3.ownerSVGElement !== void 0, t3.__h != null ? [o3] : null, u3, o3 == null ? d(t3) : o3, t3.__h), T(u3, t3), t3.__e != o3 && _(t3)));
    });
}
__name(b, "b");
function m(n2, l3, u3, i3, t3, o3, e3, c3, s3, a3) {
  var h, p3, _2, k3, b3, m3, w3, A3 = i3 && i3.__k || f, P2 = A3.length;
  for (u3.__k = [], h = 0; h < l3.length; h++)
    if ((k3 = u3.__k[h] = (k3 = l3[h]) == null || typeof k3 == "boolean" ? null : typeof k3 == "string" || typeof k3 == "number" || typeof k3 == "bigint" ? v(null, k3, null, null, k3) : Array.isArray(k3) ? v(y, {children: k3}, null, null, null) : k3.__b > 0 ? v(k3.type, k3.props, k3.key, null, k3.__v) : k3) != null) {
      if (k3.__ = u3, k3.__b = u3.__b + 1, (_2 = A3[h]) === null || _2 && k3.key == _2.key && k3.type === _2.type)
        A3[h] = void 0;
      else
        for (p3 = 0; p3 < P2; p3++) {
          if ((_2 = A3[p3]) && k3.key == _2.key && k3.type === _2.type) {
            A3[p3] = void 0;
            break;
          }
          _2 = null;
        }
      I(n2, k3, _2 = _2 || r, t3, o3, e3, c3, s3, a3), b3 = k3.__e, (p3 = k3.ref) && _2.ref != p3 && (w3 || (w3 = []), _2.ref && w3.push(_2.ref, null, k3), w3.push(p3, k3.__c || b3, k3)), b3 != null ? (m3 == null && (m3 = b3), typeof k3.type == "function" && k3.__k != null && k3.__k === _2.__k ? k3.__d = s3 = g(k3, s3, n2) : s3 = x(n2, k3, _2, A3, b3, s3), a3 || u3.type !== "option" ? typeof u3.type == "function" && (u3.__d = s3) : n2.value = "") : s3 && _2.__e == s3 && s3.parentNode != n2 && (s3 = d(_2));
    }
  for (u3.__e = m3, h = P2; h--; )
    A3[h] != null && (typeof u3.type == "function" && A3[h].__e != null && A3[h].__e == u3.__d && (u3.__d = d(i3, h + 1)), L(A3[h], A3[h]));
  if (w3)
    for (h = 0; h < w3.length; h++)
      z(w3[h], w3[++h], w3[++h]);
}
__name(m, "m");
function g(n2, l3, u3) {
  var i3, t3;
  for (i3 = 0; i3 < n2.__k.length; i3++)
    (t3 = n2.__k[i3]) && (t3.__ = n2, l3 = typeof t3.type == "function" ? g(t3, l3, u3) : x(u3, t3, t3, n2.__k, t3.__e, l3));
  return l3;
}
__name(g, "g");
function w(n2, l3) {
  return l3 = l3 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    w(n3, l3);
  }) : l3.push(n2)), l3;
}
__name(w, "w");
function x(n2, l3, u3, i3, t3, o3) {
  var r3, f3, e3;
  if (l3.__d !== void 0)
    r3 = l3.__d, l3.__d = void 0;
  else if (u3 == null || t3 != o3 || t3.parentNode == null)
    n:
      if (o3 == null || o3.parentNode !== n2)
        n2.appendChild(t3), r3 = null;
      else {
        for (f3 = o3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 2)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, o3), r3 = o3;
      }
  return r3 !== void 0 ? r3 : t3.nextSibling;
}
__name(x, "x");
function A(n2, l3, u3, i3, t3) {
  var o3;
  for (o3 in u3)
    o3 === "children" || o3 === "key" || o3 in l3 || C(n2, o3, null, u3[o3], i3);
  for (o3 in l3)
    t3 && typeof l3[o3] != "function" || o3 === "children" || o3 === "key" || o3 === "value" || o3 === "checked" || u3[o3] === l3[o3] || C(n2, o3, l3[o3], u3[o3], i3);
}
__name(A, "A");
function P(n2, l3, u3) {
  l3[0] === "-" ? n2.setProperty(l3, u3) : n2[l3] = u3 == null ? "" : typeof u3 != "number" || e.test(l3) ? u3 : u3 + "px";
}
__name(P, "P");
function C(n2, l3, u3, i3, t3) {
  var o3;
  n:
    if (l3 === "style")
      if (typeof u3 == "string")
        n2.style.cssText = u3;
      else {
        if (typeof i3 == "string" && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || P(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || P(n2.style, l3, u3[l3]);
      }
    else if (l3[0] === "o" && l3[1] === "n")
      o3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + o3] = u3, u3 ? i3 || n2.addEventListener(l3, o3 ? H : $, o3) : n2.removeEventListener(l3, o3 ? H : $, o3);
    else if (l3 !== "dangerouslySetInnerHTML") {
      if (t3)
        l3 = l3.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if (l3 !== "href" && l3 !== "list" && l3 !== "form" && l3 !== "tabIndex" && l3 !== "download" && l3 in n2)
        try {
          n2[l3] = u3 == null ? "" : u3;
          break n;
        } catch (n3) {
        }
      typeof u3 == "function" || (u3 != null && (u3 !== false || l3[0] === "a" && l3[1] === "r") ? n2.setAttribute(l3, u3) : n2.removeAttribute(l3));
    }
}
__name(C, "C");
function $(l3) {
  this.l[l3.type + false](n.event ? n.event(l3) : l3);
}
__name($, "$");
function H(l3) {
  this.l[l3.type + true](n.event ? n.event(l3) : l3);
}
__name(H, "H");
function I(l3, u3, i3, t3, o3, r3, f3, e3, s3) {
  var a3, v3, h, d3, _2, k3, b3, g3, w3, x3, A3, P2 = u3.type;
  if (u3.constructor !== void 0)
    return null;
  i3.__h != null && (s3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, r3 = [e3]), (a3 = n.__b) && a3(u3);
  try {
    n:
      if (typeof P2 == "function") {
        if (g3 = u3.props, w3 = (a3 = P2.contextType) && t3[a3.__c], x3 = a3 ? w3 ? w3.props.value : a3.__ : t3, i3.__c ? b3 = (v3 = u3.__c = i3.__c).__ = v3.__E : ("prototype" in P2 && P2.prototype.render ? u3.__c = v3 = new P2(g3, x3) : (u3.__c = v3 = new p(g3, x3), v3.constructor = P2, v3.render = M), w3 && w3.sub(v3), v3.props = g3, v3.state || (v3.state = {}), v3.context = x3, v3.__n = t3, h = v3.__d = true, v3.__h = []), v3.__s == null && (v3.__s = v3.state), P2.getDerivedStateFromProps != null && (v3.__s == v3.state && (v3.__s = c({}, v3.__s)), c(v3.__s, P2.getDerivedStateFromProps(g3, v3.__s))), d3 = v3.props, _2 = v3.state, h)
          P2.getDerivedStateFromProps == null && v3.componentWillMount != null && v3.componentWillMount(), v3.componentDidMount != null && v3.__h.push(v3.componentDidMount);
        else {
          if (P2.getDerivedStateFromProps == null && g3 !== d3 && v3.componentWillReceiveProps != null && v3.componentWillReceiveProps(g3, x3), !v3.__e && v3.shouldComponentUpdate != null && v3.shouldComponentUpdate(g3, v3.__s, x3) === false || u3.__v === i3.__v) {
            v3.props = g3, v3.state = v3.__s, u3.__v !== i3.__v && (v3.__d = false), v3.__v = u3, u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n2) {
              n2 && (n2.__ = u3);
            }), v3.__h.length && f3.push(v3);
            break n;
          }
          v3.componentWillUpdate != null && v3.componentWillUpdate(g3, v3.__s, x3), v3.componentDidUpdate != null && v3.__h.push(function() {
            v3.componentDidUpdate(d3, _2, k3);
          });
        }
        v3.context = x3, v3.props = g3, v3.state = v3.__s, (a3 = n.__r) && a3(u3), v3.__d = false, v3.__v = u3, v3.__P = l3, a3 = v3.render(v3.props, v3.state, v3.context), v3.state = v3.__s, v3.getChildContext != null && (t3 = c(c({}, t3), v3.getChildContext())), h || v3.getSnapshotBeforeUpdate == null || (k3 = v3.getSnapshotBeforeUpdate(d3, _2)), A3 = a3 != null && a3.type === y && a3.key == null ? a3.props.children : a3, m(l3, Array.isArray(A3) ? A3 : [A3], u3, i3, t3, o3, r3, f3, e3, s3), v3.base = u3.__e, u3.__h = null, v3.__h.length && f3.push(v3), b3 && (v3.__E = v3.__ = null), v3.__e = false;
      } else
        r3 == null && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = j(i3.__e, u3, i3, t3, o3, r3, f3, s3);
    (a3 = n.diffed) && a3(u3);
  } catch (l4) {
    u3.__v = null, (s3 || r3 != null) && (u3.__e = e3, u3.__h = !!s3, r3[r3.indexOf(e3)] = null), n.__e(l4, u3, i3);
  }
}
__name(I, "I");
function T(l3, u3) {
  n.__c && n.__c(u3, l3), l3.some(function(u4) {
    try {
      l3 = u4.__h, u4.__h = [], l3.some(function(n2) {
        n2.call(u4);
      });
    } catch (l4) {
      n.__e(l4, u4.__v);
    }
  });
}
__name(T, "T");
function j(n2, l3, u3, i3, t3, o3, e3, c3) {
  var a3, v3, h, y3, p3 = u3.props, d3 = l3.props, _2 = l3.type, k3 = 0;
  if (_2 === "svg" && (t3 = true), o3 != null) {
    for (; k3 < o3.length; k3++)
      if ((a3 = o3[k3]) && (a3 === n2 || (_2 ? a3.localName == _2 : a3.nodeType == 3))) {
        n2 = a3, o3[k3] = null;
        break;
      }
  }
  if (n2 == null) {
    if (_2 === null)
      return document.createTextNode(d3);
    n2 = t3 ? document.createElementNS("http://www.w3.org/2000/svg", _2) : document.createElement(_2, d3.is && d3), o3 = null, c3 = false;
  }
  if (_2 === null)
    p3 === d3 || c3 && n2.data === d3 || (n2.data = d3);
  else {
    if (o3 = o3 && f.slice.call(n2.childNodes), v3 = (p3 = u3.props || r).dangerouslySetInnerHTML, h = d3.dangerouslySetInnerHTML, !c3) {
      if (o3 != null)
        for (p3 = {}, y3 = 0; y3 < n2.attributes.length; y3++)
          p3[n2.attributes[y3].name] = n2.attributes[y3].value;
      (h || v3) && (h && (v3 && h.__html == v3.__html || h.__html === n2.innerHTML) || (n2.innerHTML = h && h.__html || ""));
    }
    if (A(n2, d3, p3, t3, c3), h)
      l3.__k = [];
    else if (k3 = l3.props.children, m(n2, Array.isArray(k3) ? k3 : [k3], l3, u3, i3, t3 && _2 !== "foreignObject", o3, e3, n2.firstChild, c3), o3 != null)
      for (k3 = o3.length; k3--; )
        o3[k3] != null && s(o3[k3]);
    c3 || ("value" in d3 && (k3 = d3.value) !== void 0 && (k3 !== n2.value || _2 === "progress" && !k3) && C(n2, "value", k3, p3.value, false), "checked" in d3 && (k3 = d3.checked) !== void 0 && k3 !== n2.checked && C(n2, "checked", k3, p3.checked, false));
  }
  return n2;
}
__name(j, "j");
function z(l3, u3, i3) {
  try {
    typeof l3 == "function" ? l3(u3) : l3.current = u3;
  } catch (l4) {
    n.__e(l4, i3);
  }
}
__name(z, "z");
function L(l3, u3, i3) {
  var t3, o3, r3;
  if (n.unmount && n.unmount(l3), (t3 = l3.ref) && (t3.current && t3.current !== l3.__e || z(t3, null, u3)), i3 || typeof l3.type == "function" || (i3 = (o3 = l3.__e) != null), l3.__e = l3.__d = void 0, (t3 = l3.__c) != null) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (l4) {
        n.__e(l4, u3);
      }
    t3.base = t3.__P = null;
  }
  if (t3 = l3.__k)
    for (r3 = 0; r3 < t3.length; r3++)
      t3[r3] && L(t3[r3], u3, i3);
  o3 != null && s(o3);
}
__name(L, "L");
function M(n2, l3, u3) {
  return this.constructor(n2, u3);
}
__name(M, "M");
function N(l3, u3, i3) {
  var t3, o3, e3;
  n.__ && n.__(l3, u3), o3 = (t3 = typeof i3 == "function") ? null : i3 && i3.__k || u3.__k, e3 = [], I(u3, l3 = (!t3 && i3 || u3).__k = a(y, null, [l3]), o3 || r, r, u3.ownerSVGElement !== void 0, !t3 && i3 ? [i3] : o3 ? null : u3.firstChild ? f.slice.call(u3.childNodes) : null, e3, !t3 && i3 ? i3 : o3 ? o3.__e : u3.firstChild, t3), T(e3, l3);
}
__name(N, "N");
function q(n2, l3) {
  var u3 = {__c: l3 = "__cC" + o++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(k);
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  }};
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
__name(q, "q");
n = {__e: function(n2, l3) {
  for (var u3, i3, t3; l3 = l3.__; )
    if ((u3 = l3.__c) && !u3.__)
      try {
        if ((i3 = u3.constructor) && i3.getDerivedStateFromError != null && (u3.setState(i3.getDerivedStateFromError(n2)), t3 = u3.__d), u3.componentDidCatch != null && (u3.componentDidCatch(n2), t3 = u3.__d), t3)
          return u3.__E = u3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
}, __v: 0}, l = /* @__PURE__ */ __name(function(n2) {
  return n2 != null && n2.constructor === void 0;
}, "l"), p.prototype.setState = function(n2, l3) {
  var u3;
  u3 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = c({}, this.state), typeof n2 == "function" && (n2 = n2(c({}, u3), this.props)), n2 && c(u3, n2), n2 != null && this.__v && (l3 && this.__h.push(l3), k(this));
}, p.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), k(this));
}, p.prototype.render = y, u = [], i = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b.__r = 0, o = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t2;
var u2;
var r2;
var o2 = 0;
var i2 = [];
var c2 = n.__b;
var f2 = n.__r;
var e2 = n.diffed;
var a2 = n.__c;
var v2 = n.unmount;
function m2(t3, r3) {
  n.__h && n.__h(u2, t3, o2 || r3), o2 = 0;
  var i3 = u2.__H || (u2.__H = {__: [], __h: []});
  return t3 >= i3.__.length && i3.__.push({}), i3.__[t3];
}
__name(m2, "m");
function l2(n2) {
  return o2 = 1, p2(w2, n2);
}
__name(l2, "l");
function p2(n2, r3, o3) {
  var i3 = m2(t2++, 2);
  return i3.t = n2, i3.__c || (i3.__ = [o3 ? o3(r3) : w2(void 0, r3), function(n3) {
    var t3 = i3.t(i3.__[0], n3);
    i3.__[0] !== t3 && (i3.__ = [t3, i3.__[1]], i3.__c.setState({}));
  }], i3.__c = u2), i3.__;
}
__name(p2, "p");
function y2(r3, o3) {
  var i3 = m2(t2++, 3);
  !n.__s && k2(i3.__H, o3) && (i3.__ = r3, i3.__H = o3, u2.__H.__h.push(i3));
}
__name(y2, "y");
function s2(n2) {
  return o2 = 5, d2(function() {
    return {current: n2};
  }, []);
}
__name(s2, "s");
function d2(n2, u3) {
  var r3 = m2(t2++, 7);
  return k2(r3.__H, u3) && (r3.__ = n2(), r3.__H = u3, r3.__h = n2), r3.__;
}
__name(d2, "d");
function A2(n2, t3) {
  return o2 = 8, d2(function() {
    return n2;
  }, t3);
}
__name(A2, "A");
function F(n2) {
  var r3 = u2.context[n2.__c], o3 = m2(t2++, 9);
  return o3.__c = n2, r3 ? (o3.__ == null && (o3.__ = true, r3.sub(u2)), r3.props.value) : n2.__;
}
__name(F, "F");
function x2() {
  i2.forEach(function(t3) {
    if (t3.__P)
      try {
        t3.__H.__h.forEach(g2), t3.__H.__h.forEach(j2), t3.__H.__h = [];
      } catch (u3) {
        t3.__H.__h = [], n.__e(u3, t3.__v);
      }
  }), i2 = [];
}
__name(x2, "x");
n.__b = function(n2) {
  u2 = null, c2 && c2(n2);
}, n.__r = function(n2) {
  f2 && f2(n2), t2 = 0;
  var r3 = (u2 = n2.__c).__H;
  r3 && (r3.__h.forEach(g2), r3.__h.forEach(j2), r3.__h = []);
}, n.diffed = function(t3) {
  e2 && e2(t3);
  var o3 = t3.__c;
  o3 && o3.__H && o3.__H.__h.length && (i2.push(o3) !== 1 && r2 === n.requestAnimationFrame || ((r2 = n.requestAnimationFrame) || function(n2) {
    var t4, u3 = /* @__PURE__ */ __name(function() {
      clearTimeout(r3), b2 && cancelAnimationFrame(t4), setTimeout(n2);
    }, "u"), r3 = setTimeout(u3, 100);
    b2 && (t4 = requestAnimationFrame(u3));
  })(x2)), u2 = void 0;
}, n.__c = function(t3, u3) {
  u3.some(function(t4) {
    try {
      t4.__h.forEach(g2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || j2(n2);
      });
    } catch (r3) {
      u3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), u3 = [], n.__e(r3, t4.__v);
    }
  }), a2 && a2(t3, u3);
}, n.unmount = function(t3) {
  v2 && v2(t3);
  var u3 = t3.__c;
  if (u3 && u3.__H)
    try {
      u3.__H.__.forEach(g2);
    } catch (t4) {
      n.__e(t4, u3.__v);
    }
};
var b2 = typeof requestAnimationFrame == "function";
function g2(n2) {
  var t3 = u2;
  typeof n2.__c == "function" && n2.__c(), u2 = t3;
}
__name(g2, "g");
function j2(n2) {
  var t3 = u2;
  n2.__c = n2.__(), u2 = t3;
}
__name(j2, "j");
function k2(n2, t3) {
  return !n2 || n2.length !== t3.length || t3.some(function(t4, u3) {
    return t4 !== n2[u3];
  });
}
__name(k2, "k");
function w2(n2, t3) {
  return typeof t3 == "function" ? t3(n2) : t3;
}
__name(w2, "w");

// node_modules/three/build/three.module.js
var REVISION = "126";
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBIntegerFormat = 1032;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var GLSL3 = "300 es";
function EventDispatcher() {
}
__name(EventDispatcher, "EventDispatcher");
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i3 = 0, l3 = array.length; i3 < l3; i3++) {
        array[i3].call(this, event);
      }
    }
  }
});
var _lut = [];
for (let i3 = 0; i3 < 256; i3++) {
  _lut[i3] = (i3 < 16 ? "0" : "") + i3.toString(16);
}
var _seed = 1234567;
var MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d22 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d22 & 63 | 128] + _lut[d22 >> 8 & 255] + "-" + _lut[d22 >> 16 & 255] + _lut[d22 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  },
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n2, m3) {
    return (n2 % m3 + m3) % m3;
  },
  mapLinear: function(x3, a1, a22, b1, b22) {
    return b1 + (x3 - a1) * (b22 - b1) / (a22 - a1);
  },
  lerp: function(x3, y3, t3) {
    return (1 - t3) * x3 + t3 * y3;
  },
  damp: function(x3, y3, lambda, dt) {
    return MathUtils.lerp(x3, y3, 1 - Math.exp(-lambda * dt));
  },
  pingpong: function(x3, length = 1) {
    return length - Math.abs(MathUtils.euclideanModulo(x3, length * 2) - length);
  },
  smoothstep: function(x3, min, max) {
    if (x3 <= min)
      return 0;
    if (x3 >= max)
      return 1;
    x3 = (x3 - min) / (max - min);
    return x3 * x3 * (3 - 2 * x3);
  },
  smootherstep: function(x3, min, max) {
    if (x3 <= min)
      return 0;
    if (x3 >= max)
      return 1;
    x3 = (x3 - min) / (max - min);
    return x3 * x3 * x3 * (x3 * (x3 * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  seededRandom: function(s3) {
    if (s3 !== void 0)
      _seed = s3 % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function(degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(q2, a3, b3, c3, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c22 = cos(b3 / 2);
    const s22 = sin(b3 / 2);
    const c13 = cos((a3 + c3) / 2);
    const s13 = sin((a3 + c3) / 2);
    const c1_3 = cos((a3 - c3) / 2);
    const s1_3 = sin((a3 - c3) / 2);
    const c3_1 = cos((c3 - a3) / 2);
    const s3_1 = sin((c3 - a3) / 2);
    switch (order) {
      case "XYX":
        q2.set(c22 * s13, s22 * c1_3, s22 * s1_3, c22 * c13);
        break;
      case "YZY":
        q2.set(s22 * s1_3, c22 * s13, s22 * c1_3, c22 * c13);
        break;
      case "ZXZ":
        q2.set(s22 * c1_3, s22 * s1_3, c22 * s13, c22 * c13);
        break;
      case "XZX":
        q2.set(c22 * s13, s22 * s3_1, s22 * c3_1, c22 * c13);
        break;
      case "YXY":
        q2.set(s22 * c3_1, c22 * s13, s22 * s3_1, c22 * c13);
        break;
      case "ZYZ":
        q2.set(s22 * s3_1, s22 * c3_1, c22 * s13, c22 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
};
var Vector2 = class {
  constructor(x3 = 0, y3 = 0) {
    this.x = x3;
    this.y = y3;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x3, y3) {
    this.x = x3;
    this.y = y3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v3) {
    this.x = v3.x;
    this.y = v3.y;
    return this;
  }
  add(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v3, w3);
    }
    this.x += v3.x;
    this.y += v3.y;
    return this;
  }
  addScalar(s3) {
    this.x += s3;
    this.y += s3;
    return this;
  }
  addVectors(a3, b3) {
    this.x = a3.x + b3.x;
    this.y = a3.y + b3.y;
    return this;
  }
  addScaledVector(v3, s3) {
    this.x += v3.x * s3;
    this.y += v3.y * s3;
    return this;
  }
  sub(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v3, w3);
    }
    this.x -= v3.x;
    this.y -= v3.y;
    return this;
  }
  subScalar(s3) {
    this.x -= s3;
    this.y -= s3;
    return this;
  }
  subVectors(a3, b3) {
    this.x = a3.x - b3.x;
    this.y = a3.y - b3.y;
    return this;
  }
  multiply(v3) {
    this.x *= v3.x;
    this.y *= v3.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v3) {
    this.x /= v3.x;
    this.y /= v3.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m3) {
    const x3 = this.x, y3 = this.y;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[3] * y3 + e3[6];
    this.y = e3[1] * x3 + e3[4] * y3 + e3[7];
    return this;
  }
  min(v3) {
    this.x = Math.min(this.x, v3.x);
    this.y = Math.min(this.y, v3.y);
    return this;
  }
  max(v3) {
    this.x = Math.max(this.x, v3.x);
    this.y = Math.max(this.y, v3.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v3) {
    return this.x * v3.x + this.y * v3.y;
  }
  cross(v3) {
    return this.x * v3.y - this.y * v3.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v3) {
    return Math.sqrt(this.distanceToSquared(v3));
  }
  distanceToSquared(v3) {
    const dx = this.x - v3.x, dy = this.y - v3.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v3) {
    return Math.abs(this.x - v3.x) + Math.abs(this.y - v3.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v3, alpha) {
    this.x += (v3.x - this.x) * alpha;
    this.y += (v3.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v22, alpha) {
    this.x = v1.x + (v22.x - v1.x) * alpha;
    this.y = v1.y + (v22.y - v1.y) * alpha;
    return this;
  }
  equals(v3) {
    return v3.x === this.x && v3.y === this.y;
  }
  fromArray(array, offset3 = 0) {
    this.x = array[offset3];
    this.y = array[offset3 + 1];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.x;
    array[offset3 + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset3) {
    if (offset3 !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center2, angle) {
    const c3 = Math.cos(angle), s3 = Math.sin(angle);
    const x3 = this.x - center2.x;
    const y3 = this.y - center2.y;
    this.x = x3 * c3 - y3 * s3 + center2.x;
    this.y = x3 * s3 + y3 * c3 + center2.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
};
__name(Vector2, "Vector2");
Vector2.prototype.isVector2 = true;
var Matrix3 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m3) {
    const te = this.elements;
    const me = m3.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m3) {
    const me = m3.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m3) {
    return this.multiplyMatrices(this, m3);
  }
  premultiply(m3) {
    return this.multiplyMatrices(m3, this);
  }
  multiplyMatrices(a3, b3) {
    const ae = a3.elements;
    const be = b3.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s3) {
    const te = this.elements;
    te[0] *= s3;
    te[3] *= s3;
    te[6] *= s3;
    te[1] *= s3;
    te[4] *= s3;
    te[7] *= s3;
    te[2] *= s3;
    te[5] *= s3;
    te[8] *= s3;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a3 = te[0], b3 = te[1], c3 = te[2], d3 = te[3], e3 = te[4], f3 = te[5], g3 = te[6], h = te[7], i3 = te[8];
    return a3 * e3 * i3 - a3 * f3 * h - b3 * d3 * i3 + b3 * f3 * g3 + c3 * d3 * h - c3 * e3 * g3;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m3 = this.elements;
    tmp2 = m3[1];
    m3[1] = m3[3];
    m3[3] = tmp2;
    tmp2 = m3[2];
    m3[2] = m3[6];
    m3[6] = tmp2;
    tmp2 = m3[5];
    m3[5] = m3[7];
    m3[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r3) {
    const m3 = this.elements;
    r3[0] = m3[0];
    r3[1] = m3[3];
    r3[2] = m3[6];
    r3[3] = m3[1];
    r3[4] = m3[4];
    r3[5] = m3[7];
    r3[6] = m3[2];
    r3[7] = m3[5];
    r3[8] = m3[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c3 = Math.cos(rotation);
    const s3 = Math.sin(rotation);
    this.set(sx * c3, sx * s3, -sx * (c3 * cx + s3 * cy) + cx + tx, -sy * s3, sy * c3, -sy * (-s3 * cx + c3 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c3 = Math.cos(theta);
    const s3 = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c3 * a11 + s3 * a21;
    te[3] = c3 * a12 + s3 * a22;
    te[6] = c3 * a13 + s3 * a23;
    te[1] = -s3 * a11 + c3 * a21;
    te[4] = -s3 * a12 + c3 * a22;
    te[7] = -s3 * a13 + c3 * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i3 = 0; i3 < 9; i3++) {
      if (te[i3] !== me[i3])
        return false;
    }
    return true;
  }
  fromArray(array, offset3 = 0) {
    for (let i3 = 0; i3 < 9; i3++) {
      this.elements[i3] = array[i3 + offset3];
    }
    return this;
  }
  toArray(array = [], offset3 = 0) {
    const te = this.elements;
    array[offset3] = te[0];
    array[offset3 + 1] = te[1];
    array[offset3 + 2] = te[2];
    array[offset3 + 3] = te[3];
    array[offset3 + 4] = te[4];
    array[offset3 + 5] = te[5];
    array[offset3 + 6] = te[6];
    array[offset3 + 7] = te[7];
    array[offset3 + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
__name(Matrix3, "Matrix3");
Matrix3.prototype.isMatrix3 = true;
var _canvas;
var ImageUtils = {
  getDataURL: function(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context3 = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context3.putImageData(image, 0, 0);
      } else {
        context3.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
var Texture = class extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = MathUtils.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i3 = 0, l3 = image.length; i3 < l3; i3++) {
            if (image[i3].isDataTexture) {
              url.push(serializeImage(image[i3].image));
            } else {
              url.push(serializeImage(image[i3]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
__name(Texture, "Texture");
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
__name(serializeImage, "serializeImage");
var Vector4 = class {
  constructor(x3 = 0, y3 = 0, z2 = 0, w3 = 1) {
    this.x = x3;
    this.y = y3;
    this.z = z2;
    this.w = w3;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x3, y3, z2, w3) {
    this.x = x3;
    this.y = y3;
    this.z = z2;
    this.w = w3;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w3) {
    this.w = w3;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v3) {
    this.x = v3.x;
    this.y = v3.y;
    this.z = v3.z;
    this.w = v3.w !== void 0 ? v3.w : 1;
    return this;
  }
  add(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v3, w3);
    }
    this.x += v3.x;
    this.y += v3.y;
    this.z += v3.z;
    this.w += v3.w;
    return this;
  }
  addScalar(s3) {
    this.x += s3;
    this.y += s3;
    this.z += s3;
    this.w += s3;
    return this;
  }
  addVectors(a3, b3) {
    this.x = a3.x + b3.x;
    this.y = a3.y + b3.y;
    this.z = a3.z + b3.z;
    this.w = a3.w + b3.w;
    return this;
  }
  addScaledVector(v3, s3) {
    this.x += v3.x * s3;
    this.y += v3.y * s3;
    this.z += v3.z * s3;
    this.w += v3.w * s3;
    return this;
  }
  sub(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v3, w3);
    }
    this.x -= v3.x;
    this.y -= v3.y;
    this.z -= v3.z;
    this.w -= v3.w;
    return this;
  }
  subScalar(s3) {
    this.x -= s3;
    this.y -= s3;
    this.z -= s3;
    this.w -= s3;
    return this;
  }
  subVectors(a3, b3) {
    this.x = a3.x - b3.x;
    this.y = a3.y - b3.y;
    this.z = a3.z - b3.z;
    this.w = a3.w - b3.w;
    return this;
  }
  multiply(v3) {
    this.x *= v3.x;
    this.y *= v3.y;
    this.z *= v3.z;
    this.w *= v3.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m3) {
    const x3 = this.x, y3 = this.y, z2 = this.z, w3 = this.w;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[4] * y3 + e3[8] * z2 + e3[12] * w3;
    this.y = e3[1] * x3 + e3[5] * y3 + e3[9] * z2 + e3[13] * w3;
    this.z = e3[2] * x3 + e3[6] * y3 + e3[10] * z2 + e3[14] * w3;
    this.w = e3[3] * x3 + e3[7] * y3 + e3[11] * z2 + e3[15] * w3;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s3 = Math.sqrt(1 - q2.w * q2.w);
    if (s3 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s3;
      this.y = q2.y / s3;
      this.z = q2.z / s3;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m3) {
    let angle, x3, y3, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te = m3.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x3 = 0;
          y3 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x3 = Math.sqrt(xx);
          y3 = xy / x3;
          z2 = xz / x3;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x3 = 0.707106781;
          y3 = 0;
          z2 = 0.707106781;
        } else {
          y3 = Math.sqrt(yy);
          x3 = xy / y3;
          z2 = yz / y3;
        }
      } else {
        if (zz < epsilon) {
          x3 = 0.707106781;
          y3 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x3 = xz / z2;
          y3 = yz / z2;
        }
      }
      this.set(x3, y3, z2, angle);
      return this;
    }
    let s3 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s3) < 1e-3)
      s3 = 1;
    this.x = (m32 - m23) / s3;
    this.y = (m13 - m31) / s3;
    this.z = (m21 - m12) / s3;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v3) {
    this.x = Math.min(this.x, v3.x);
    this.y = Math.min(this.y, v3.y);
    this.z = Math.min(this.z, v3.z);
    this.w = Math.min(this.w, v3.w);
    return this;
  }
  max(v3) {
    this.x = Math.max(this.x, v3.x);
    this.y = Math.max(this.y, v3.y);
    this.z = Math.max(this.z, v3.z);
    this.w = Math.max(this.w, v3.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v3) {
    return this.x * v3.x + this.y * v3.y + this.z * v3.z + this.w * v3.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v3, alpha) {
    this.x += (v3.x - this.x) * alpha;
    this.y += (v3.y - this.y) * alpha;
    this.z += (v3.z - this.z) * alpha;
    this.w += (v3.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v22, alpha) {
    this.x = v1.x + (v22.x - v1.x) * alpha;
    this.y = v1.y + (v22.y - v1.y) * alpha;
    this.z = v1.z + (v22.z - v1.z) * alpha;
    this.w = v1.w + (v22.w - v1.w) * alpha;
    return this;
  }
  equals(v3) {
    return v3.x === this.x && v3.y === this.y && v3.z === this.z && v3.w === this.w;
  }
  fromArray(array, offset3 = 0) {
    this.x = array[offset3];
    this.y = array[offset3 + 1];
    this.z = array[offset3 + 2];
    this.w = array[offset3 + 3];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.x;
    array[offset3 + 1] = this.y;
    array[offset3 + 2] = this.z;
    array[offset3 + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset3) {
    if (offset3 !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
};
__name(Vector4, "Vector4");
Vector4.prototype.isVector4 = true;
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width, height, options) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
};
__name(WebGLRenderTarget, "WebGLRenderTarget");
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
  constructor(width, height, options) {
    super(width, height, options);
    this.samples = 4;
  }
  copy(source) {
    super.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
};
__name(WebGLMultisampleRenderTarget, "WebGLMultisampleRenderTarget");
WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
var Quaternion = class {
  constructor(x3 = 0, y3 = 0, z2 = 0, w3 = 1) {
    this._x = x3;
    this._y = y3;
    this._z = z2;
    this._w = w3;
  }
  static slerp(qa, qb, qm, t3) {
    return qm.copy(qa).slerp(qb, t3);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t3) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t3 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t3 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s3 = 1 - t3;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s3 = Math.sin(s3 * len) / sin;
        t3 = Math.sin(t3 * len) / sin;
      }
      const tDir = t3 * dir;
      x0 = x0 * s3 + x1 * tDir;
      y0 = y0 * s3 + y1 * tDir;
      z0 = z0 * s3 + z1 * tDir;
      w0 = w0 * s3 + w1 * tDir;
      if (s3 === 1 - t3) {
        const f3 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f3;
        y0 *= f3;
        z0 *= f3;
        w0 *= f3;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x3, y3, z2, w3) {
    this._x = x3;
    this._y = y3;
    this._z = z2;
    this._w = w3;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x3 = euler._x, y3 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x3 / 2);
    const c22 = cos(y3 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x3 / 2);
    const s22 = sin(y3 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c22 * c3 + c1 * s22 * s3;
        this._y = c1 * s22 * c3 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s22 * c3;
        this._w = c1 * c22 * c3 - s1 * s22 * s3;
        break;
      case "YXZ":
        this._x = s1 * c22 * c3 + c1 * s22 * s3;
        this._y = c1 * s22 * c3 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s22 * c3;
        this._w = c1 * c22 * c3 + s1 * s22 * s3;
        break;
      case "ZXY":
        this._x = s1 * c22 * c3 - c1 * s22 * s3;
        this._y = c1 * s22 * c3 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s22 * c3;
        this._w = c1 * c22 * c3 - s1 * s22 * s3;
        break;
      case "ZYX":
        this._x = s1 * c22 * c3 - c1 * s22 * s3;
        this._y = c1 * s22 * c3 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s22 * c3;
        this._w = c1 * c22 * c3 + s1 * s22 * s3;
        break;
      case "YZX":
        this._x = s1 * c22 * c3 + c1 * s22 * s3;
        this._y = c1 * s22 * c3 + s1 * c22 * s3;
        this._z = c1 * c22 * s3 - s1 * s22 * c3;
        this._w = c1 * c22 * c3 - s1 * s22 * s3;
        break;
      case "XZY":
        this._x = s1 * c22 * c3 - c1 * s22 * s3;
        this._y = c1 * s22 * c3 - s1 * c22 * s3;
        this._z = c1 * c22 * s3 + s1 * s22 * c3;
        this._w = c1 * c22 * c3 + s1 * s22 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s3 = Math.sin(halfAngle);
    this._x = axis.x * s3;
    this._y = axis.y * s3;
    this._z = axis.z * s3;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m3) {
    const te = m3.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s3 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s3;
      this._x = (m32 - m23) * s3;
      this._y = (m13 - m31) * s3;
      this._z = (m21 - m12) * s3;
    } else if (m11 > m22 && m11 > m33) {
      const s3 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s3;
      this._x = 0.25 * s3;
      this._y = (m12 + m21) / s3;
      this._z = (m13 + m31) / s3;
    } else if (m22 > m33) {
      const s3 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s3;
      this._x = (m12 + m21) / s3;
      this._y = 0.25 * s3;
      this._z = (m23 + m32) / s3;
    } else {
      const s3 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s3;
      this._x = (m13 + m31) / s3;
      this._y = (m23 + m32) / s3;
      this._z = 0.25 * s3;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    const EPS = 1e-6;
    let r3 = vFrom.dot(vTo) + 1;
    if (r3 < EPS) {
      r3 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r3;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r3;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r3;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0)
      return this;
    const t3 = Math.min(1, step / angle);
    this.slerp(q2, t3);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v3) {
    return this._x * v3._x + this._y * v3._y + this._z * v3._z + this._w * v3._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l3 = this.length();
    if (l3 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l3 = 1 / l3;
      this._x = this._x * l3;
      this._y = this._y * l3;
      this._z = this._z * l3;
      this._w = this._w * l3;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p3) {
    if (p3 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p3);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a3, b3) {
    const qax = a3._x, qay = a3._y, qaz = a3._z, qaw = a3._w;
    const qbx = b3._x, qby = b3._y, qbz = b3._z, qbw = b3._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t3) {
    if (t3 === 0)
      return this;
    if (t3 === 1)
      return this.copy(qb);
    const x3 = this._x, y3 = this._y, z2 = this._z, w3 = this._w;
    let cosHalfTheta = w3 * qb._w + x3 * qb._x + y3 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w3;
      this._x = x3;
      this._y = y3;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s3 = 1 - t3;
      this._w = s3 * w3 + t3 * this._w;
      this._x = s3 * x3 + t3 * this._x;
      this._y = s3 * y3 + t3 * this._y;
      this._z = s3 * z2 + t3 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t3) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t3 * halfTheta) / sinHalfTheta;
    this._w = w3 * ratioA + this._w * ratioB;
    this._x = x3 * ratioA + this._x * ratioB;
    this._y = y3 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset3 = 0) {
    this._x = array[offset3];
    this._y = array[offset3 + 1];
    this._z = array[offset3 + 2];
    this._w = array[offset3 + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this._x;
    array[offset3 + 1] = this._y;
    array[offset3 + 2] = this._z;
    array[offset3 + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
__name(Quaternion, "Quaternion");
Quaternion.prototype.isQuaternion = true;
var Vector3 = class {
  constructor(x3 = 0, y3 = 0, z2 = 0) {
    this.x = x3;
    this.y = y3;
    this.z = z2;
  }
  set(x3, y3, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x3;
    this.y = y3;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y3) {
    this.y = y3;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v3) {
    this.x = v3.x;
    this.y = v3.y;
    this.z = v3.z;
    return this;
  }
  add(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v3, w3);
    }
    this.x += v3.x;
    this.y += v3.y;
    this.z += v3.z;
    return this;
  }
  addScalar(s3) {
    this.x += s3;
    this.y += s3;
    this.z += s3;
    return this;
  }
  addVectors(a3, b3) {
    this.x = a3.x + b3.x;
    this.y = a3.y + b3.y;
    this.z = a3.z + b3.z;
    return this;
  }
  addScaledVector(v3, s3) {
    this.x += v3.x * s3;
    this.y += v3.y * s3;
    this.z += v3.z * s3;
    return this;
  }
  sub(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v3, w3);
    }
    this.x -= v3.x;
    this.y -= v3.y;
    this.z -= v3.z;
    return this;
  }
  subScalar(s3) {
    this.x -= s3;
    this.y -= s3;
    this.z -= s3;
    return this;
  }
  subVectors(a3, b3) {
    this.x = a3.x - b3.x;
    this.y = a3.y - b3.y;
    this.z = a3.z - b3.z;
    return this;
  }
  multiply(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v3, w3);
    }
    this.x *= v3.x;
    this.y *= v3.y;
    this.z *= v3.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a3, b3) {
    this.x = a3.x * b3.x;
    this.y = a3.y * b3.y;
    this.z = a3.z * b3.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m3) {
    const x3 = this.x, y3 = this.y, z2 = this.z;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[3] * y3 + e3[6] * z2;
    this.y = e3[1] * x3 + e3[4] * y3 + e3[7] * z2;
    this.z = e3[2] * x3 + e3[5] * y3 + e3[8] * z2;
    return this;
  }
  applyNormalMatrix(m3) {
    return this.applyMatrix3(m3).normalize();
  }
  applyMatrix4(m3) {
    const x3 = this.x, y3 = this.y, z2 = this.z;
    const e3 = m3.elements;
    const w3 = 1 / (e3[3] * x3 + e3[7] * y3 + e3[11] * z2 + e3[15]);
    this.x = (e3[0] * x3 + e3[4] * y3 + e3[8] * z2 + e3[12]) * w3;
    this.y = (e3[1] * x3 + e3[5] * y3 + e3[9] * z2 + e3[13]) * w3;
    this.z = (e3[2] * x3 + e3[6] * y3 + e3[10] * z2 + e3[14]) * w3;
    return this;
  }
  applyQuaternion(q2) {
    const x3 = this.x, y3 = this.y, z2 = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const ix = qw * x3 + qy * z2 - qz * y3;
    const iy = qw * y3 + qz * x3 - qx * z2;
    const iz = qw * z2 + qx * y3 - qy * x3;
    const iw = -qx * x3 - qy * y3 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m3) {
    const x3 = this.x, y3 = this.y, z2 = this.z;
    const e3 = m3.elements;
    this.x = e3[0] * x3 + e3[4] * y3 + e3[8] * z2;
    this.y = e3[1] * x3 + e3[5] * y3 + e3[9] * z2;
    this.z = e3[2] * x3 + e3[6] * y3 + e3[10] * z2;
    return this.normalize();
  }
  divide(v3) {
    this.x /= v3.x;
    this.y /= v3.y;
    this.z /= v3.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v3) {
    this.x = Math.min(this.x, v3.x);
    this.y = Math.min(this.y, v3.y);
    this.z = Math.min(this.z, v3.z);
    return this;
  }
  max(v3) {
    this.x = Math.max(this.x, v3.x);
    this.y = Math.max(this.y, v3.y);
    this.z = Math.max(this.z, v3.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v3) {
    return this.x * v3.x + this.y * v3.y + this.z * v3.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v3, alpha) {
    this.x += (v3.x - this.x) * alpha;
    this.y += (v3.y - this.y) * alpha;
    this.z += (v3.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v22, alpha) {
    this.x = v1.x + (v22.x - v1.x) * alpha;
    this.y = v1.y + (v22.y - v1.y) * alpha;
    this.z = v1.z + (v22.z - v1.z) * alpha;
    return this;
  }
  cross(v3, w3) {
    if (w3 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v3, w3);
    }
    return this.crossVectors(this, v3);
  }
  crossVectors(a3, b3) {
    const ax = a3.x, ay = a3.y, az = a3.z;
    const bx = b3.x, by = b3.y, bz = b3.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v3) {
    const denominator = v3.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v3.dot(this) / denominator;
    return this.copy(v3).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector);
  }
  reflect(normal) {
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v3) {
    const denominator = Math.sqrt(this.lengthSq() * v3.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v3) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v3) {
    return Math.sqrt(this.distanceToSquared(v3));
  }
  distanceToSquared(v3) {
    const dx = this.x - v3.x, dy = this.y - v3.y, dz = this.z - v3.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v3) {
    return Math.abs(this.x - v3.x) + Math.abs(this.y - v3.y) + Math.abs(this.z - v3.z);
  }
  setFromSpherical(s3) {
    return this.setFromSphericalCoords(s3.radius, s3.phi, s3.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c3) {
    return this.setFromCylindricalCoords(c3.radius, c3.theta, c3.y);
  }
  setFromCylindricalCoords(radius, theta, y3) {
    this.x = radius * Math.sin(theta);
    this.y = y3;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m3) {
    const e3 = m3.elements;
    this.x = e3[12];
    this.y = e3[13];
    this.z = e3[14];
    return this;
  }
  setFromMatrixScale(m3) {
    const sx = this.setFromMatrixColumn(m3, 0).length();
    const sy = this.setFromMatrixColumn(m3, 1).length();
    const sz = this.setFromMatrixColumn(m3, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m3, index) {
    return this.fromArray(m3.elements, index * 4);
  }
  setFromMatrix3Column(m3, index) {
    return this.fromArray(m3.elements, index * 3);
  }
  equals(v3) {
    return v3.x === this.x && v3.y === this.y && v3.z === this.z;
  }
  fromArray(array, offset3 = 0) {
    this.x = array[offset3];
    this.y = array[offset3 + 1];
    this.z = array[offset3 + 2];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.x;
    array[offset3 + 1] = this.y;
    array[offset3 + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset3) {
    if (offset3 !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
};
__name(Vector3, "Vector3");
Vector3.prototype.isVector3 = true;
var _vector = /* @__PURE__ */ new Vector3();
var _quaternion = /* @__PURE__ */ new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i3 = 0, l3 = array.length; i3 < l3; i3 += 3) {
      const x3 = array[i3];
      const y3 = array[i3 + 1];
      const z2 = array[i3 + 2];
      if (x3 < minX)
        minX = x3;
      if (y3 < minY)
        minY = y3;
      if (z2 < minZ)
        minZ = z2;
      if (x3 > maxX)
        maxX = x3;
      if (y3 > maxY)
        maxY = y3;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i3 = 0, l3 = attribute.count; i3 < l3; i3++) {
      const x3 = attribute.getX(i3);
      const y3 = attribute.getY(i3);
      const z2 = attribute.getZ(i3);
      if (x3 < minX)
        minX = x3;
      if (y3 < minY)
        minY = y3;
      if (z2 < minZ)
        minZ = z2;
      if (x3 > maxX)
        maxX = x3;
      if (y3 > maxY)
        maxY = y3;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i3 = 0, il = points.length; i3 < il; i3++) {
      this.expandByPoint(points[i3]);
    }
    return this;
  }
  setFromCenterAndSize(center2, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);
    this.min.copy(center2).sub(halfSize);
    this.max.copy(center2).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box2) {
    this.min.copy(box2.min);
    this.max.copy(box2.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target2 = new Vector3();
    }
    return this.isEmpty() ? target2.set(0, 0, 0) : target2.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target2 = new Vector3();
    }
    return this.isEmpty() ? target2.set(0, 0, 0) : target2.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box.copy(geometry.boundingBox);
      _box.applyMatrix4(object.matrixWorld);
      this.union(_box);
    }
    const children = object.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      this.expandByObject(children[i3]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box2) {
    return this.min.x <= box2.min.x && box2.max.x <= this.max.x && this.min.y <= box2.min.y && box2.max.y <= this.max.y && this.min.z <= box2.min.z && box2.max.z <= this.max.z;
  }
  getParameter(point, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target2 = new Vector3();
    }
    return target2.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box2) {
    return box2.max.x < this.min.x || box2.min.x > this.max.x || box2.max.y < this.min.y || box2.min.y > this.max.y || box2.max.z < this.min.z || box2.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$1);
    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0.subVectors(triangle.a, _center);
    _v1.subVectors(triangle.b, _center);
    _v2.subVectors(triangle.c, _center);
    _f0.subVectors(_v1, _v0);
    _f1.subVectors(_v2, _v1);
    _f2.subVectors(_v0, _v2);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }
  clampPoint(point, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target2 = new Vector3();
    }
    return target2.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target2) {
    if (target2 === void 0) {
      console.error("THREE.Box3: .getBoundingSphere() target is now required");
    }
    this.getCenter(target2.center);
    target2.radius = this.getSize(_vector$1).length() * 0.5;
    return target2;
  }
  intersect(box2) {
    this.min.max(box2.min);
    this.max.min(box2.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box2) {
    this.min.min(box2.min);
    this.max.max(box2.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset3) {
    this.min.add(offset3);
    this.max.add(offset3);
    return this;
  }
  equals(box2) {
    return box2.min.equals(this.min) && box2.max.equals(this.max);
  }
};
__name(Box3, "Box3");
Box3.prototype.isBox3 = true;
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$1 = /* @__PURE__ */ new Vector3();
var _box = /* @__PURE__ */ new Box3();
var _v0 = /* @__PURE__ */ new Vector3();
var _v1 = /* @__PURE__ */ new Vector3();
var _v2 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v22, extents) {
  for (let i3 = 0, j3 = axes.length - 3; i3 <= j3; i3 += 3) {
    _testAxis.fromArray(axes, i3);
    const r3 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p22 = v22.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p22), Math.min(p0, p1, p22)) > r3) {
      return false;
    }
  }
  return true;
}
__name(satForAxes, "satForAxes");
var _box$1 = /* @__PURE__ */ new Box3();
var Sphere = class {
  constructor(center2 = new Vector3(), radius = -1) {
    this.center = center2;
    this.radius = radius;
  }
  set(center2, radius) {
    this.center.copy(center2);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center2 = this.center;
    if (optionalCenter !== void 0) {
      center2.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center2);
    }
    let maxRadiusSq = 0;
    for (let i3 = 0, il = points.length; i3 < il; i3++) {
      maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(points[i3]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box2) {
    return box2.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target2) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target2 === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target2 = new Vector3();
    }
    target2.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target2.sub(this.center).normalize();
      target2.multiplyScalar(this.radius).add(this.center);
    }
    return target2;
  }
  getBoundingBox(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target2 = new Box3();
    }
    if (this.isEmpty()) {
      target2.makeEmpty();
      return target2;
    }
    target2.set(this.center, this.center);
    target2.expandByScalar(this.radius);
    return target2;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset3) {
    this.center.add(offset3);
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
__name(Sphere, "Sphere");
var _vector$2 = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal = /* @__PURE__ */ new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t3, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target2 = new Vector3();
    }
    return target2.copy(this.direction).multiplyScalar(t3).add(this.origin);
  }
  lookAt(v3) {
    this.direction.copy(v3).sub(this.origin).normalize();
    return this;
  }
  recast(t3) {
    this.origin.copy(this.at(t3, _vector$2));
    return this;
  }
  closestPointToPoint(point, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target2 = new Vector3();
    }
    target2.subVectors(point, this.origin);
    const directionDistance = target2.dot(this.direction);
    if (directionDistance < 0) {
      return target2.copy(this.origin);
    }
    return target2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$2.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c3 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c3;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c3;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c3;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target2) {
    _vector$2.subVectors(sphere.center, this.origin);
    const tca = _vector$2.dot(this.direction);
    const d22 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d22 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d22);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target2);
    return this.at(t0, target2);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t3 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t3 >= 0 ? t3 : null;
  }
  intersectPlane(plane, target2) {
    const t3 = this.distanceToPlane(plane);
    if (t3 === null) {
      return null;
    }
    return this.at(t3, target2);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box2, target2) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box2.min.x - origin.x) * invdirx;
      tmax = (box2.max.x - origin.x) * invdirx;
    } else {
      tmin = (box2.max.x - origin.x) * invdirx;
      tmax = (box2.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box2.min.y - origin.y) * invdiry;
      tymax = (box2.max.y - origin.y) * invdiry;
    } else {
      tymin = (box2.max.y - origin.y) * invdiry;
      tymax = (box2.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box2.min.z - origin.z) * invdirz;
      tzmax = (box2.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box2.max.z - origin.z) * invdirz;
      tzmax = (box2.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target2);
  }
  intersectsBox(box2) {
    return this.intersectBox(box2, _vector$2) !== null;
  }
  intersectTriangle(a3, b3, c3, backfaceCulling, target2) {
    _edge1.subVectors(b3, a3);
    _edge2.subVectors(c3, a3);
    _normal.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a3);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target2);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
__name(Ray, "Ray");
var Matrix4 = class {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m3) {
    const te = this.elements;
    const me = m3.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m3) {
    const te = this.elements, me = m3.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m3) {
    const me = m3.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m3) {
    const te = this.elements;
    const me = m3.elements;
    const scaleX = 1 / _v1$1.setFromMatrixColumn(m3, 0).length();
    const scaleY = 1 / _v1$1.setFromMatrixColumn(m3, 1).length();
    const scaleZ = 1 / _v1$1.setFromMatrixColumn(m3, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x3 = euler.x, y3 = euler.y, z2 = euler.z;
    const a3 = Math.cos(x3), b3 = Math.sin(x3);
    const c3 = Math.cos(y3), d3 = Math.sin(y3);
    const e3 = Math.cos(z2), f3 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae = a3 * e3, af = a3 * f3, be = b3 * e3, bf = b3 * f3;
      te[0] = c3 * e3;
      te[4] = -c3 * f3;
      te[8] = d3;
      te[1] = af + be * d3;
      te[5] = ae - bf * d3;
      te[9] = -b3 * c3;
      te[2] = bf - ae * d3;
      te[6] = be + af * d3;
      te[10] = a3 * c3;
    } else if (euler.order === "YXZ") {
      const ce = c3 * e3, cf = c3 * f3, de = d3 * e3, df = d3 * f3;
      te[0] = ce + df * b3;
      te[4] = de * b3 - cf;
      te[8] = a3 * d3;
      te[1] = a3 * f3;
      te[5] = a3 * e3;
      te[9] = -b3;
      te[2] = cf * b3 - de;
      te[6] = df + ce * b3;
      te[10] = a3 * c3;
    } else if (euler.order === "ZXY") {
      const ce = c3 * e3, cf = c3 * f3, de = d3 * e3, df = d3 * f3;
      te[0] = ce - df * b3;
      te[4] = -a3 * f3;
      te[8] = de + cf * b3;
      te[1] = cf + de * b3;
      te[5] = a3 * e3;
      te[9] = df - ce * b3;
      te[2] = -a3 * d3;
      te[6] = b3;
      te[10] = a3 * c3;
    } else if (euler.order === "ZYX") {
      const ae = a3 * e3, af = a3 * f3, be = b3 * e3, bf = b3 * f3;
      te[0] = c3 * e3;
      te[4] = be * d3 - af;
      te[8] = ae * d3 + bf;
      te[1] = c3 * f3;
      te[5] = bf * d3 + ae;
      te[9] = af * d3 - be;
      te[2] = -d3;
      te[6] = b3 * c3;
      te[10] = a3 * c3;
    } else if (euler.order === "YZX") {
      const ac = a3 * c3, ad = a3 * d3, bc = b3 * c3, bd = b3 * d3;
      te[0] = c3 * e3;
      te[4] = bd - ac * f3;
      te[8] = bc * f3 + ad;
      te[1] = f3;
      te[5] = a3 * e3;
      te[9] = -b3 * e3;
      te[2] = -d3 * e3;
      te[6] = ad * f3 + bc;
      te[10] = ac - bd * f3;
    } else if (euler.order === "XZY") {
      const ac = a3 * c3, ad = a3 * d3, bc = b3 * c3, bd = b3 * d3;
      te[0] = c3 * e3;
      te[4] = -f3;
      te[8] = d3 * e3;
      te[1] = ac * f3 + bd;
      te[5] = a3 * e3;
      te[9] = ad * f3 - bc;
      te[2] = bc * f3 - ad;
      te[6] = b3 * e3;
      te[10] = bd * f3 + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target2, up) {
    const te = this.elements;
    _z.subVectors(eye, target2);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m3, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m3, n2);
    }
    return this.multiplyMatrices(this, m3);
  }
  premultiply(m3) {
    return this.multiplyMatrices(m3, this);
  }
  multiplyMatrices(a3, b3) {
    const ae = a3.elements;
    const be = b3.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s3) {
    const te = this.elements;
    te[0] *= s3;
    te[4] *= s3;
    te[8] *= s3;
    te[12] *= s3;
    te[1] *= s3;
    te[5] *= s3;
    te[9] *= s3;
    te[13] *= s3;
    te[2] *= s3;
    te[6] *= s3;
    te[10] *= s3;
    te[14] *= s3;
    te[3] *= s3;
    te[7] *= s3;
    te[11] *= s3;
    te[15] *= s3;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x3, y3, z2) {
    const te = this.elements;
    if (x3.isVector3) {
      te[12] = x3.x;
      te[13] = x3.y;
      te[14] = x3.z;
    } else {
      te[12] = x3;
      te[13] = y3;
      te[14] = z2;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v3) {
    const te = this.elements;
    const x3 = v3.x, y3 = v3.y, z2 = v3.z;
    te[0] *= x3;
    te[4] *= y3;
    te[8] *= z2;
    te[1] *= x3;
    te[5] *= y3;
    te[9] *= z2;
    te[2] *= x3;
    te[6] *= y3;
    te[10] *= z2;
    te[3] *= x3;
    te[7] *= y3;
    te[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x3, y3, z2) {
    this.set(1, 0, 0, x3, 0, 1, 0, y3, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c3 = Math.cos(theta), s3 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c3, -s3, 0, 0, s3, c3, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c3 = Math.cos(theta), s3 = Math.sin(theta);
    this.set(c3, 0, s3, 0, 0, 1, 0, 0, -s3, 0, c3, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c3 = Math.cos(theta), s3 = Math.sin(theta);
    this.set(c3, -s3, 0, 0, s3, c3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c3 = Math.cos(angle);
    const s3 = Math.sin(angle);
    const t3 = 1 - c3;
    const x3 = axis.x, y3 = axis.y, z2 = axis.z;
    const tx = t3 * x3, ty = t3 * y3;
    this.set(tx * x3 + c3, tx * y3 - s3 * z2, tx * z2 + s3 * y3, 0, tx * y3 + s3 * z2, ty * y3 + c3, ty * z2 - s3 * x3, 0, tx * z2 - s3 * y3, ty * z2 + s3 * x3, t3 * z2 * z2 + c3, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x3, y3, z2) {
    this.set(x3, 0, 0, 0, 0, y3, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x3, y3, z2) {
    this.set(1, y3, z2, 0, x3, 1, z2, 0, x3, y3, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x3 = quaternion._x, y3 = quaternion._y, z2 = quaternion._z, w3 = quaternion._w;
    const x22 = x3 + x3, y22 = y3 + y3, z22 = z2 + z2;
    const xx = x3 * x22, xy = x3 * y22, xz = x3 * z22;
    const yy = y3 * y22, yz = y3 * z22, zz = z2 * z22;
    const wx = w3 * x22, wy = w3 * y22, wz = w3 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$1.set(te[0], te[1], te[2]).length();
    const sy = _v1$1.set(te[4], te[5], te[6]).length();
    const sz = _v1$1.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x3 = 2 * near / (right - left);
    const y3 = 2 * near / (top - bottom);
    const a3 = (right + left) / (right - left);
    const b3 = (top + bottom) / (top - bottom);
    const c3 = -(far + near) / (far - near);
    const d3 = -2 * far * near / (far - near);
    te[0] = x3;
    te[4] = 0;
    te[8] = a3;
    te[12] = 0;
    te[1] = 0;
    te[5] = y3;
    te[9] = b3;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c3;
    te[14] = d3;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w3 = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p3 = 1 / (far - near);
    const x3 = (right + left) * w3;
    const y3 = (top + bottom) * h;
    const z2 = (far + near) * p3;
    te[0] = 2 * w3;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x3;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y3;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p3;
    te[14] = -z2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i3 = 0; i3 < 16; i3++) {
      if (te[i3] !== me[i3])
        return false;
    }
    return true;
  }
  fromArray(array, offset3 = 0) {
    for (let i3 = 0; i3 < 16; i3++) {
      this.elements[i3] = array[i3 + offset3];
    }
    return this;
  }
  toArray(array = [], offset3 = 0) {
    const te = this.elements;
    array[offset3] = te[0];
    array[offset3 + 1] = te[1];
    array[offset3 + 2] = te[2];
    array[offset3 + 3] = te[3];
    array[offset3 + 4] = te[4];
    array[offset3 + 5] = te[5];
    array[offset3 + 6] = te[6];
    array[offset3 + 7] = te[7];
    array[offset3 + 8] = te[8];
    array[offset3 + 9] = te[9];
    array[offset3 + 10] = te[10];
    array[offset3 + 11] = te[11];
    array[offset3 + 12] = te[12];
    array[offset3 + 13] = te[13];
    array[offset3 + 14] = te[14];
    array[offset3 + 15] = te[15];
    return array;
  }
};
__name(Matrix4, "Matrix4");
Matrix4.prototype.isMatrix4 = true;
var _v1$1 = /* @__PURE__ */ new Vector3();
var _m1 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix = /* @__PURE__ */ new Matrix4();
var _quaternion$1 = /* @__PURE__ */ new Quaternion();
var Euler = class {
  constructor(x3 = 0, y3 = 0, z2 = 0, order = Euler.DefaultOrder) {
    this._x = x3;
    this._y = y3;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x3, y3, z2, order) {
    this._x = x3;
    this._y = y3;
    this._z = z2;
    this._order = order || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m3, order, update) {
    const clamp = MathUtils.clamp;
    const te = m3.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update) {
    _matrix.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v3, order) {
    return this.set(v3.x, v3.y, v3.z, order || this._order);
  }
  reorder(newOrder) {
    _quaternion$1.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$1, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this._x;
    array[offset3 + 1] = this._y;
    array[offset3 + 2] = this._z;
    array[offset3 + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
};
__name(Euler, "Euler");
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
};
__name(Layers, "Layers");
var _object3DId = 0;
var _v1$2 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();
var _position = new Vector3();
var _scale = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = {type: "added"};
var _removedEvent = {type: "removed"};
function Object3D() {
  Object.defineProperty(this, "id", {value: _object3DId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  __name(onRotationChange, "onRotationChange");
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  __name(onQuaternionChange, "onQuaternionChange");
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
__name(Object3D, "Object3D");
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q2) {
    this.quaternion.premultiply(q2);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m3) {
    this.quaternion.setFromRotationMatrix(m3);
  },
  setRotationFromQuaternion: function(q2) {
    this.quaternion.copy(q2);
  },
  rotateOnAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function(axis, distance) {
    _v1$2.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$2.multiplyScalar(distance));
    return this;
  },
  translateX: function(distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function(distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function(distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function(x3, y3, z2) {
    if (x3.isVector3) {
      _target.copy(x3);
    } else {
      _target.set(x3, y3, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function(object) {
    if (arguments.length > 1) {
      for (let i3 = 0; i3 < arguments.length; i3++) {
        this.add(arguments[i3]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (let i3 = 0; i3 < arguments.length; i3++) {
        this.remove(arguments[i3]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function() {
    for (let i3 = 0; i3 < this.children.length; i3++) {
      const object = this.children[i3];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name) {
    return this.getObjectByProperty("name", name);
  },
  getObjectByProperty: function(name, value) {
    if (this[name] === value)
      return this;
    for (let i3 = 0, l3 = this.children.length; i3 < l3; i3++) {
      const child = this.children[i3];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target2 = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target2.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
      target2 = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target2, _scale);
    return target2;
  },
  getWorldScale: function(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Object3D: .getWorldScale() target is now required");
      target2 = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion$2, target2);
    return target2;
  },
  getWorldDirection: function(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target2 = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e3 = this.matrixWorld.elements;
    return target2.set(e3[8], e3[9], e3[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    const children = this.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      children[i3].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      children[i3].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      children[i3].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
        children[i3].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    __name(serialize, "serialize");
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i3 = 0, l3 = shapes.length; i3 < l3; i3++) {
            const shape = shapes[i3];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i3 = 0, l3 = this.material.length; i3 < l3; i3++) {
          uuids.push(serialize(meta.materials, this.material[i3]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i3 = 0; i3 < this.children.length; i3++) {
        object.children.push(this.children[i3].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i3 = 0; i3 < this.animations.length; i3++) {
        const animation = this.animations[i3];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
    __name(extractFromCache, "extractFromCache");
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i3 = 0; i3 < source.children.length; i3++) {
        const child = source.children[i3];
        this.add(child.clone());
      }
    }
    return this;
  }
});
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x3, y3, z2, w3) {
    this.normal.set(x3, y3, z2);
    this.constant = w3;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a3, b3, c3) {
    const normal = _vector1.subVectors(c3, b3).cross(_vector2.subVectors(a3, b3)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a3);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target2 = new Vector3();
    }
    return target2.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Plane: .intersectLine() target is now required");
      target2 = new Vector3();
    }
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target2.copy(line.start);
      }
      return void 0;
    }
    const t3 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t3 < 0 || t3 > 1) {
      return void 0;
    }
    return target2.copy(direction).multiplyScalar(t3).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box2) {
    return box2.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target2 = new Vector3();
    }
    return target2.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset3) {
    this.constant -= offset3.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
__name(Plane, "Plane");
Plane.prototype.isPlane = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$1 = /* @__PURE__ */ new Vector3();
var _v3 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var Triangle = class {
  constructor(a3 = new Vector3(), b3 = new Vector3(), c3 = new Vector3()) {
    this.a = a3;
    this.b = b3;
    this.c = c3;
  }
  static getNormal(a3, b3, c3, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Triangle: .getNormal() target is now required");
      target2 = new Vector3();
    }
    target2.subVectors(c3, b3);
    _v0$1.subVectors(a3, b3);
    target2.cross(_v0$1);
    const targetLengthSq = target2.lengthSq();
    if (targetLengthSq > 0) {
      return target2.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target2.set(0, 0, 0);
  }
  static getBarycoord(point, a3, b3, c3, target2) {
    _v0$1.subVectors(c3, a3);
    _v1$3.subVectors(b3, a3);
    _v2$1.subVectors(point, a3);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$1);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$1);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target2 === void 0) {
      console.warn("THREE.Triangle: .getBarycoord() target is now required");
      target2 = new Vector3();
    }
    if (denom === 0) {
      return target2.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u3 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v3 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target2.set(1 - u3 - v3, v3, u3);
  }
  static containsPoint(point, a3, b3, c3) {
    this.getBarycoord(point, a3, b3, c3, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }
  static getUV(point, p1, p22, p3, uv1, uv2, uv3, target2) {
    this.getBarycoord(point, p1, p22, p3, _v3);
    target2.set(0, 0);
    target2.addScaledVector(uv1, _v3.x);
    target2.addScaledVector(uv2, _v3.y);
    target2.addScaledVector(uv3, _v3.z);
    return target2;
  }
  static isFrontFacing(a3, b3, c3, direction) {
    _v0$1.subVectors(c3, b3);
    _v1$3.subVectors(a3, b3);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a3, b3, c3) {
    this.a.copy(a3);
    this.b.copy(b3);
    this.c.copy(c3);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i22) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i22]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target2 = new Vector3();
    }
    return target2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target2) {
    return Triangle.getNormal(this.a, this.b, this.c, target2);
  }
  getPlane(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target2 = new Plane();
    }
    return target2.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target2) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target2);
  }
  getUV(point, uv1, uv2, uv3, target2) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target2);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box2) {
    return box2.intersectsTriangle(this);
  }
  closestPointToPoint(p3, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
      target2 = new Vector3();
    }
    const a3 = this.a, b3 = this.b, c3 = this.c;
    let v3, w3;
    _vab.subVectors(b3, a3);
    _vac.subVectors(c3, a3);
    _vap.subVectors(p3, a3);
    const d1 = _vab.dot(_vap);
    const d22 = _vac.dot(_vap);
    if (d1 <= 0 && d22 <= 0) {
      return target2.copy(a3);
    }
    _vbp.subVectors(p3, b3);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target2.copy(b3);
    }
    const vc = d1 * d4 - d3 * d22;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v3 = d1 / (d1 - d3);
      return target2.copy(a3).addScaledVector(_vab, v3);
    }
    _vcp.subVectors(p3, c3);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target2.copy(c3);
    }
    const vb = d5 * d22 - d1 * d6;
    if (vb <= 0 && d22 >= 0 && d6 <= 0) {
      w3 = d22 / (d22 - d6);
      return target2.copy(a3).addScaledVector(_vac, w3);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c3, b3);
      w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target2.copy(b3).addScaledVector(_vbc, w3);
    }
    const denom = 1 / (va + vb + vc);
    v3 = vb * denom;
    w3 = vc * denom;
    return target2.copy(a3).addScaledVector(_vab, v3).addScaledVector(_vac, w3);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
__name(Triangle, "Triangle");
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
__name(Material, "Material");
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor)
      data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
      data.refractionRatio = this.refractionRatio;
      if (this.combine !== void 0)
        data.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data.size = this.size;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data.morphTargets = true;
    if (this.morphNormals === true)
      data.morphNormals = true;
    if (this.skinning === true)
      data.skinning = true;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    __name(extractFromCache, "extractFromCache");
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i3 = 0; i3 !== n2; ++i3) {
        dstPlanes[i3] = srcPlanes[i3].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
var _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var _hslA = {h: 0, s: 0, l: 0};
var _hslB = {h: 0, s: 0, l: 0};
function hue2rgb(p3, q2, t3) {
  if (t3 < 0)
    t3 += 1;
  if (t3 > 1)
    t3 -= 1;
  if (t3 < 1 / 6)
    return p3 + (q2 - p3) * 6 * t3;
  if (t3 < 1 / 2)
    return q2;
  if (t3 < 2 / 3)
    return p3 + (q2 - p3) * 6 * (2 / 3 - t3);
  return p3;
}
__name(hue2rgb, "hue2rgb");
function SRGBToLinear(c3) {
  return c3 < 0.04045 ? c3 * 0.0773993808 : Math.pow(c3 * 0.9478672986 + 0.0521327014, 2.4);
}
__name(SRGBToLinear, "SRGBToLinear");
function LinearToSRGB(c3) {
  return c3 < 31308e-7 ? c3 * 12.92 : 1.055 * Math.pow(c3, 0.41666) - 0.055;
}
__name(LinearToSRGB, "LinearToSRGB");
var Color = class {
  constructor(r3, g3, b3) {
    if (g3 === void 0 && b3 === void 0) {
      return this.set(r3);
    }
    return this.setRGB(r3, g3, b3);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r3, g3, b3) {
    this.r = r3;
    this.g = g3;
    this.b = b3;
    return this;
  }
  setHSL(h, s3, l3) {
    h = MathUtils.euclideanModulo(h, 1);
    s3 = MathUtils.clamp(s3, 0, 1);
    l3 = MathUtils.clamp(l3, 0, 1);
    if (s3 === 0) {
      this.r = this.g = this.b = l3;
    } else {
      const p3 = l3 <= 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
      const q2 = 2 * l3 - p3;
      this.r = hue2rgb(q2, p3, h + 1 / 3);
      this.g = hue2rgb(q2, p3, h);
      this.b = hue2rgb(q2, p3, h - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    __name(handleAlpha, "handleAlpha");
    let m3;
    if (m3 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m3[1];
      const components = m3[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color[1]) / 360;
            const s3 = parseInt(color[2], 10) / 100;
            const l3 = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s3, l3);
          }
          break;
      }
    } else if (m3 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m3[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target2 = {h: 0, s: 0, l: 0};
    }
    const r3 = this.r, g3 = this.g, b3 = this.b;
    const max = Math.max(r3, g3, b3);
    const min = Math.min(r3, g3, b3);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r3:
          hue = (g3 - b3) / delta + (g3 < b3 ? 6 : 0);
          break;
        case g3:
          hue = (b3 - r3) / delta + 2;
          break;
        case b3:
          hue = (r3 - g3) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target2.h = hue;
    target2.s = saturation;
    target2.l = lightness;
    return target2;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h, s3, l3) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s3;
    _hslA.l += l3;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s3) {
    this.r += s3;
    this.g += s3;
    this.b += s3;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s3) {
    this.r *= s3;
    this.g *= s3;
    this.b *= s3;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s3 = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l3 = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s3, l3);
    return this;
  }
  equals(c3) {
    return c3.r === this.r && c3.g === this.g && c3.b === this.b;
  }
  fromArray(array, offset3 = 0) {
    this.r = array[offset3];
    this.g = array[offset3 + 1];
    this.b = array[offset3 + 2];
    return this;
  }
  toArray(array = [], offset3 = 0) {
    array[offset3] = this.r;
    array[offset3 + 1] = this.g;
    array[offset3 + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
};
__name(Color, "Color");
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
__name(MeshBasicMaterial, "MeshBasicMaterial");
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
var _vector$3 = new Vector3();
var _vector2$1 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
}
__name(BufferAttribute, "BufferAttribute");
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i3 = 0, l3 = this.itemSize; i3 < l3; i3++) {
      this.array[index1 + i3] = attribute.array[index2 + i3];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors2) {
    const array = this.array;
    let offset3 = 0;
    for (let i3 = 0, l3 = colors2.length; i3 < l3; i3++) {
      let color = colors2[i3];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i3);
        color = new Color();
      }
      array[offset3++] = color.r;
      array[offset3++] = color.g;
      array[offset3++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    const array = this.array;
    let offset3 = 0;
    for (let i3 = 0, l3 = vectors.length; i3 < l3; i3++) {
      let vector = vectors[i3];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i3);
        vector = new Vector2();
      }
      array[offset3++] = vector.x;
      array[offset3++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    const array = this.array;
    let offset3 = 0;
    for (let i3 = 0, l3 = vectors.length; i3 < l3; i3++) {
      let vector = vectors[i3];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i3);
        vector = new Vector3();
      }
      array[offset3++] = vector.x;
      array[offset3++] = vector.y;
      array[offset3++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    const array = this.array;
    let offset3 = 0;
    for (let i3 = 0, l3 = vectors.length; i3 < l3; i3++) {
      let vector = vectors[i3];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i3);
        vector = new Vector4();
      }
      array[offset3++] = vector.x;
      array[offset3++] = vector.y;
      array[offset3++] = vector.z;
      array[offset3++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function(m3) {
    if (this.itemSize === 2) {
      for (let i3 = 0, l3 = this.count; i3 < l3; i3++) {
        _vector2$1.fromBufferAttribute(this, i3);
        _vector2$1.applyMatrix3(m3);
        this.setXY(i3, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i3 = 0, l3 = this.count; i3 < l3; i3++) {
        _vector$3.fromBufferAttribute(this, i3);
        _vector$3.applyMatrix3(m3);
        this.setXYZ(i3, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }
    return this;
  },
  applyMatrix4: function(m3) {
    for (let i3 = 0, l3 = this.count; i3 < l3; i3++) {
      _vector$3.x = this.getX(i3);
      _vector$3.y = this.getY(i3);
      _vector$3.z = this.getZ(i3);
      _vector$3.applyMatrix4(m3);
      this.setXYZ(i3, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  applyNormalMatrix: function(m3) {
    for (let i3 = 0, l3 = this.count; i3 < l3; i3++) {
      _vector$3.x = this.getX(i3);
      _vector$3.y = this.getY(i3);
      _vector$3.z = this.getZ(i3);
      _vector$3.applyNormalMatrix(m3);
      this.setXYZ(i3, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  transformDirection: function(m3) {
    for (let i3 = 0, l3 = this.count; i3 < l3; i3++) {
      _vector$3.x = this.getX(i3);
      _vector$3.y = this.getY(i3);
      _vector$3.z = this.getZ(i3);
      _vector$3.transformDirection(m3);
      this.setXYZ(i3, _vector$3.x, _vector$3.y, _vector$3.z);
    }
    return this;
  },
  set: function(value, offset3 = 0) {
    this.array.set(value, offset3);
    return this;
  },
  getX: function(index) {
    return this.array[index * this.itemSize];
  },
  setX: function(index, x3) {
    this.array[index * this.itemSize] = x3;
    return this;
  },
  getY: function(index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function(index, y3) {
    this.array[index * this.itemSize + 1] = y3;
    return this;
  },
  getZ: function(index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function(index, z2) {
    this.array[index * this.itemSize + 2] = z2;
    return this;
  },
  getW: function(index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function(index, w3) {
    this.array[index * this.itemSize + 3] = w3;
    return this;
  },
  setXY: function(index, x3, y3) {
    index *= this.itemSize;
    this.array[index + 0] = x3;
    this.array[index + 1] = y3;
    return this;
  },
  setXYZ: function(index, x3, y3, z2) {
    index *= this.itemSize;
    this.array[index + 0] = x3;
    this.array[index + 1] = y3;
    this.array[index + 2] = z2;
    return this;
  },
  setXYZW: function(index, x3, y3, z2, w3) {
    index *= this.itemSize;
    this.array[index + 0] = x3;
    this.array[index + 1] = y3;
    this.array[index + 2] = z2;
    this.array[index + 3] = w3;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
__name(Int8BufferAttribute, "Int8BufferAttribute");
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
__name(Uint8BufferAttribute, "Uint8BufferAttribute");
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
__name(Uint8ClampedBufferAttribute, "Uint8ClampedBufferAttribute");
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
__name(Int16BufferAttribute, "Int16BufferAttribute");
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
__name(Uint16BufferAttribute, "Uint16BufferAttribute");
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
__name(Int32BufferAttribute, "Int32BufferAttribute");
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
__name(Uint32BufferAttribute, "Uint32BufferAttribute");
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
__name(Float16BufferAttribute, "Float16BufferAttribute");
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
__name(Float32BufferAttribute, "Float32BufferAttribute");
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
__name(Float64BufferAttribute, "Float64BufferAttribute");
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i3 = 1, l3 = array.length; i3 < l3; ++i3) {
    if (array[i3] > max)
      max = array[i3];
  }
  return max;
}
__name(arrayMax, "arrayMax");
var _id = 0;
var _m1$2 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$2 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$4 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, "id", {value: _id++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
  this.userData = {};
}
__name(BufferGeometry, "BufferGeometry");
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  setAttribute: function(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  },
  deleteAttribute: function(name) {
    delete this.attributes[name];
    return this;
  },
  hasAttribute: function(name) {
    return this.attributes[name] !== void 0;
  },
  addGroup: function(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function(x3, y3, z2) {
    _m1$2.makeTranslation(x3, y3, z2);
    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function(x3, y3, z2) {
    _m1$2.makeScale(x3, y3, z2);
    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function(points) {
    const position = [];
    for (let i3 = 0, l3 = points.length; i3 < l3; i3++) {
      const point = points[i3];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i3 = 0, il = morphAttributesPosition.length; i3 < il; i3++) {
          const morphAttribute = morphAttributesPosition[i3];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$4);
            _vector$4.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center2 = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i3 = 0, il = morphAttributesPosition.length; i3 < il; i3++) {
          const morphAttribute = morphAttributesPosition[i3];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$4);
            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center2);
      let maxRadiusSq = 0;
      for (let i3 = 0, il = position.count; i3 < il; i3++) {
        _vector$4.fromBufferAttribute(position, i3);
        maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_vector$4));
      }
      if (morphAttributesPosition) {
        for (let i3 = 0, il = morphAttributesPosition.length; i3 < il; i3++) {
          const morphAttribute = morphAttributesPosition[i3];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j3 = 0, jl = morphAttribute.count; j3 < jl; j3++) {
            _vector$4.fromBufferAttribute(morphAttribute, j3);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j3);
              _vector$4.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(_vector$4));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function() {
  },
  computeTangents: function() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i3 = 0; i3 < nVertices; i3++) {
      tan1[i3] = new Vector3();
      tan2[i3] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a3, b3, c3) {
      vA.fromArray(positions, a3 * 3);
      vB.fromArray(positions, b3 * 3);
      vC.fromArray(positions, c3 * 3);
      uvA.fromArray(uvs, a3 * 2);
      uvB.fromArray(uvs, b3 * 2);
      uvC.fromArray(uvs, c3 * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r3 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r3))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r3);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r3);
      tan1[a3].add(sdir);
      tan1[b3].add(sdir);
      tan1[c3].add(sdir);
      tan2[a3].add(tdir);
      tan2[b3].add(tdir);
      tan2[c3].add(tdir);
    }
    __name(handleTriangle, "handleTriangle");
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i3 = 0, il = groups.length; i3 < il; ++i3) {
      const group = groups[i3];
      const start = group.start;
      const count = group.count;
      for (let j3 = start, jl = start + count; j3 < jl; j3 += 3) {
        handleTriangle(indices[j3 + 0], indices[j3 + 1], indices[j3 + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v3) {
      n2.fromArray(normals, v3 * 3);
      n22.copy(n2);
      const t3 = tan1[v3];
      tmp2.copy(t3);
      tmp2.sub(n2.multiplyScalar(n2.dot(t3))).normalize();
      tmp22.crossVectors(n22, t3);
      const test = tmp22.dot(tan2[v3]);
      const w3 = test < 0 ? -1 : 1;
      tangents[v3 * 4] = tmp2.x;
      tangents[v3 * 4 + 1] = tmp2.y;
      tangents[v3 * 4 + 2] = tmp2.z;
      tangents[v3 * 4 + 3] = w3;
    }
    __name(handleVertex, "handleVertex");
    for (let i3 = 0, il = groups.length; i3 < il; ++i3) {
      const group = groups[i3];
      const start = group.start;
      const count = group.count;
      for (let j3 = start, jl = start + count; j3 < jl; j3 += 3) {
        handleVertex(indices[j3 + 0]);
        handleVertex(indices[j3 + 1]);
        handleVertex(indices[j3 + 2]);
      }
    }
  },
  computeVertexNormals: function() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i3 = 0, il = normalAttribute.count; i3 < il; i3++) {
          normalAttribute.setXYZ(i3, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i3 = 0, il = index.count; i3 < il; i3 += 3) {
          const vA = index.getX(i3 + 0);
          const vB = index.getX(i3 + 1);
          const vC = index.getX(i3 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i3 = 0, il = positionAttribute.count; i3 < il; i3 += 3) {
          pA.fromBufferAttribute(positionAttribute, i3 + 0);
          pB.fromBufferAttribute(positionAttribute, i3 + 1);
          pC.fromBufferAttribute(positionAttribute, i3 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i3 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i3 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i3 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function(geometry, offset3) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset3 === void 0) {
      offset3 = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset3;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i3 = 0, j3 = attributeOffset; i3 < length; i3++, j3++) {
        attributeArray1[j3] = attributeArray2[i3];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    const normals = this.attributes.normal;
    for (let i3 = 0, il = normals.count; i3 < il; i3++) {
      _vector$4.fromBufferAttribute(normals, i3);
      _vector$4.normalize();
      normals.setXYZ(i3, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i3 = 0, l3 = indices2.length; i3 < l3; i3++) {
        index = indices2[i3] * itemSize;
        for (let j3 = 0; j3 < itemSize; j3++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    __name(convertBufferAttribute, "convertBufferAttribute");
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i3 = 0, il = morphAttribute.length; i3 < il; i3++) {
        const attribute = morphAttribute[i3];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i3 = 0, l3 = groups.length; i3 < l3; i3++) {
      const group = groups[i3];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = {attributes: {}};
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data.data);
      if (attribute.name !== "")
        attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i3 = 0, il = attributeArray.length; i3 < il; i3++) {
        const attribute = attributeArray[i3];
        const attributeData = attribute.toJSON(data.data);
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        array.push(attributeData);
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i3 = 0, l3 = morphAttribute.length; i3 < l3; i3++) {
        array.push(morphAttribute[i3].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i3 = 0, l3 = groups.length; i3 < l3; i3++) {
      const group = groups[i3];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _tempA = new Vector3();
var _tempB = new Vector3();
var _tempC = new Vector3();
var _morphA = new Vector3();
var _morphB = new Vector3();
var _morphC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
__name(Mesh, "Mesh");
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m3 = 0, ml = morphAttribute.length; m3 < ml; m3++) {
            const name = morphAttribute[m3].name || String(m3);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m3;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i3 = 0, il = groups.length; i3 < il; i3++) {
            const group = groups[i3];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j3 = start, jl = end; j3 < jl; j3 += 3) {
              const a3 = index.getX(j3);
              const b3 = index.getX(j3 + 1);
              const c3 = index.getX(j3 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b3, c3);
              if (intersection) {
                intersection.faceIndex = Math.floor(j3 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i3 = start, il = end; i3 < il; i3 += 3) {
            const a3 = index.getX(i3);
            const b3 = index.getX(i3 + 1);
            const c3 = index.getX(i3 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b3, c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(i3 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i3 = 0, il = groups.length; i3 < il; i3++) {
            const group = groups[i3];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j3 = start, jl = end; j3 < jl; j3 += 3) {
              const a3 = j3;
              const b3 = j3 + 1;
              const c3 = j3 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b3, c3);
              if (intersection) {
                intersection.faceIndex = Math.floor(j3 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i3 = start, il = end; i3 < il; i3 += 3) {
            const a3 = i3;
            const b3 = i3 + 1;
            const c3 = i3 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b3, c3);
            if (intersection) {
              intersection.faceIndex = Math.floor(i3 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
__name(checkIntersection, "checkIntersection");
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a3, b3, c3) {
  _vA.fromBufferAttribute(position, a3);
  _vB.fromBufferAttribute(position, b3);
  _vC.fromBufferAttribute(position, c3);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i3 = 0, il = morphPosition.length; i3 < il; i3++) {
      const influence = morphInfluences[i3];
      const morphAttribute = morphPosition[i3];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a3);
      _tempB.fromBufferAttribute(morphAttribute, b3);
      _tempC.fromBufferAttribute(morphAttribute, c3);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);
        _morphB.addScaledVector(_tempB.sub(_vB), influence);
        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }
    _vA.add(_morphA);
    _vB.add(_morphB);
    _vC.add(_morphC);
  }
  if (object.isSkinnedMesh && material.skinning) {
    object.boneTransform(a3, _vA);
    object.boneTransform(b3, _vB);
    object.boneTransform(c3, _vC);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a3);
      _uvB.fromBufferAttribute(uv, b3);
      _uvC.fromBufferAttribute(uv, c3);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a3);
      _uvB.fromBufferAttribute(uv2, b3);
      _uvC.fromBufferAttribute(uv2, c3);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    const face = {
      a: a3,
      b: b3,
      c: c3,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }
  return intersection;
}
__name(checkBufferGeometryIntersection, "checkBufferGeometryIntersection");
var BoxGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u3, v3, w3, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y3 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x3 = ix * segmentWidth - widthHalf;
          vector[u3] = x3 * udir;
          vector[v3] = y3 * vdir;
          vector[w3] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u3] = 0;
          vector[v3] = 0;
          vector[w3] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a3 = numberOfVertices + ix + gridX1 * iy;
          const b3 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c3 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d3 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a3, b3, d3);
          indices.push(b3, c3, d3);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
    __name(buildPlane, "buildPlane");
  }
};
__name(BoxGeometry, "BoxGeometry");
function cloneUniforms(src) {
  const dst = {};
  for (const u3 in src) {
    dst[u3] = {};
    for (const p3 in src[u3]) {
      const property = src[u3][p3];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u3][p3] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u3][p3] = property.slice();
      } else {
        dst[u3][p3] = property;
      }
    }
  }
  return dst;
}
__name(cloneUniforms, "cloneUniforms");
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u3 = 0; u3 < uniforms.length; u3++) {
    const tmp2 = cloneUniforms(uniforms[u3]);
    for (const p3 in tmp2) {
      merged[p3] = tmp2[p3];
    }
  }
  return merged;
}
__name(mergeUniforms, "mergeUniforms");
var UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
__name(ShaderMaterial, "ShaderMaterial");
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.glslVersion = this.glslVersion;
  data.uniforms = {};
  for (const name in this.uniforms) {
    const uniform = this.uniforms[name];
    const value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data.extensions = extensions;
  return data;
};
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
__name(Camera, "Camera");
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target2 = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e3 = this.matrixWorld.elements;
    return target2.set(-e3[8], -e3[9], -e3[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect2;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
__name(PerspectiveCamera, "PerspectiveCamera");
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x3, y3, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y3;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
var fov = 90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
};
__name(CubeCamera, "CubeCamera");
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this._needsFlipEnvMap = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
__name(CubeTexture, "CubeTexture");
CubeTexture.prototype.isCubeTexture = true;
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i3 = 0; i3 < 6; i3++) {
      renderer.setRenderTarget(this, i3);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
__name(WebGLCubeRenderTarget, "WebGLCubeRenderTarget");
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
var DataTexture = class extends Texture {
  constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {data: data || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
};
__name(DataTexture, "DataTexture");
DataTexture.prototype.isDataTexture = true;
var _sphere$1 = /* @__PURE__ */ new Sphere();
var _vector$5 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p22 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p22, p3, p4, p5];
  }
  set(p0, p1, p22, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p22);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i3 = 0; i3 < 6; i3++) {
      planes[i3].copy(frustum.planes[i3]);
    }
    return this;
  }
  setFromProjectionMatrix(m3) {
    const planes = this.planes;
    const me = m3.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSprite(sprite) {
    _sphere$1.center.set(0, 0, 0);
    _sphere$1.radius = 0.7071067811865476;
    _sphere$1.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$1);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center2 = sphere.center;
    const negRadius = -sphere.radius;
    for (let i3 = 0; i3 < 6; i3++) {
      const distance = planes[i3].distanceToPoint(center2);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box2) {
    const planes = this.planes;
    for (let i3 = 0; i3 < 6; i3++) {
      const plane = planes[i3];
      _vector$5.x = plane.normal.x > 0 ? box2.max.x : box2.min.x;
      _vector$5.y = plane.normal.y > 0 ? box2.max.y : box2.min.y;
      _vector$5.z = plane.normal.z > 0 ? box2.max.z : box2.min.z;
      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i3 = 0; i3 < 6; i3++) {
      if (planes[i3].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
__name(Frustum, "Frustum");
function WebGLAnimation() {
  let context3 = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context3.requestAnimationFrame(onAnimationFrame);
  }
  __name(onAnimationFrame, "onAnimationFrame");
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context3.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context3.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context3 = value;
    }
  };
}
__name(WebGLAnimation, "WebGLAnimation");
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  __name(createBuffer, "createBuffer");
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  __name(updateBuffer, "updateBuffer");
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  __name(get, "get");
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  __name(remove, "remove");
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  __name(update, "update");
  return {
    get,
    remove,
    update
  };
}
__name(WebGLAttributes, "WebGLAttributes");
var PlaneGeometry = class extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y3 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x3 = ix * segment_width - width_half;
        vertices.push(x3, -y3, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a3 = ix + gridX1 * iy;
        const b3 = ix + gridX1 * (iy + 1);
        const c3 = ix + 1 + gridX1 * (iy + 1);
        const d3 = ix + 1 + gridX1 * iy;
        indices.push(a3, b3, d3);
        indices.push(b3, c3, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
__name(PlaneGeometry, "PlaneGeometry");
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmissionmap_fragment,
  transmissionmap_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
var UniformsLib = {
  common: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    map: {value: null},
    uvTransform: {value: new Matrix3()},
    uv2Transform: {value: new Matrix3()},
    alphaMap: {value: null}
  },
  specularmap: {
    specularMap: {value: null}
  },
  envmap: {
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98},
    maxMipLevel: {value: 0}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    lightProbe: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {}
    }},
    directionalLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    }},
    spotLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    }},
    pointLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }},
    ltc_1: {value: null},
    ltc_2: {value: null}
  },
  points: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  },
  sprite: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    center: {value: new Vector2(0.5, 0.5)},
    rotation: {value: 0},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        specular: {value: new Color(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {value: new Matrix3()},
      t2D: {value: null}
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: {value: new Vector3()},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: {value: new Color(0)},
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new Vector2(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Color(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      if (background.isWebGLCubeRenderTarget) {
        background = background.texture;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  __name(render, "render");
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  __name(setClear, "setClear");
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
__name(WebGLBackground, "WebGLBackground");
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  __name(setup, "setup");
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  __name(createVertexArrayObject, "createVertexArrayObject");
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  __name(bindVertexArrayObject, "bindVertexArrayObject");
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  __name(deleteVertexArrayObject, "deleteVertexArrayObject");
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  __name(getBindingState, "getBindingState");
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i3 = 0; i3 < maxVertexAttributes; i3++) {
      newAttributes[i3] = 0;
      enabledAttributes[i3] = 0;
      attributeDivisors[i3] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  __name(createBindingState, "createBindingState");
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  __name(needsUpdate, "needsUpdate");
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  __name(saveCache, "saveCache");
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i3 = 0, il = newAttributes.length; i3 < il; i3++) {
      newAttributes[i3] = 0;
    }
  }
  __name(initAttributes, "initAttributes");
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  __name(enableAttribute, "enableAttribute");
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  __name(enableAttributeAndDivisor, "enableAttributeAndDivisor");
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i3 = 0, il = enabledAttributes.length; i3 < il; i3++) {
      if (enabledAttributes[i3] !== newAttributes[i3]) {
        gl.disableVertexAttribArray(i3);
        enabledAttributes[i3] = 0;
      }
    }
  }
  __name(disableUnusedAttributes, "disableUnusedAttributes");
  function vertexAttribPointer(index, size, type, normalized, stride, offset3) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset3);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset3);
    }
  }
  __name(vertexAttribPointer, "vertexAttribPointer");
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset3 = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset3 * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name === "instanceColor") {
          const attribute = attributes.get(object.instanceColor);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  __name(setupVertexAttributes, "setupVertexAttributes");
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  __name(dispose, "dispose");
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  __name(releaseStatesOfGeometry, "releaseStatesOfGeometry");
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  __name(releaseStatesOfProgram, "releaseStatesOfProgram");
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  __name(reset, "reset");
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  __name(resetDefaultState, "resetDefaultState");
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
__name(WebGLBindingStates, "WebGLBindingStates");
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  __name(setMode, "setMode");
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  __name(render, "render");
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  __name(renderInstances, "renderInstances");
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
__name(WebGLBufferRenderer, "WebGLBufferRenderer");
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  __name(getMaxAnisotropy, "getMaxAnisotropy");
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  __name(getMaxPrecision, "getMaxPrecision");
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
__name(WebGLCapabilities, "WebGLCapabilities");
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i3 = 0; i3 !== lGlobal; ++i3) {
        dstArray[i3] = globalState[i3];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  __name(resetGlobalState, "resetGlobalState");
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i3 = 0, i4 = dstOffset; i3 !== nPlanes; ++i3, i4 += 4) {
          plane.copy(planes[i3]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
  __name(projectPlanes, "projectPlanes");
}
__name(WebGLClipping, "WebGLClipping");
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  __name(mapTextureMapping, "mapTextureMapping");
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  __name(get, "get");
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  __name(onTextureDispose, "onTextureDispose");
  function dispose() {
    cubemaps = new WeakMap();
  }
  __name(dispose, "dispose");
  return {
    get,
    dispose
  };
}
__name(WebGLCubeMaps, "WebGLCubeMaps");
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  __name(getExtension, "getExtension");
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
__name(WebGLExtensions, "WebGLExtensions");
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  __name(onGeometryDispose, "onGeometryDispose");
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  __name(get, "get");
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i3 = 0, l3 = array.length; i3 < l3; i3++) {
        attributes.update(array[i3], 34962);
      }
    }
  }
  __name(update, "update");
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i3 = 0, l3 = array.length; i3 < l3; i3 += 3) {
        const a3 = array[i3 + 0];
        const b3 = array[i3 + 1];
        const c3 = array[i3 + 2];
        indices.push(a3, b3, b3, c3, c3, a3);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i3 = 0, l3 = array.length / 3 - 1; i3 < l3; i3 += 3) {
        const a3 = i3 + 0;
        const b3 = i3 + 1;
        const c3 = i3 + 2;
        indices.push(a3, b3, b3, c3, c3, a3);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  __name(updateWireframeAttribute, "updateWireframeAttribute");
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  __name(getWireframeAttribute, "getWireframeAttribute");
  return {
    get,
    update,
    getWireframeAttribute
  };
}
__name(WebGLGeometries, "WebGLGeometries");
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  __name(setMode, "setMode");
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  __name(setIndex, "setIndex");
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  __name(render, "render");
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  __name(renderInstances, "renderInstances");
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
__name(WebGLIndexedBufferRenderer, "WebGLIndexedBufferRenderer");
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  __name(update, "update");
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  __name(reset, "reset");
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
__name(WebGLInfo, "WebGLInfo");
function numericalSort(a3, b3) {
  return a3[0] - b3[0];
}
__name(numericalSort, "numericalSort");
function absNumericalSort(a3, b3) {
  return Math.abs(b3[1]) - Math.abs(a3[1]);
}
__name(absNumericalSort, "absNumericalSort");
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i3 = 0; i3 < 8; i3++) {
    workInfluences[i3] = [i3, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i3 = 0; i3 < length; i3++) {
        influences[i3] = [i3, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i3 = 0; i3 < length; i3++) {
      const influence = influences[i3];
      influence[0] = i3;
      influence[1] = objectInfluences[i3];
    }
    influences.sort(absNumericalSort);
    for (let i3 = 0; i3 < 8; i3++) {
      if (i3 < length && influences[i3][1]) {
        workInfluences[i3][0] = influences[i3][0];
        workInfluences[i3][1] = influences[i3][1];
      } else {
        workInfluences[i3][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i3][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i3 = 0; i3 < 8; i3++) {
      const influence = workInfluences[i3];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i3) !== morphTargets[index]) {
          geometry.setAttribute("morphTarget" + i3, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i3) !== morphNormals[index]) {
          geometry.setAttribute("morphNormal" + i3, morphNormals[index]);
        }
        morphInfluences[i3] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i3) === true) {
          geometry.deleteAttribute("morphTarget" + i3);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i3) === true) {
          geometry.deleteAttribute("morphNormal" + i3);
        }
        morphInfluences[i3] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  __name(update, "update");
  return {
    update
  };
}
__name(WebGLMorphtargets, "WebGLMorphtargets");
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  __name(update, "update");
  function dispose() {
    updateMap = new WeakMap();
  }
  __name(dispose, "dispose");
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  __name(onInstancedMeshDispose, "onInstancedMeshDispose");
  return {
    update,
    dispose
  };
}
__name(WebGLObjects, "WebGLObjects");
var DataTexture2DArray = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
__name(DataTexture2DArray, "DataTexture2DArray");
DataTexture2DArray.prototype.isDataTexture2DArray = true;
var DataTexture3D = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
};
__name(DataTexture3D, "DataTexture3D");
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture2dArray = new DataTexture2DArray();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n2 = nBlocks * blockSize;
  let r3 = arrayCacheF32[n2];
  if (r3 === void 0) {
    r3 = new Float32Array(n2);
    arrayCacheF32[n2] = r3;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r3, 0);
    for (let i3 = 1, offset3 = 0; i3 !== nBlocks; ++i3) {
      offset3 += blockSize;
      array[i3].toArray(r3, offset3);
    }
  }
  return r3;
}
__name(flatten, "flatten");
function arraysEqual(a3, b3) {
  if (a3.length !== b3.length)
    return false;
  for (let i3 = 0, l3 = a3.length; i3 < l3; i3++) {
    if (a3[i3] !== b3[i3])
      return false;
  }
  return true;
}
__name(arraysEqual, "arraysEqual");
function copyArray(a3, b3) {
  for (let i3 = 0, l3 = b3.length; i3 < l3; i3++) {
    a3[i3] = b3[i3];
  }
}
__name(copyArray, "copyArray");
function allocTexUnits(textures, n2) {
  let r3 = arrayCacheI32[n2];
  if (r3 === void 0) {
    r3 = new Int32Array(n2);
    arrayCacheI32[n2] = r3;
  }
  for (let i3 = 0; i3 !== n2; ++i3) {
    r3[i3] = textures.allocateTextureUnit();
  }
  return r3;
}
__name(allocTexUnits, "allocTexUnits");
function setValueV1f(gl, v3) {
  const cache = this.cache;
  if (cache[0] === v3)
    return;
  gl.uniform1f(this.addr, v3);
  cache[0] = v3;
}
__name(setValueV1f, "setValueV1f");
function setValueV2f(gl, v3) {
  const cache = this.cache;
  if (v3.x !== void 0) {
    if (cache[0] !== v3.x || cache[1] !== v3.y) {
      gl.uniform2f(this.addr, v3.x, v3.y);
      cache[0] = v3.x;
      cache[1] = v3.y;
    }
  } else {
    if (arraysEqual(cache, v3))
      return;
    gl.uniform2fv(this.addr, v3);
    copyArray(cache, v3);
  }
}
__name(setValueV2f, "setValueV2f");
function setValueV3f(gl, v3) {
  const cache = this.cache;
  if (v3.x !== void 0) {
    if (cache[0] !== v3.x || cache[1] !== v3.y || cache[2] !== v3.z) {
      gl.uniform3f(this.addr, v3.x, v3.y, v3.z);
      cache[0] = v3.x;
      cache[1] = v3.y;
      cache[2] = v3.z;
    }
  } else if (v3.r !== void 0) {
    if (cache[0] !== v3.r || cache[1] !== v3.g || cache[2] !== v3.b) {
      gl.uniform3f(this.addr, v3.r, v3.g, v3.b);
      cache[0] = v3.r;
      cache[1] = v3.g;
      cache[2] = v3.b;
    }
  } else {
    if (arraysEqual(cache, v3))
      return;
    gl.uniform3fv(this.addr, v3);
    copyArray(cache, v3);
  }
}
__name(setValueV3f, "setValueV3f");
function setValueV4f(gl, v3) {
  const cache = this.cache;
  if (v3.x !== void 0) {
    if (cache[0] !== v3.x || cache[1] !== v3.y || cache[2] !== v3.z || cache[3] !== v3.w) {
      gl.uniform4f(this.addr, v3.x, v3.y, v3.z, v3.w);
      cache[0] = v3.x;
      cache[1] = v3.y;
      cache[2] = v3.z;
      cache[3] = v3.w;
    }
  } else {
    if (arraysEqual(cache, v3))
      return;
    gl.uniform4fv(this.addr, v3);
    copyArray(cache, v3);
  }
}
__name(setValueV4f, "setValueV4f");
function setValueM2(gl, v3) {
  const cache = this.cache;
  const elements = v3.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v3))
      return;
    gl.uniformMatrix2fv(this.addr, false, v3);
    copyArray(cache, v3);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
__name(setValueM2, "setValueM2");
function setValueM3(gl, v3) {
  const cache = this.cache;
  const elements = v3.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v3))
      return;
    gl.uniformMatrix3fv(this.addr, false, v3);
    copyArray(cache, v3);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
__name(setValueM3, "setValueM3");
function setValueM4(gl, v3) {
  const cache = this.cache;
  const elements = v3.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v3))
      return;
    gl.uniformMatrix4fv(this.addr, false, v3);
    copyArray(cache, v3);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
__name(setValueM4, "setValueM4");
function setValueT1(gl, v3, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v3 || emptyTexture, unit);
}
__name(setValueT1, "setValueT1");
function setValueT2DArray1(gl, v3, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v3 || emptyTexture2dArray, unit);
}
__name(setValueT2DArray1, "setValueT2DArray1");
function setValueT3D1(gl, v3, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v3 || emptyTexture3d, unit);
}
__name(setValueT3D1, "setValueT3D1");
function setValueT6(gl, v3, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v3 || emptyCubeTexture, unit);
}
__name(setValueT6, "setValueT6");
function setValueV1i(gl, v3) {
  const cache = this.cache;
  if (cache[0] === v3)
    return;
  gl.uniform1i(this.addr, v3);
  cache[0] = v3;
}
__name(setValueV1i, "setValueV1i");
function setValueV2i(gl, v3) {
  const cache = this.cache;
  if (arraysEqual(cache, v3))
    return;
  gl.uniform2iv(this.addr, v3);
  copyArray(cache, v3);
}
__name(setValueV2i, "setValueV2i");
function setValueV3i(gl, v3) {
  const cache = this.cache;
  if (arraysEqual(cache, v3))
    return;
  gl.uniform3iv(this.addr, v3);
  copyArray(cache, v3);
}
__name(setValueV3i, "setValueV3i");
function setValueV4i(gl, v3) {
  const cache = this.cache;
  if (arraysEqual(cache, v3))
    return;
  gl.uniform4iv(this.addr, v3);
  copyArray(cache, v3);
}
__name(setValueV4i, "setValueV4i");
function setValueV1ui(gl, v3) {
  const cache = this.cache;
  if (cache[0] === v3)
    return;
  gl.uniform1ui(this.addr, v3);
  cache[0] = v3;
}
__name(setValueV1ui, "setValueV1ui");
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
__name(getSingularSetter, "getSingularSetter");
function setValueV1fArray(gl, v3) {
  gl.uniform1fv(this.addr, v3);
}
__name(setValueV1fArray, "setValueV1fArray");
function setValueV1iArray(gl, v3) {
  gl.uniform1iv(this.addr, v3);
}
__name(setValueV1iArray, "setValueV1iArray");
function setValueV2iArray(gl, v3) {
  gl.uniform2iv(this.addr, v3);
}
__name(setValueV2iArray, "setValueV2iArray");
function setValueV3iArray(gl, v3) {
  gl.uniform3iv(this.addr, v3);
}
__name(setValueV3iArray, "setValueV3iArray");
function setValueV4iArray(gl, v3) {
  gl.uniform4iv(this.addr, v3);
}
__name(setValueV4iArray, "setValueV4iArray");
function setValueV2fArray(gl, v3) {
  const data = flatten(v3, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
__name(setValueV2fArray, "setValueV2fArray");
function setValueV3fArray(gl, v3) {
  const data = flatten(v3, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
__name(setValueV3fArray, "setValueV3fArray");
function setValueV4fArray(gl, v3) {
  const data = flatten(v3, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
__name(setValueV4fArray, "setValueV4fArray");
function setValueM2Array(gl, v3) {
  const data = flatten(v3, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
__name(setValueM2Array, "setValueM2Array");
function setValueM3Array(gl, v3) {
  const data = flatten(v3, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
__name(setValueM3Array, "setValueM3Array");
function setValueM4Array(gl, v3) {
  const data = flatten(v3, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
__name(setValueM4Array, "setValueM4Array");
function setValueT1Array(gl, v3, textures) {
  const n2 = v3.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i3 = 0; i3 !== n2; ++i3) {
    textures.safeSetTexture2D(v3[i3] || emptyTexture, units[i3]);
  }
}
__name(setValueT1Array, "setValueT1Array");
function setValueT6Array(gl, v3, textures) {
  const n2 = v3.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i3 = 0; i3 !== n2; ++i3) {
    textures.safeSetTextureCube(v3[i3] || emptyCubeTexture, units[i3]);
  }
}
__name(setValueT6Array, "setValueT6Array");
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
__name(getPureArraySetter, "getPureArraySetter");
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
__name(SingleUniform, "SingleUniform");
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
__name(PureArrayUniform, "PureArrayUniform");
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
__name(StructuredUniform, "StructuredUniform");
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i3 = 0, n2 = seq.length; i3 !== n2; ++i3) {
    const u3 = seq[i3];
    u3.setValue(gl, value[u3.id], textures);
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container2, uniformObject) {
  container2.seq.push(uniformObject);
  container2.map[uniformObject.id] = uniformObject;
}
__name(addUniform, "addUniform");
function parseUniform(activeInfo, addr, container2) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container2, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container2.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container2, next);
      }
      container2 = next;
    }
  }
}
__name(parseUniform, "parseUniform");
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl.getProgramParameter(program, 35718);
  for (let i3 = 0; i3 < n2; ++i3) {
    const info = gl.getActiveUniform(program, i3), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
__name(WebGLUniforms, "WebGLUniforms");
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u3 = this.map[name];
  if (u3 !== void 0)
    u3.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  const v3 = object[name];
  if (v3 !== void 0)
    this.setValue(gl, name, v3);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i3 = 0, n2 = seq.length; i3 !== n2; ++i3) {
    const u3 = seq[i3], v3 = values[u3.id];
    if (v3.needsUpdate !== false) {
      u3.setValue(gl, v3.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r3 = [];
  for (let i3 = 0, n2 = seq.length; i3 !== n2; ++i3) {
    const u3 = seq[i3];
    if (u3.id in values)
      r3.push(u3);
  }
  return r3;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
__name(WebGLShader, "WebGLShader");
var programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i3 = 0; i3 < lines.length; i3++) {
    lines[i3] = i3 + 1 + ": " + lines[i3];
  }
  return lines.join("\n");
}
__name(addLineNumbers, "addLineNumbers");
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
__name(getEncodingComponents, "getEncodingComponents");
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
__name(getShaderErrors, "getShaderErrors");
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
__name(getTexelDecodingFunction, "getTexelDecodingFunction");
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
__name(getTexelEncodingFunction, "getTexelEncodingFunction");
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
__name(getToneMappingFunction, "getToneMappingFunction");
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
__name(generateExtensions, "generateExtensions");
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
__name(generateDefines, "generateDefines");
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, 35721);
  for (let i3 = 0; i3 < n2; i3++) {
    const info = gl.getActiveAttrib(program, i3);
    const name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
__name(fetchAttributeLocations, "fetchAttributeLocations");
function filterEmptyLine(string) {
  return string !== "";
}
__name(filterEmptyLine, "filterEmptyLine");
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
__name(replaceLightNums, "replaceLightNums");
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
__name(replaceClippingPlaneNums, "replaceClippingPlaneNums");
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
__name(resolveIncludes, "resolveIncludes");
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
__name(includeReplacer, "includeReplacer");
var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
__name(unrollLoops, "unrollLoops");
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
__name(deprecatedLoopReplacer, "deprecatedLoopReplacer");
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i3 = parseInt(start); i3 < parseInt(end); i3++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i3);
  }
  return string;
}
__name(loopReplacer, "loopReplacer");
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
__name(generatePrecision, "generatePrecision");
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
__name(generateShadowMapTypeDefine, "generateShadowMapTypeDefine");
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
__name(generateEnvMapTypeDefine, "generateEnvMapTypeDefine");
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
__name(generateEnvMapModeDefine, "generateEnvMapModeDefine");
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
__name(generateEnvMapBlendingDefine, "generateEnvMapBlendingDefine");
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
__name(WebGLProgram, "WebGLProgram");
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  __name(getMaxBones, "getMaxBones");
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  __name(getTextureEncodingFromMap, "getTextureEncodingFromMap");
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  __name(getParameters, "getParameters");
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i3 = 0; i3 < parameterNames.length; i3++) {
        array.push(parameters[parameterNames[i3]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  __name(getProgramCacheKey, "getProgramCacheKey");
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  __name(getUniforms, "getUniforms");
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p3 = 0, pl = programs.length; p3 < pl; p3++) {
      const preexistingProgram = programs[p3];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  __name(acquireProgram, "acquireProgram");
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i3 = programs.indexOf(program);
      programs[i3] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  __name(releaseProgram, "releaseProgram");
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
__name(WebGLPrograms, "WebGLPrograms");
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  __name(get, "get");
  function remove(object) {
    properties.delete(object);
  }
  __name(remove, "remove");
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  __name(update, "update");
  function dispose() {
    properties = new WeakMap();
  }
  __name(dispose, "dispose");
  return {
    get,
    remove,
    update,
    dispose
  };
}
__name(WebGLProperties, "WebGLProperties");
function painterSortStable(a3, b3) {
  if (a3.groupOrder !== b3.groupOrder) {
    return a3.groupOrder - b3.groupOrder;
  } else if (a3.renderOrder !== b3.renderOrder) {
    return a3.renderOrder - b3.renderOrder;
  } else if (a3.program !== b3.program) {
    return a3.program.id - b3.program.id;
  } else if (a3.material.id !== b3.material.id) {
    return a3.material.id - b3.material.id;
  } else if (a3.z !== b3.z) {
    return a3.z - b3.z;
  } else {
    return a3.id - b3.id;
  }
}
__name(painterSortStable, "painterSortStable");
function reversePainterSortStable(a3, b3) {
  if (a3.groupOrder !== b3.groupOrder) {
    return a3.groupOrder - b3.groupOrder;
  } else if (a3.renderOrder !== b3.renderOrder) {
    return a3.renderOrder - b3.renderOrder;
  } else if (a3.z !== b3.z) {
    return b3.z - a3.z;
  } else {
    return a3.id - b3.id;
  }
}
__name(reversePainterSortStable, "reversePainterSortStable");
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {id: -1};
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  __name(init, "init");
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  __name(getNextRenderItem, "getNextRenderItem");
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  __name(push, "push");
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  __name(unshift, "unshift");
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  __name(sort, "sort");
  function finish() {
    for (let i3 = renderItemsIndex, il = renderItems.length; i3 < il; i3++) {
      const renderItem = renderItems[i3];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  __name(finish, "finish");
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
__name(WebGLRenderList, "WebGLRenderList");
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  __name(get, "get");
  function dispose() {
    lists = new WeakMap();
  }
  __name(dispose, "dispose");
  return {
    get,
    dispose
  };
}
__name(WebGLRenderLists, "WebGLRenderLists");
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
__name(UniformsCache, "UniformsCache");
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
__name(ShadowUniformsCache, "ShadowUniformsCache");
var nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
__name(shadowCastingLightsFirst, "shadowCastingLightsFirst");
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i3 = 0; i3 < 9; i3++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r3 = 0, g3 = 0, b3 = 0;
    for (let i3 = 0; i3 < 9; i3++)
      state.probe[i3].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i3 = 0, l3 = lights.length; i3 < l3; i3++) {
      const light = lights[i3];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r3 += color.r * intensity;
        g3 += color.g * intensity;
        b3 += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j3 = 0; j3 < 9; j3++) {
          state.probe[j3].addScaledVector(light.sh.coefficients[j3], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r3;
    state.ambient[1] = g3;
    state.ambient[2] = b3;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  __name(setup, "setup");
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i3 = 0, l3 = lights.length; i3 < l3; i3++) {
      const light = lights[i3];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  __name(setupView, "setupView");
  return {
    setup,
    setupView,
    state
  };
}
__name(WebGLLights, "WebGLLights");
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  __name(init, "init");
  function pushLight(light) {
    lightsArray.push(light);
  }
  __name(pushLight, "pushLight");
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  __name(pushShadow, "pushShadow");
  function setupLights() {
    lights.setup(lightsArray);
  }
  __name(setupLights, "setupLights");
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  __name(setupLightsView, "setupLightsView");
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
__name(WebGLRenderState, "WebGLRenderState");
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  __name(get, "get");
  function dispose() {
    renderStates = new WeakMap();
  }
  __name(dispose, "dispose");
  return {
    get,
    dispose
  };
}
__name(WebGLRenderStates, "WebGLRenderStates");
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
__name(MeshDepthMaterial, "MeshDepthMaterial");
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
__name(MeshDistanceMaterial, "MeshDistanceMaterial");
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {value: null},
      resolution: {value: new Vector2()},
      radius: {value: 4}
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i3 = 0, il = lights.length; i3 < il; i3++) {
      const light = lights[i3];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  __name(VSMPass, "VSMPass");
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }
    return material;
  }
  __name(getDepthMaterialVariant, "getDepthMaterialVariant");
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }
    return material;
  }
  __name(getDistanceMaterialVariant, "getDistanceMaterialVariant");
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  __name(getDepthMaterial, "getDepthMaterial");
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k3 = 0, kl = groups.length; k3 < kl; k3++) {
            const group = groups[k3];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      renderObject(children[i3], camera, shadowCamera, light, type);
    }
  }
  __name(renderObject, "renderObject");
}
__name(WebGLShadowMap, "WebGLShadowMap");
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r3, g3, b3, a3, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r3 *= a3;
          g3 *= a3;
          b3 *= a3;
        }
        color.set(r3, g3, b3, a3);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r3, g3, b3, a3);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  __name(ColorBuffer, "ColorBuffer");
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  __name(DepthBuffer, "DepthBuffer");
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  __name(StencilBuffer, "StencilBuffer");
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();
  function createTexture(type, target2, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i3 = 0; i3 < count; i3++) {
      gl.texImage2D(target2 + i3, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  __name(createTexture, "createTexture");
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  __name(enable, "enable");
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  __name(disable, "disable");
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  __name(useProgram, "useProgram");
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  __name(setBlending, "setBlending");
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  __name(setMaterial, "setMaterial");
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  __name(setFlipSided, "setFlipSided");
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  __name(setCullFace, "setCullFace");
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  __name(setLineWidth, "setLineWidth");
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  __name(setPolygonOffset, "setPolygonOffset");
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  __name(setScissorTest, "setScissorTest");
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  __name(activeTexture, "activeTexture");
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  __name(bindTexture, "bindTexture");
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  __name(unbindTexture, "unbindTexture");
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  __name(compressedTexImage2D, "compressedTexImage2D");
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  __name(texImage2D, "texImage2D");
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  __name(texImage3D, "texImage3D");
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  __name(scissor, "scissor");
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  __name(viewport, "viewport");
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  __name(reset, "reset");
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
__name(WebGLState, "WebGLState");
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas2(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  __name(createCanvas2, "createCanvas");
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas2(width, height);
        const canvas = needsNewCanvas ? createCanvas2(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context3 = canvas.getContext("2d");
        context3.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  __name(resizeImage, "resizeImage");
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  __name(isPowerOfTwo, "isPowerOfTwo");
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  __name(textureNeedsPowerOfTwo, "textureNeedsPowerOfTwo");
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  __name(textureNeedsGenerateMipmaps, "textureNeedsGenerateMipmaps");
  function generateMipmap(target2, texture, width, height) {
    _gl.generateMipmap(target2);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }
  __name(generateMipmap, "generateMipmap");
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  __name(getInternalFormat, "getInternalFormat");
  function filterFallback(f3) {
    if (f3 === NearestFilter || f3 === NearestMipmapNearestFilter || f3 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  __name(filterFallback, "filterFallback");
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  __name(onTextureDispose, "onTextureDispose");
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  __name(onRenderTargetDispose, "onRenderTargetDispose");
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  __name(deallocateTexture, "deallocateTexture");
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i3 = 0; i3 < 6; i3++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i3]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i3]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  __name(deallocateRenderTarget, "deallocateRenderTarget");
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  __name(resetTextureUnits, "resetTextureUnits");
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  __name(allocateTextureUnit, "allocateTextureUnit");
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  __name(setTexture2D, "setTexture2D");
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  __name(setTexture2DArray, "setTexture2DArray");
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  __name(setTexture3D, "setTexture3D");
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  __name(setTextureCube, "setTextureCube");
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  __name(setTextureParameters, "setTextureParameters");
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  __name(initTexture, "initTexture");
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i3 = 0, il = mipmaps.length; i3 < il; i3++) {
          mipmap = mipmaps[i3];
          state.texImage2D(3553, i3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i3 = 0, il = mipmaps.length; i3 < il; i3++) {
        mipmap = mipmaps[i3];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i3, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i3 = 0, il = mipmaps.length; i3 < il; i3++) {
          mipmap = mipmaps[i3];
          state.texImage2D(3553, i3, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  __name(uploadTexture, "uploadTexture");
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i3 = 0; i3 < 6; i3++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i3] = resizeImage(texture.image[i3], false, true, maxCubemapSize);
      } else {
        cubeImage[i3] = isDataTexture ? texture.image[i3].image : texture.image[i3];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i3 = 0; i3 < 6; i3++) {
        mipmaps = cubeImage[i3].mipmaps;
        for (let j3 = 0; j3 < mipmaps.length; j3++) {
          const mipmap = mipmaps[j3];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i3, j3, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i3, j3, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i3 = 0; i3 < 6; i3++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i3, 0, glInternalFormat, cubeImage[i3].width, cubeImage[i3].height, 0, glFormat, glType, cubeImage[i3].data);
          for (let j3 = 0; j3 < mipmaps.length; j3++) {
            const mipmap = mipmaps[j3];
            const mipmapImage = mipmap.image[i3].image;
            state.texImage2D(34069 + i3, j3 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i3, 0, glInternalFormat, glFormat, glType, cubeImage[i3]);
          for (let j3 = 0; j3 < mipmaps.length; j3++) {
            const mipmap = mipmaps[j3];
            state.texImage2D(34069 + i3, j3 + 1, glInternalFormat, glFormat, glType, mipmap.image[i3]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  __name(uploadCubeTexture, "uploadCubeTexture");
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const texture = renderTarget.texture;
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    _gl.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    _gl.bindFramebuffer(36160, null);
  }
  __name(setupFrameBufferTexture, "setupFrameBufferTexture");
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  __name(setupRenderBufferStorage, "setupRenderBufferStorage");
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  __name(setupDepthTexture, "setupDepthTexture");
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i3 = 0; i3 < 6; i3++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i3]);
          renderTargetProperties.__webglDepthbuffer[i3] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i3], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    _gl.bindFramebuffer(36160, null);
  }
  __name(setupDepthRenderbuffer, "setupDepthRenderbuffer");
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i3 = 0; i3 < 6; i3++) {
        renderTargetProperties.__webglFramebuffer[i3] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i3 = 0; i3 < 6; i3++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i3], renderTarget, 36064, 34069 + i3);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  __name(setupRenderTarget, "setupRenderTarget");
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target2 = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target2, webglTexture);
      generateMipmap(target2, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target2, null);
    }
  }
  __name(updateRenderTargetMipmap, "updateRenderTargetMipmap");
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  __name(updateMultisampleRenderTarget, "updateMultisampleRenderTarget");
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  __name(getRenderTargetSamples, "getRenderTargetSamples");
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  __name(updateVideoTexture, "updateVideoTexture");
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  __name(safeSetTexture2D, "safeSetTexture2D");
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  __name(safeSetTextureCube, "safeSetTextureCube");
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
__name(WebGLTextures, "WebGLTextures");
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p3) {
    let extension;
    if (p3 === UnsignedByteType)
      return 5121;
    if (p3 === UnsignedShort4444Type)
      return 32819;
    if (p3 === UnsignedShort5551Type)
      return 32820;
    if (p3 === UnsignedShort565Type)
      return 33635;
    if (p3 === ByteType)
      return 5120;
    if (p3 === ShortType)
      return 5122;
    if (p3 === UnsignedShortType)
      return 5123;
    if (p3 === IntType)
      return 5124;
    if (p3 === UnsignedIntType)
      return 5125;
    if (p3 === FloatType)
      return 5126;
    if (p3 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p3 === AlphaFormat)
      return 6406;
    if (p3 === RGBFormat)
      return 6407;
    if (p3 === RGBAFormat)
      return 6408;
    if (p3 === LuminanceFormat)
      return 6409;
    if (p3 === LuminanceAlphaFormat)
      return 6410;
    if (p3 === DepthFormat)
      return 6402;
    if (p3 === DepthStencilFormat)
      return 34041;
    if (p3 === RedFormat)
      return 6403;
    if (p3 === RedIntegerFormat)
      return 36244;
    if (p3 === RGFormat)
      return 33319;
    if (p3 === RGIntegerFormat)
      return 33320;
    if (p3 === RGBIntegerFormat)
      return 36248;
    if (p3 === RGBAIntegerFormat)
      return 36249;
    if (p3 === RGB_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT1_Format || p3 === RGBA_S3TC_DXT3_Format || p3 === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p3 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p3 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p3 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p3 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p3 === RGB_PVRTC_4BPPV1_Format || p3 === RGB_PVRTC_2BPPV1_Format || p3 === RGBA_PVRTC_4BPPV1_Format || p3 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p3 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p3 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p3 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p3 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p3 === RGB_ETC2_Format || p3 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p3 === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p3 === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p3 === RGBA_ASTC_4x4_Format || p3 === RGBA_ASTC_5x4_Format || p3 === RGBA_ASTC_5x5_Format || p3 === RGBA_ASTC_6x5_Format || p3 === RGBA_ASTC_6x6_Format || p3 === RGBA_ASTC_8x5_Format || p3 === RGBA_ASTC_8x6_Format || p3 === RGBA_ASTC_8x8_Format || p3 === RGBA_ASTC_10x5_Format || p3 === RGBA_ASTC_10x6_Format || p3 === RGBA_ASTC_10x8_Format || p3 === RGBA_ASTC_10x10_Format || p3 === RGBA_ASTC_12x10_Format || p3 === RGBA_ASTC_12x12_Format || p3 === SRGB8_ALPHA8_ASTC_4x4_Format || p3 === SRGB8_ALPHA8_ASTC_5x4_Format || p3 === SRGB8_ALPHA8_ASTC_5x5_Format || p3 === SRGB8_ALPHA8_ASTC_6x5_Format || p3 === SRGB8_ALPHA8_ASTC_6x6_Format || p3 === SRGB8_ALPHA8_ASTC_8x5_Format || p3 === SRGB8_ALPHA8_ASTC_8x6_Format || p3 === SRGB8_ALPHA8_ASTC_8x8_Format || p3 === SRGB8_ALPHA8_ASTC_10x5_Format || p3 === SRGB8_ALPHA8_ASTC_10x6_Format || p3 === SRGB8_ALPHA8_ASTC_10x8_Format || p3 === SRGB8_ALPHA8_ASTC_10x10_Format || p3 === SRGB8_ALPHA8_ASTC_12x10_Format || p3 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p3;
      } else {
        return null;
      }
    }
    if (p3 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p3;
      } else {
        return null;
      }
    }
    if (p3 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  __name(convert, "convert");
  return {convert};
}
__name(WebGLUtils, "WebGLUtils");
function ArrayCamera(array = []) {
  PerspectiveCamera.call(this);
  this.cameras = array;
}
__name(ArrayCamera, "ArrayCamera");
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
var Group = class extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
};
__name(Group, "Group");
Group.prototype.isGroup = true;
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
__name(WebXRController, "WebXRController");
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {pinching: false};
    }
    return this._hand;
  },
  getTargetRaySpace: function() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function(inputSource) {
    this.dispatchEvent({type: "disconnected", data: inputSource});
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          }
        }
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({type: event.type, data: event.inputSource});
    }
  }
  __name(onSessionEvent, "onSessionEvent");
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;
    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({type: "sessionend"});
  }
  __name(onSessionEnd, "onSessionEnd");
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = async function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.addEventListener("inputsourceschange", onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({baseLayer});
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;
    for (let i3 = 0; i3 < controllers.length; i3++) {
      inputSourcesMap.set(inputSources[i3], controllers[i3]);
    }
    for (let i3 = 0; i3 < event.removed.length; i3++) {
      const inputSource = event.removed[i3];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "disconnected", data: inputSource});
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i3 = 0; i3 < event.added.length; i3++) {
      const inputSource = event.added[i3];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "connected", data: inputSource});
      }
    }
  }
  __name(onInputSourcesChange, "onInputSourcesChange");
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  __name(setProjectionFromUnion, "setProjectionFromUnion");
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  }
  __name(updateCamera, "updateCamera");
  this.getCamera = function(camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i3 = 0; i3 < cameras2.length; i3++) {
      updateCamera(cameras2[i3], parent);
    }
    camera.matrixWorld.copy(cameraVR.matrixWorld);
    camera.matrix.copy(cameraVR.matrix);
    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
    const children = camera.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      children[i3].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i3 = 0; i3 < views.length; i3++) {
        const view = views[i3];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i3];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i3 === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i3 = 0; i3 < controllers.length; i3++) {
      const controller = controllers[i3];
      const inputSource = inputSources[i3];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time, frame);
  }
  __name(onAnimationFrame, "onAnimationFrame");
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
__name(WebXRManager, "WebXRManager");
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  __name(refreshFogUniforms, "refreshFogUniforms");
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  __name(refreshMaterialUniforms, "refreshMaterialUniforms");
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  __name(refreshUniformsCommon, "refreshUniformsCommon");
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  __name(refreshUniformsLine, "refreshUniformsLine");
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  __name(refreshUniformsDash, "refreshUniformsDash");
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  __name(refreshUniformsPoints, "refreshUniformsPoints");
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  __name(refreshUniformsSprites, "refreshUniformsSprites");
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  __name(refreshUniformsLambert, "refreshUniformsLambert");
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  __name(refreshUniformsPhong, "refreshUniformsPhong");
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  __name(refreshUniformsToon, "refreshUniformsToon");
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  __name(refreshUniformsStandard, "refreshUniformsStandard");
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  __name(refreshUniformsPhysical, "refreshUniformsPhysical");
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  __name(refreshUniformsMatcap, "refreshUniformsMatcap");
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  __name(refreshUniformsDepth, "refreshUniformsDepth");
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  __name(refreshUniformsDistance, "refreshUniformsDistance");
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  __name(refreshUniformsNormal, "refreshUniformsNormal");
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
__name(WebGLMaterials, "WebGLMaterials");
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
__name(createCanvasElement, "createCanvasElement");
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  const _this = this;
  let _isContextLost = false;
  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  __name(getTargetPixelRatio, "getTargetPixelRatio");
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i3 = 0; i3 < contextNames.length; i3++) {
      const contextName = contextNames[i3];
      const context3 = _canvas2.getContext(contextName, contextAttributes);
      if (context3 !== null)
        return context3;
    }
    return null;
  }
  __name(getContext, "getContext");
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  __name(initGLContext, "initGLContext");
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target2) {
    if (target2 === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target2 = new Vector2();
    }
    return target2.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target2) {
    if (target2 === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target2 = new Vector2();
    }
    return target2.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target2) {
    if (target2 === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target2 = new Vector4();
    }
    return target2.copy(_currentViewport);
  };
  this.getViewport = function(target2) {
    return target2.copy(_viewport);
  };
  this.setViewport = function(x3, y3, width, height) {
    if (x3.isVector4) {
      _viewport.set(x3.x, x3.y, x3.z, x3.w);
    } else {
      _viewport.set(x3, y3, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target2) {
    return target2.copy(_scissor);
  };
  this.setScissor = function(x3, y3, width, height) {
    if (x3.isVector4) {
      _scissor.set(x3.x, x3.y, x3.z, x3.w);
    } else {
      _scissor.set(x3, y3, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target2) {
    if (target2 === void 0) {
      console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
      target2 = new Color();
    }
    return target2.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  __name(onContextLost, "onContextLost");
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  __name(onContextRestore, "onContextRestore");
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  __name(onMaterialDispose, "onMaterialDispose");
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  __name(deallocateMaterial, "deallocateMaterial");
  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  __name(releaseMaterialProgramReference, "releaseMaterialProgramReference");
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  __name(renderObjectImmediate, "renderObjectImmediate");
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    const compiled = new WeakMap();
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i3 = 0; i3 < material.length; i3++) {
            const material2 = material[i3];
            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (xr.isPresenting)
      return;
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  __name(onAnimationFrame, "onAnimationFrame");
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  this.render = function(scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i3 = 0, l3 = groups.length; i3 < l3; i3++) {
              const group = groups[i3];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      projectObject(children[i3], camera, groupOrder, sortObjects);
    }
  }
  __name(projectObject, "projectObject");
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i3 = 0, l3 = renderList.length; i3 < l3; i3++) {
      const renderItem = renderList[i3];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j3 = 0, jl = cameras.length; j3 < jl; j3++) {
          const camera2 = cameras[j3];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  __name(renderObjects, "renderObjects");
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  __name(renderObject, "renderObject");
  function initMaterial(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let program = materialProperties.program;
    let programChange = true;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters2.uniforms;
      materialProperties.outputEncoding = parameters2.outputEncoding;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = clipping.numPlanes;
      materialProperties.numIntersection = clipping.numIntersection;
      uniforms.clippingPlanes = clipping.uniform;
    }
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = materialProperties.program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  __name(initMaterial, "initMaterial");
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    if (material.version === materialProperties.__version) {
      if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      } else if (materialProperties.envMap !== envMap) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  __name(setProgram, "setProgram");
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  __name(markUniformsLightsNeedsUpdate, "markUniformsLightsNeedsUpdate");
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  __name(materialNeedsLights, "materialNeedsLights");
  this.setFramebuffer = function(value) {
    if (_framebuffer !== value && _currentRenderTarget === null)
      _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = _framebuffer;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x3, y3, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      let restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        restore = true;
      }
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x3 >= 0 && x3 <= renderTarget.width - width && (y3 >= 0 && y3 <= renderTarget.height - height)) {
            _gl.readPixels(x3, y3, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const {width, height, data} = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    _gl.pixelStorei(3314, width);
    _gl.pixelStorei(32878, height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
  }
}
__name(WebGLRenderer, "WebGLRenderer");
var WebGL1Renderer = class extends WebGLRenderer {
};
__name(WebGL1Renderer, "WebGL1Renderer");
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class {
  constructor(color, density) {
    this.name = "";
    this.color = new Color(color);
    this.density = density !== void 0 ? density : 25e-5;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
__name(FogExp2, "FogExp2");
FogExp2.prototype.isFogExp2 = true;
var Fog = class {
  constructor(color, near, far) {
    this.name = "";
    this.color = new Color(color);
    this.near = near !== void 0 ? near : 1;
    this.far = far !== void 0 ? far : 1e3;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
__name(Fog, "Fog");
Fog.prototype.isFog = true;
var Scene = class extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null)
      data.object.background = this.background.toJSON(meta);
    if (this.environment !== null)
      data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
};
__name(Scene, "Scene");
Scene.prototype.isScene = true;
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
__name(InterleavedBuffer, "InterleavedBuffer");
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i3 = 0, l3 = this.stride; i3 < l3; i3++) {
      this.array[index1 + i3] = attribute.array[index2 + i3];
    }
    return this;
  },
  set: function(value, offset3 = 0) {
    this.array.set(value, offset3);
    return this;
  },
  clone: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
var _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset3, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset3;
  this.normalized = normalized === true;
}
__name(InterleavedBufferAttribute, "InterleavedBufferAttribute");
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function(m3) {
    for (let i3 = 0, l3 = this.data.count; i3 < l3; i3++) {
      _vector$6.x = this.getX(i3);
      _vector$6.y = this.getY(i3);
      _vector$6.z = this.getZ(i3);
      _vector$6.applyMatrix4(m3);
      this.setXYZ(i3, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function(index, x3) {
    this.data.array[index * this.data.stride + this.offset] = x3;
    return this;
  },
  setY: function(index, y3) {
    this.data.array[index * this.data.stride + this.offset + 1] = y3;
    return this;
  },
  setZ: function(index, z2) {
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  },
  setW: function(index, w3) {
    this.data.array[index * this.data.stride + this.offset + 3] = w3;
    return this;
  },
  getX: function(index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function(index, x3, y3) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x3;
    this.data.array[index + 1] = y3;
    return this;
  },
  setXYZ: function(index, x3, y3, z2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x3;
    this.data.array[index + 1] = y3;
    this.data.array[index + 2] = z2;
    return this;
  },
  setXYZW: function(index, x3, y3, z2, w3) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x3;
    this.data.array[index + 1] = y3;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w3;
    return this;
  },
  clone: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i3 = 0; i3 < this.count; i3++) {
        const index = i3 * this.data.stride + this.offset;
        for (let j3 = 0; j3 < this.itemSize; j3++) {
          array.push(this.data.array[index + j3]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i3 = 0; i3 < this.count; i3++) {
        const index = i3 * this.data.stride + this.offset;
        for (let j3 = 0; j3 < this.itemSize; j3++) {
          array.push(this.data.array[index + j3]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
};
__name(SpriteMaterial, "SpriteMaterial");
SpriteMaterial.prototype.isSpriteMaterial = true;
var _geometry;
var _intersectPoint = /* @__PURE__ */ new Vector3();
var _worldScale = /* @__PURE__ */ new Vector3();
var _mvPosition = /* @__PURE__ */ new Vector3();
var _alignedPosition = /* @__PURE__ */ new Vector2();
var _rotatedPosition = /* @__PURE__ */ new Vector2();
var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _uvA$1 = /* @__PURE__ */ new Vector2();
var _uvB$1 = /* @__PURE__ */ new Vector2();
var _uvC$1 = /* @__PURE__ */ new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center2 = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
    _uvA$1.set(0, 0);
    _uvB$1.set(1, 0);
    _uvC$1.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center2, _worldScale, sin, cos);
      _uvB$1.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
__name(Sprite, "Sprite");
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center2, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center2).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
__name(transformVertex, "transformVertex");
var _v1$4 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var LOD = class extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i3 = 0, l3 = levels.length; i3 < l3; i3++) {
      const level = levels[i3];
      this.addLevel(level.object.clone(), level.distance);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l3;
    for (l3 = 0; l3 < levels.length; l3++) {
      if (distance < levels[l3].distance) {
        break;
      }
    }
    levels.splice(l3, 0, {distance, object});
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i3, l3;
      for (i3 = 1, l3 = levels.length; i3 < l3; i3++) {
        if (distance < levels[i3].distance) {
          break;
        }
      }
      return levels[i3 - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);
      _v2$2.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
      levels[0].object.visible = true;
      let i3, l3;
      for (i3 = 1, l3 = levels.length; i3 < l3; i3++) {
        if (distance >= levels[i3].distance) {
          levels[i3 - 1].object.visible = false;
          levels[i3].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i3 - 1;
      for (; i3 < l3; i3++) {
        levels[i3].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false)
      data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i3 = 0, l3 = levels.length; i3 < l3; i3++) {
      const level = levels[i3];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
};
__name(LOD, "LOD");
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector$7 = new Vector3();
var _matrix$1 = new Matrix4();
function SkinnedMesh(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
__name(SkinnedMesh, "SkinnedMesh");
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i3 = 0, l3 = skinWeight.count; i3 < l3; i3++) {
      vector.x = skinWeight.getX(i3);
      vector.y = skinWeight.getY(i3);
      vector.z = skinWeight.getZ(i3);
      vector.w = skinWeight.getW(i3);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i3, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  boneTransform: function(index, target2) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
    target2.set(0, 0, 0);
    for (let i3 = 0; i3 < 4; i3++) {
      const weight = _skinWeight.getComponent(i3);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i3);
        _matrix$1.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target2.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), weight);
      }
    }
    return target2.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
__name(Bone, "Bone");
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
var _offsetMatrix = /* @__PURE__ */ new Matrix4();
var _identityMatrix = /* @__PURE__ */ new Matrix4();
var Skeleton = class {
  constructor(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i3 = 0, il = this.bones.length; i3 < il; i3++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i3 = 0, il = this.bones.length; i3 < il; i3++) {
      const inverse = new Matrix4();
      if (this.bones[i3]) {
        inverse.copy(this.bones[i3].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i3 = 0, il = this.bones.length; i3 < il; i3++) {
      const bone = this.bones[i3];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i3]).invert();
      }
    }
    for (let i3 = 0, il = this.bones.length; i3 < il; i3++) {
      const bone = this.bones[i3];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i3 = 0, il = bones.length; i3 < il; i3++) {
      const matrix = bones[i3] ? bones[i3].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i3]);
      _offsetMatrix.toArray(boneMatrices, i3 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  getBoneByName(name) {
    for (let i3 = 0, il = this.bones.length; i3 < il; i3++) {
      const bone = this.bones[i3];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i3 = 0, l3 = json.bones.length; i3 < l3; i3++) {
      const uuid = json.bones[i3];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i3]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i3 = 0, l3 = bones.length; i3 < l3; i3++) {
      const bone = bones[i3];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i3];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
};
__name(Skeleton, "Skeleton");
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
__name(InstancedMesh, "InstancedMesh");
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  },
  getMatrixAt: function(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i3 = 0, l3 = _instanceIntersects.length; i3 < l3; i3++) {
        const intersect = _instanceIntersects[i3];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  },
  setMatrixAt: function(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
__name(LineBasicMaterial, "LineBasicMaterial");
LineBasicMaterial.prototype.isLineBasicMaterial = true;
var _start = new Vector3();
var _end = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$2 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
__name(Line, "Line");
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i3 = 1, l3 = positionAttribute.count; i3 < l3; i3++) {
          _start.fromBufferAttribute(positionAttribute, i3 - 1);
          _end.fromBufferAttribute(positionAttribute, i3);
          lineDistances[i3] = lineDistances[i3 - 1];
          lineDistances[i3] += _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const indices = index.array;
        for (let i3 = 0, l3 = indices.length - 1; i3 < l3; i3 += step) {
          const a3 = indices[i3];
          const b3 = indices[i3 + 1];
          vStart.fromBufferAttribute(positionAttribute, a3);
          vEnd.fromBufferAttribute(positionAttribute, b3);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i3,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i3 = 0, l3 = positionAttribute.count - 1; i3 < l3; i3 += step) {
          vStart.fromBufferAttribute(positionAttribute, i3);
          vEnd.fromBufferAttribute(positionAttribute, i3 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i3,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m3 = 0, ml = morphAttribute.length; m3 < ml; m3++) {
            const name = morphAttribute[m3].name || String(m3);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m3;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
var _start$1 = new Vector3();
var _end$1 = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
__name(LineSegments, "LineSegments");
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i3 = 0, l3 = positionAttribute.count; i3 < l3; i3 += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i3);
          _end$1.fromBufferAttribute(positionAttribute, i3 + 1);
          lineDistances[i3] = i3 === 0 ? 0 : lineDistances[i3 - 1];
          lineDistances[i3 + 1] = lineDistances[i3] + _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
});
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
};
__name(LineLoop, "LineLoop");
LineLoop.prototype.isLineLoop = true;
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }
};
__name(PointsMaterial, "PointsMaterial");
PointsMaterial.prototype.isPointsMaterial = true;
var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var _sphere$3 = new Sphere();
var _position$1 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
__name(Points, "Points");
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const indices = index.array;
        for (let i3 = 0, il = indices.length; i3 < il; i3++) {
          const a3 = indices[i3];
          _position$1.fromBufferAttribute(positionAttribute, a3);
          testPoint(_position$1, a3, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        for (let i3 = 0, l3 = positionAttribute.count; i3 < l3; i3++) {
          _position$1.fromBufferAttribute(positionAttribute, i3);
          testPoint(_position$1, i3, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m3 = 0, ml = morphAttribute.length; m3 < ml; m3++) {
            const name = morphAttribute[m3].name || String(m3);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m3;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray$2.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
__name(testPoint, "testPoint");
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    __name(updateVideo, "updateVideo");
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
__name(VideoTexture, "VideoTexture");
VideoTexture.prototype.isVideoTexture = true;
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
__name(CompressedTexture, "CompressedTexture");
CompressedTexture.prototype.isCompressedTexture = true;
var CanvasTexture = class extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
};
__name(CanvasTexture, "CanvasTexture");
CanvasTexture.prototype.isCanvasTexture = true;
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {width, height};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
__name(DepthTexture, "DepthTexture");
DepthTexture.prototype.isDepthTexture = true;
var CylinderGeometry = class extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y3 = 0; y3 <= heightSegments; y3++) {
        const indexRow = [];
        const v3 = y3 / heightSegments;
        const radius = v3 * (radiusBottom - radiusTop) + radiusTop;
        for (let x3 = 0; x3 <= radialSegments; x3++) {
          const u3 = x3 / radialSegments;
          const theta = u3 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v3 * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u3, 1 - v3);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        for (let y3 = 0; y3 < heightSegments; y3++) {
          const a3 = indexArray[y3][x3];
          const b3 = indexArray[y3 + 1][x3];
          const c3 = indexArray[y3 + 1][x3 + 1];
          const d3 = indexArray[y3][x3 + 1];
          indices.push(a3, b3, d3);
          indices.push(b3, c3, d3);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    __name(generateTorso, "generateTorso");
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x3 = 1; x3 <= radialSegments; x3++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x3 = 0; x3 <= radialSegments; x3++) {
        const u3 = x3 / radialSegments;
        const theta = u3 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign2;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        const c3 = centerIndexStart + x3;
        const i3 = centerIndexEnd + x3;
        if (top === true) {
          indices.push(i3, i3 + 1, c3);
        } else {
          indices.push(i3 + 1, i3, c3);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
    __name(generateCap, "generateCap");
  }
};
__name(CylinderGeometry, "CylinderGeometry");
var ConeGeometry = class extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
};
__name(ConeGeometry, "ConeGeometry");
var PolyhedronGeometry = class extends BufferGeometry {
  constructor(vertices, indices, radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a3 = new Vector3();
      const b3 = new Vector3();
      const c3 = new Vector3();
      for (let i3 = 0; i3 < indices.length; i3 += 3) {
        getVertexByIndex(indices[i3 + 0], a3);
        getVertexByIndex(indices[i3 + 1], b3);
        getVertexByIndex(indices[i3 + 2], c3);
        subdivideFace(a3, b3, c3, detail2);
      }
    }
    __name(subdivide, "subdivide");
    function subdivideFace(a3, b3, c3, detail2) {
      const cols = detail2 + 1;
      const v3 = [];
      for (let i3 = 0; i3 <= cols; i3++) {
        v3[i3] = [];
        const aj = a3.clone().lerp(c3, i3 / cols);
        const bj = b3.clone().lerp(c3, i3 / cols);
        const rows = cols - i3;
        for (let j3 = 0; j3 <= rows; j3++) {
          if (j3 === 0 && i3 === cols) {
            v3[i3][j3] = aj;
          } else {
            v3[i3][j3] = aj.clone().lerp(bj, j3 / rows);
          }
        }
      }
      for (let i3 = 0; i3 < cols; i3++) {
        for (let j3 = 0; j3 < 2 * (cols - i3) - 1; j3++) {
          const k3 = Math.floor(j3 / 2);
          if (j3 % 2 === 0) {
            pushVertex(v3[i3][k3 + 1]);
            pushVertex(v3[i3 + 1][k3]);
            pushVertex(v3[i3][k3]);
          } else {
            pushVertex(v3[i3][k3 + 1]);
            pushVertex(v3[i3 + 1][k3 + 1]);
            pushVertex(v3[i3 + 1][k3]);
          }
        }
      }
    }
    __name(subdivideFace, "subdivideFace");
    function applyRadius(radius2) {
      const vertex = new Vector3();
      for (let i3 = 0; i3 < vertexBuffer.length; i3 += 3) {
        vertex.x = vertexBuffer[i3 + 0];
        vertex.y = vertexBuffer[i3 + 1];
        vertex.z = vertexBuffer[i3 + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i3 + 0] = vertex.x;
        vertexBuffer[i3 + 1] = vertex.y;
        vertexBuffer[i3 + 2] = vertex.z;
      }
    }
    __name(applyRadius, "applyRadius");
    function generateUVs() {
      const vertex = new Vector3();
      for (let i3 = 0; i3 < vertexBuffer.length; i3 += 3) {
        vertex.x = vertexBuffer[i3 + 0];
        vertex.y = vertexBuffer[i3 + 1];
        vertex.z = vertexBuffer[i3 + 2];
        const u3 = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v3 = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u3, 1 - v3);
      }
      correctUVs();
      correctSeam();
    }
    __name(generateUVs, "generateUVs");
    function correctSeam() {
      for (let i3 = 0; i3 < uvBuffer.length; i3 += 6) {
        const x0 = uvBuffer[i3 + 0];
        const x1 = uvBuffer[i3 + 2];
        const x22 = uvBuffer[i3 + 4];
        const max = Math.max(x0, x1, x22);
        const min = Math.min(x0, x1, x22);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i3 + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i3 + 2] += 1;
          if (x22 < 0.2)
            uvBuffer[i3 + 4] += 1;
        }
      }
    }
    __name(correctSeam, "correctSeam");
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    __name(pushVertex, "pushVertex");
    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    __name(getVertexByIndex, "getVertexByIndex");
    function correctUVs() {
      const a3 = new Vector3();
      const b3 = new Vector3();
      const c3 = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i3 = 0, j3 = 0; i3 < vertexBuffer.length; i3 += 9, j3 += 6) {
        a3.set(vertexBuffer[i3 + 0], vertexBuffer[i3 + 1], vertexBuffer[i3 + 2]);
        b3.set(vertexBuffer[i3 + 3], vertexBuffer[i3 + 4], vertexBuffer[i3 + 5]);
        c3.set(vertexBuffer[i3 + 6], vertexBuffer[i3 + 7], vertexBuffer[i3 + 8]);
        uvA.set(uvBuffer[j3 + 0], uvBuffer[j3 + 1]);
        uvB.set(uvBuffer[j3 + 2], uvBuffer[j3 + 3]);
        uvC.set(uvBuffer[j3 + 4], uvBuffer[j3 + 5]);
        centroid.copy(a3).add(b3).add(c3).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j3 + 0, a3, azi);
        correctUV(uvB, j3 + 2, b3, azi);
        correctUV(uvC, j3 + 4, c3, azi);
      }
    }
    __name(correctUVs, "correctUVs");
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    __name(correctUV, "correctUV");
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    __name(azimuth, "azimuth");
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
    __name(inclination, "inclination");
  }
};
__name(PolyhedronGeometry, "PolyhedronGeometry");
var DodecahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t3 = (1 + Math.sqrt(5)) / 2;
    const r3 = 1 / t3;
    const vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r3,
      -t3,
      0,
      -r3,
      t3,
      0,
      r3,
      -t3,
      0,
      r3,
      t3,
      -r3,
      -t3,
      0,
      -r3,
      t3,
      0,
      r3,
      -t3,
      0,
      r3,
      t3,
      0,
      -t3,
      0,
      -r3,
      t3,
      0,
      -r3,
      -t3,
      0,
      r3,
      t3,
      0,
      r3
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
__name(DodecahedronGeometry, "DodecahedronGeometry");
var _v0$2 = new Vector3();
var _v1$5 = new Vector3();
var _normal$1 = new Vector3();
var _triangle = new Triangle();
var Earcut = {
  triangulate: function(data, holeIndices, dim) {
    dim = dim || 2;
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x3, y3, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i3 = dim; i3 < outerLen; i3 += dim) {
        x3 = data[i3];
        y3 = data[i3 + 1];
        if (x3 < minX)
          minX = x3;
        if (y3 < minY)
          minY = y3;
        if (x3 > maxX)
          maxX = x3;
        if (y3 > maxY)
          maxY = y3;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i3, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i3 = start; i3 < end; i3 += dim)
      last = insertNode(i3, data[i3], data[i3 + 1], last);
  } else {
    for (i3 = end - dim; i3 >= start; i3 -= dim)
      last = insertNode(i3, data[i3], data[i3 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
__name(linkedList, "linkedList");
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p3 = start, again;
  do {
    again = false;
    if (!p3.steiner && (equals(p3, p3.next) || area(p3.prev, p3, p3.next) === 0)) {
      removeNode(p3);
      p3 = end = p3.prev;
      if (p3 === p3.next)
        break;
      again = true;
    } else {
      p3 = p3.next;
    }
  } while (again || p3 !== end);
  return end;
}
__name(filterPoints, "filterPoints");
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
__name(earcutLinked, "earcutLinked");
function isEar(ear) {
  const a3 = ear.prev, b3 = ear, c3 = ear.next;
  if (area(a3, b3, c3) >= 0)
    return false;
  let p3 = ear.next.next;
  while (p3 !== ear.prev) {
    if (pointInTriangle(a3.x, a3.y, b3.x, b3.y, c3.x, c3.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
      return false;
    p3 = p3.next;
  }
  return true;
}
__name(isEar, "isEar");
function isEarHashed(ear, minX, minY, invSize) {
  const a3 = ear.prev, b3 = ear, c3 = ear.next;
  if (area(a3, b3, c3) >= 0)
    return false;
  const minTX = a3.x < b3.x ? a3.x < c3.x ? a3.x : c3.x : b3.x < c3.x ? b3.x : c3.x, minTY = a3.y < b3.y ? a3.y < c3.y ? a3.y : c3.y : b3.y < c3.y ? b3.y : c3.y, maxTX = a3.x > b3.x ? a3.x > c3.x ? a3.x : c3.x : b3.x > c3.x ? b3.x : c3.x, maxTY = a3.y > b3.y ? a3.y > c3.y ? a3.y : c3.y : b3.y > c3.y ? b3.y : c3.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p3 = ear.prevZ, n2 = ear.nextZ;
  while (p3 && p3.z >= minZ && n2 && n2.z <= maxZ) {
    if (p3 !== ear.prev && p3 !== ear.next && pointInTriangle(a3.x, a3.y, b3.x, b3.y, c3.x, c3.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
      return false;
    p3 = p3.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a3.x, a3.y, b3.x, b3.y, c3.x, c3.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p3 && p3.z >= minZ) {
    if (p3 !== ear.prev && p3 !== ear.next && pointInTriangle(a3.x, a3.y, b3.x, b3.y, c3.x, c3.y, p3.x, p3.y) && area(p3.prev, p3, p3.next) >= 0)
      return false;
    p3 = p3.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a3.x, a3.y, b3.x, b3.y, c3.x, c3.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
__name(isEarHashed, "isEarHashed");
function cureLocalIntersections(start, triangles, dim) {
  let p3 = start;
  do {
    const a3 = p3.prev, b3 = p3.next.next;
    if (!equals(a3, b3) && intersects(a3, p3, p3.next, b3) && locallyInside(a3, b3) && locallyInside(b3, a3)) {
      triangles.push(a3.i / dim);
      triangles.push(p3.i / dim);
      triangles.push(b3.i / dim);
      removeNode(p3);
      removeNode(p3.next);
      p3 = start = b3;
    }
    p3 = p3.next;
  } while (p3 !== start);
  return filterPoints(p3);
}
__name(cureLocalIntersections, "cureLocalIntersections");
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a3 = start;
  do {
    let b3 = a3.next.next;
    while (b3 !== a3.prev) {
      if (a3.i !== b3.i && isValidDiagonal(a3, b3)) {
        let c3 = splitPolygon(a3, b3);
        a3 = filterPoints(a3, a3.next);
        c3 = filterPoints(c3, c3.next);
        earcutLinked(a3, triangles, dim, minX, minY, invSize);
        earcutLinked(c3, triangles, dim, minX, minY, invSize);
        return;
      }
      b3 = b3.next;
    }
    a3 = a3.next;
  } while (a3 !== start);
}
__name(splitEarcut, "splitEarcut");
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i3, len, start, end, list;
  for (i3 = 0, len = holeIndices.length; i3 < len; i3++) {
    start = holeIndices[i3] * dim;
    end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i3 = 0; i3 < queue.length; i3++) {
    eliminateHole(queue[i3], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
__name(eliminateHoles, "eliminateHoles");
function compareX(a3, b3) {
  return a3.x - b3.x;
}
__name(compareX, "compareX");
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b3 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b3, b3.next);
  }
}
__name(eliminateHole, "eliminateHole");
function findHoleBridge(hole, outerNode) {
  let p3 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m3;
  do {
    if (hy <= p3.y && hy >= p3.next.y && p3.next.y !== p3.y) {
      const x3 = p3.x + (hy - p3.y) * (p3.next.x - p3.x) / (p3.next.y - p3.y);
      if (x3 <= hx && x3 > qx) {
        qx = x3;
        if (x3 === hx) {
          if (hy === p3.y)
            return p3;
          if (hy === p3.next.y)
            return p3.next;
        }
        m3 = p3.x < p3.next.x ? p3 : p3.next;
      }
    }
    p3 = p3.next;
  } while (p3 !== outerNode);
  if (!m3)
    return null;
  if (hx === qx)
    return m3;
  const stop = m3, mx = m3.x, my = m3.y;
  let tanMin = Infinity, tan;
  p3 = m3;
  do {
    if (hx >= p3.x && p3.x >= mx && hx !== p3.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p3.x, p3.y)) {
      tan = Math.abs(hy - p3.y) / (hx - p3.x);
      if (locallyInside(p3, hole) && (tan < tanMin || tan === tanMin && (p3.x > m3.x || p3.x === m3.x && sectorContainsSector(m3, p3)))) {
        m3 = p3;
        tanMin = tan;
      }
    }
    p3 = p3.next;
  } while (p3 !== stop);
  return m3;
}
__name(findHoleBridge, "findHoleBridge");
function sectorContainsSector(m3, p3) {
  return area(m3.prev, m3, p3.prev) < 0 && area(p3.next, m3, m3.next) < 0;
}
__name(sectorContainsSector, "sectorContainsSector");
function indexCurve(start, minX, minY, invSize) {
  let p3 = start;
  do {
    if (p3.z === null)
      p3.z = zOrder(p3.x, p3.y, minX, minY, invSize);
    p3.prevZ = p3.prev;
    p3.nextZ = p3.next;
    p3 = p3.next;
  } while (p3 !== start);
  p3.prevZ.nextZ = null;
  p3.prevZ = null;
  sortLinked(p3);
}
__name(indexCurve, "indexCurve");
function sortLinked(list) {
  let i3, p3, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p3 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p3) {
      numMerges++;
      q2 = p3;
      pSize = 0;
      for (i3 = 0; i3 < inSize; i3++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p3.z <= q2.z)) {
          e3 = p3;
          p3 = p3.nextZ;
          pSize--;
        } else {
          e3 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e3;
        else
          list = e3;
        e3.prevZ = tail;
        tail = e3;
      }
      p3 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
__name(sortLinked, "sortLinked");
function zOrder(x3, y3, minX, minY, invSize) {
  x3 = 32767 * (x3 - minX) * invSize;
  y3 = 32767 * (y3 - minY) * invSize;
  x3 = (x3 | x3 << 8) & 16711935;
  x3 = (x3 | x3 << 4) & 252645135;
  x3 = (x3 | x3 << 2) & 858993459;
  x3 = (x3 | x3 << 1) & 1431655765;
  y3 = (y3 | y3 << 8) & 16711935;
  y3 = (y3 | y3 << 4) & 252645135;
  y3 = (y3 | y3 << 2) & 858993459;
  y3 = (y3 | y3 << 1) & 1431655765;
  return x3 | y3 << 1;
}
__name(zOrder, "zOrder");
function getLeftmost(start) {
  let p3 = start, leftmost = start;
  do {
    if (p3.x < leftmost.x || p3.x === leftmost.x && p3.y < leftmost.y)
      leftmost = p3;
    p3 = p3.next;
  } while (p3 !== start);
  return leftmost;
}
__name(getLeftmost, "getLeftmost");
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
__name(pointInTriangle, "pointInTriangle");
function isValidDiagonal(a3, b3) {
  return a3.next.i !== b3.i && a3.prev.i !== b3.i && !intersectsPolygon(a3, b3) && (locallyInside(a3, b3) && locallyInside(b3, a3) && middleInside(a3, b3) && (area(a3.prev, a3, b3.prev) || area(a3, b3.prev, b3)) || equals(a3, b3) && area(a3.prev, a3, a3.next) > 0 && area(b3.prev, b3, b3.next) > 0);
}
__name(isValidDiagonal, "isValidDiagonal");
function area(p3, q2, r3) {
  return (q2.y - p3.y) * (r3.x - q2.x) - (q2.x - p3.x) * (r3.y - q2.y);
}
__name(area, "area");
function equals(p1, p22) {
  return p1.x === p22.x && p1.y === p22.y;
}
__name(equals, "equals");
function intersects(p1, q1, p22, q2) {
  const o1 = sign(area(p1, q1, p22));
  const o22 = sign(area(p1, q1, q2));
  const o3 = sign(area(p22, q2, p1));
  const o4 = sign(area(p22, q2, q1));
  if (o1 !== o22 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p22, q1))
    return true;
  if (o22 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p22, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p22, q1, q2))
    return true;
  return false;
}
__name(intersects, "intersects");
function onSegment(p3, q2, r3) {
  return q2.x <= Math.max(p3.x, r3.x) && q2.x >= Math.min(p3.x, r3.x) && q2.y <= Math.max(p3.y, r3.y) && q2.y >= Math.min(p3.y, r3.y);
}
__name(onSegment, "onSegment");
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
__name(sign, "sign");
function intersectsPolygon(a3, b3) {
  let p3 = a3;
  do {
    if (p3.i !== a3.i && p3.next.i !== a3.i && p3.i !== b3.i && p3.next.i !== b3.i && intersects(p3, p3.next, a3, b3))
      return true;
    p3 = p3.next;
  } while (p3 !== a3);
  return false;
}
__name(intersectsPolygon, "intersectsPolygon");
function locallyInside(a3, b3) {
  return area(a3.prev, a3, a3.next) < 0 ? area(a3, b3, a3.next) >= 0 && area(a3, a3.prev, b3) >= 0 : area(a3, b3, a3.prev) < 0 || area(a3, a3.next, b3) < 0;
}
__name(locallyInside, "locallyInside");
function middleInside(a3, b3) {
  let p3 = a3, inside = false;
  const px2 = (a3.x + b3.x) / 2, py2 = (a3.y + b3.y) / 2;
  do {
    if (p3.y > py2 !== p3.next.y > py2 && p3.next.y !== p3.y && px2 < (p3.next.x - p3.x) * (py2 - p3.y) / (p3.next.y - p3.y) + p3.x)
      inside = !inside;
    p3 = p3.next;
  } while (p3 !== a3);
  return inside;
}
__name(middleInside, "middleInside");
function splitPolygon(a3, b3) {
  const a22 = new Node(a3.i, a3.x, a3.y), b22 = new Node(b3.i, b3.x, b3.y), an = a3.next, bp = b3.prev;
  a3.next = b3;
  b3.prev = a3;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
__name(splitPolygon, "splitPolygon");
function insertNode(i3, x3, y3, last) {
  const p3 = new Node(i3, x3, y3);
  if (!last) {
    p3.prev = p3;
    p3.next = p3;
  } else {
    p3.next = last.next;
    p3.prev = last;
    last.next.prev = p3;
    last.next = p3;
  }
  return p3;
}
__name(insertNode, "insertNode");
function removeNode(p3) {
  p3.next.prev = p3.prev;
  p3.prev.next = p3.next;
  if (p3.prevZ)
    p3.prevZ.nextZ = p3.nextZ;
  if (p3.nextZ)
    p3.nextZ.prevZ = p3.prevZ;
}
__name(removeNode, "removeNode");
function Node(i3, x3, y3) {
  this.i = i3;
  this.x = x3;
  this.y = y3;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
__name(Node, "Node");
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i3 = start, j3 = end - dim; i3 < end; i3 += dim) {
    sum += (data[j3] - data[i3]) * (data[i3 + 1] + data[j3 + 1]);
    j3 = i3;
  }
  return sum;
}
__name(signedArea, "signedArea");
var ShapeUtils = {
  area: function(contour) {
    const n2 = contour.length;
    let a3 = 0;
    for (let p3 = n2 - 1, q2 = 0; q2 < n2; p3 = q2++) {
      a3 += contour[p3].x * contour[q2].y - contour[q2].x * contour[p3].y;
    }
    return a3 * 0.5;
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i3 = 0; i3 < holes.length; i3++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i3].length;
      addContour(vertices, holes[i3]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i3 = 0; i3 < triangles.length; i3 += 3) {
      faces.push(triangles.slice(i3, i3 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l3 = points.length;
  if (l3 > 2 && points[l3 - 1].equals(points[0])) {
    points.pop();
  }
}
__name(removeDupEndPts, "removeDupEndPts");
function addContour(vertices, contour) {
  for (let i3 = 0; i3 < contour.length; i3++) {
    vertices.push(contour[i3].x);
    vertices.push(contour[i3].y);
  }
}
__name(addContour, "addContour");
var ExtrudeGeometry = class extends BufferGeometry {
  constructor(shapes, options) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i3 = 0, l3 = shapes.length; i3 < l3; i3++) {
      const shape = shapes[i3];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      let depth = options.depth !== void 0 ? options.depth : 100;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      if (options.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      __name(scalePt2, "scalePt2");
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      __name(getBevelVec, "getBevelVec");
      const contourMovements = [];
      for (let i3 = 0, il = contour.length, j3 = il - 1, k3 = i3 + 1; i3 < il; i3++, j3++, k3++) {
        if (j3 === il)
          j3 = 0;
        if (k3 === il)
          k3 = 0;
        contourMovements[i3] = getBevelVec(contour[i3], contour[j3], contour[k3]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i3 = 0, il = ahole.length, j3 = il - 1, k3 = i3 + 1; i3 < il; i3++, j3++, k3++) {
          if (j3 === il)
            j3 = 0;
          if (k3 === il)
            k3 = 0;
          oneHoleMovements[i3] = getBevelVec(ahole[i3], ahole[j3], ahole[k3]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b3 = 0; b3 < bevelSegments; b3++) {
        const t3 = b3 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t3 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t3 * Math.PI / 2) + bevelOffset;
        for (let i3 = 0, il = contour.length; i3 < il; i3++) {
          const vert = scalePt2(contour[i3], contourMovements[i3], bs2);
          v3(vert.x, vert.y, -z2);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i3 = 0, il = ahole.length; i3 < il; i3++) {
            const vert = scalePt2(ahole[i3], oneHoleMovements[i3], bs2);
            v3(vert.x, vert.y, -z2);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i3 = 0; i3 < vlen; i3++) {
        const vert = bevelEnabled ? scalePt2(vertices[i3], verticesMovements[i3], bs) : vertices[i3];
        if (!extrudeByPath) {
          v3(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v3(position2.x, position2.y, position2.z);
        }
      }
      for (let s3 = 1; s3 <= steps; s3++) {
        for (let i3 = 0; i3 < vlen; i3++) {
          const vert = bevelEnabled ? scalePt2(vertices[i3], verticesMovements[i3], bs) : vertices[i3];
          if (!extrudeByPath) {
            v3(vert.x, vert.y, depth / steps * s3);
          } else {
            normal.copy(splineTube.normals[s3]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s3]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s3]).add(normal).add(binormal);
            v3(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b3 = bevelSegments - 1; b3 >= 0; b3--) {
        const t3 = b3 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t3 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t3 * Math.PI / 2) + bevelOffset;
        for (let i3 = 0, il = contour.length; i3 < il; i3++) {
          const vert = scalePt2(contour[i3], contourMovements[i3], bs2);
          v3(vert.x, vert.y, depth + z2);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i3 = 0, il = ahole.length; i3 < il; i3++) {
            const vert = scalePt2(ahole[i3], oneHoleMovements[i3], bs2);
            if (!extrudeByPath) {
              v3(vert.x, vert.y, depth + z2);
            } else {
              v3(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset3 = vlen * layer;
          for (let i3 = 0; i3 < flen; i3++) {
            const face = faces[i3];
            f3(face[2] + offset3, face[1] + offset3, face[0] + offset3);
          }
          layer = steps + bevelSegments * 2;
          offset3 = vlen * layer;
          for (let i3 = 0; i3 < flen; i3++) {
            const face = faces[i3];
            f3(face[0] + offset3, face[1] + offset3, face[2] + offset3);
          }
        } else {
          for (let i3 = 0; i3 < flen; i3++) {
            const face = faces[i3];
            f3(face[2], face[1], face[0]);
          }
          for (let i3 = 0; i3 < flen; i3++) {
            const face = faces[i3];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      __name(buildLidFaces, "buildLidFaces");
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      __name(buildSideFaces, "buildSideFaces");
      function sidewalls(contour2, layeroffset) {
        let i3 = contour2.length;
        while (--i3 >= 0) {
          const j3 = i3;
          let k3 = i3 - 1;
          if (k3 < 0)
            k3 = contour2.length - 1;
          for (let s3 = 0, sl = steps + bevelSegments * 2; s3 < sl; s3++) {
            const slen1 = vlen * s3;
            const slen2 = vlen * (s3 + 1);
            const a3 = layeroffset + j3 + slen1, b3 = layeroffset + k3 + slen1, c3 = layeroffset + k3 + slen2, d3 = layeroffset + j3 + slen2;
            f4(a3, b3, c3, d3);
          }
        }
      }
      __name(sidewalls, "sidewalls");
      function v3(x3, y3, z2) {
        placeholder.push(x3);
        placeholder.push(y3);
        placeholder.push(z2);
      }
      __name(v3, "v");
      function f3(a3, b3, c3) {
        addVertex(a3);
        addVertex(b3);
        addVertex(c3);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      __name(f3, "f3");
      function f4(a3, b3, c3, d3) {
        addVertex(a3);
        addVertex(b3);
        addVertex(d3);
        addVertex(b3);
        addVertex(c3);
        addVertex(d3);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      __name(f4, "f4");
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      __name(addVertex, "addVertex");
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
      __name(addUV, "addUV");
    }
    __name(addShape, "addShape");
  }
  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }
};
__name(ExtrudeGeometry, "ExtrudeGeometry");
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i3 = 0, l3 = shapes.length; i3 < l3; i3++) {
      const shape = shapes[i3];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
__name(toJSON, "toJSON");
var LatheGeometry = class extends BufferGeometry {
  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const inverseSegments = 1 / segments;
    const vertex = new Vector3();
    const uv = new Vector2();
    for (let i3 = 0; i3 <= segments; i3++) {
      const phi = phiStart + i3 * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j3 = 0; j3 <= points.length - 1; j3++) {
        vertex.x = points[j3].x * sin;
        vertex.y = points[j3].y;
        vertex.z = points[j3].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv.x = i3 / segments;
        uv.y = j3 / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }
    for (let i3 = 0; i3 < segments; i3++) {
      for (let j3 = 0; j3 < points.length - 1; j3++) {
        const base = j3 + i3 * points.length;
        const a3 = base;
        const b3 = base + points.length;
        const c3 = base + points.length + 1;
        const d3 = base + 1;
        indices.push(a3, b3, d3);
        indices.push(b3, c3, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
      const normals = this.attributes.normal.array;
      const n1 = new Vector3();
      const n2 = new Vector3();
      const n3 = new Vector3();
      const base = segments * points.length * 3;
      for (let i3 = 0, j3 = 0; i3 < points.length; i3++, j3 += 3) {
        n1.x = normals[j3 + 0];
        n1.y = normals[j3 + 1];
        n1.z = normals[j3 + 2];
        n2.x = normals[base + j3 + 0];
        n2.y = normals[base + j3 + 1];
        n2.z = normals[base + j3 + 2];
        n3.addVectors(n1, n2).normalize();
        normals[j3 + 0] = normals[base + j3 + 0] = n3.x;
        normals[j3 + 1] = normals[base + j3 + 1] = n3.y;
        normals[j3 + 2] = normals[base + j3 + 2] = n3.z;
      }
    }
  }
};
__name(LatheGeometry, "LatheGeometry");
var OctahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
__name(OctahedronGeometry, "OctahedronGeometry");
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i3 = 0; i3 <= stacks; i3++) {
    const v3 = i3 / stacks;
    for (let j3 = 0; j3 <= slices; j3++) {
      const u3 = j3 / slices;
      func(u3, v3, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u3 - EPS >= 0) {
        func(u3 - EPS, v3, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u3 + EPS, v3, p1);
        pu.subVectors(p1, p0);
      }
      if (v3 - EPS >= 0) {
        func(u3, v3 - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u3, v3 + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u3, v3);
    }
  }
  for (let i3 = 0; i3 < stacks; i3++) {
    for (let j3 = 0; j3 < slices; j3++) {
      const a3 = i3 * sliceCount + j3;
      const b3 = i3 * sliceCount + j3 + 1;
      const c3 = (i3 + 1) * sliceCount + j3 + 1;
      const d3 = (i3 + 1) * sliceCount + j3;
      indices.push(a3, b3, d3);
      indices.push(b3, c3, d3);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
__name(ParametricGeometry, "ParametricGeometry");
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
var ShapeGeometry = class extends BufferGeometry {
  constructor(shapes, curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i3 = 0; i3 < shapes.length; i3++) {
        addShape(shapes[i3]);
        this.addGroup(groupStart, groupCount, i3);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i3 = 0, l3 = shapeHoles.length; i3 < l3; i3++) {
        const shapeHole = shapeHoles[i3];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i3] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i3 = 0, l3 = shapeHoles.length; i3 < l3; i3++) {
        const shapeHole = shapeHoles[i3];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i3 = 0, l3 = shapeVertices.length; i3 < l3; i3++) {
        const vertex = shapeVertices[i3];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (let i3 = 0, l3 = faces.length; i3 < l3; i3++) {
        const face = faces[i3];
        const a3 = face[0] + indexOffset;
        const b3 = face[1] + indexOffset;
        const c3 = face[2] + indexOffset;
        indices.push(a3, b3, c3);
        groupCount += 3;
      }
    }
    __name(addShape, "addShape");
  }
  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    const shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  }
};
__name(ShapeGeometry, "ShapeGeometry");
function toJSON$1(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i3 = 0, l3 = shapes.length; i3 < l3; i3++) {
      const shape = shapes[i3];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
__name(toJSON$1, "toJSON$1");
var SphereGeometry = class extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v3 = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u3 = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u3 * phiLength) * Math.sin(thetaStart + v3 * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v3 * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u3 * phiLength) * Math.sin(thetaStart + v3 * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u3 + uOffset, 1 - v3);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a3 = grid[iy][ix + 1];
        const b3 = grid[iy][ix];
        const c3 = grid[iy + 1][ix];
        const d3 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a3, b3, d3);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b3, c3, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
__name(SphereGeometry, "SphereGeometry");
var TetrahedronGeometry = class extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
};
__name(TetrahedronGeometry, "TetrahedronGeometry");
var TorusGeometry = class extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center2 = new Vector3();
    const vertex = new Vector3();
    const normal = new Vector3();
    for (let j3 = 0; j3 <= radialSegments; j3++) {
      for (let i3 = 0; i3 <= tubularSegments; i3++) {
        const u3 = i3 / tubularSegments * arc;
        const v3 = j3 / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v3)) * Math.cos(u3);
        vertex.y = (radius + tube * Math.cos(v3)) * Math.sin(u3);
        vertex.z = tube * Math.sin(v3);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center2.x = radius * Math.cos(u3);
        center2.y = radius * Math.sin(u3);
        normal.subVectors(vertex, center2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i3 / tubularSegments);
        uvs.push(j3 / radialSegments);
      }
    }
    for (let j3 = 1; j3 <= radialSegments; j3++) {
      for (let i3 = 1; i3 <= tubularSegments; i3++) {
        const a3 = (tubularSegments + 1) * j3 + i3 - 1;
        const b3 = (tubularSegments + 1) * (j3 - 1) + i3 - 1;
        const c3 = (tubularSegments + 1) * (j3 - 1) + i3;
        const d3 = (tubularSegments + 1) * j3 + i3;
        indices.push(a3, b3, d3);
        indices.push(b3, c3, d3);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};
__name(TorusGeometry, "TorusGeometry");
var TubeGeometry = class extends BufferGeometry {
  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P2 = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i3 = 0; i3 < tubularSegments; i3++) {
        generateSegment(i3);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    __name(generateBufferData, "generateBufferData");
    function generateSegment(i3) {
      P2 = path.getPointAt(i3 / tubularSegments, P2);
      const N2 = frames.normals[i3];
      const B = frames.binormals[i3];
      for (let j3 = 0; j3 <= radialSegments; j3++) {
        const v3 = j3 / radialSegments * Math.PI * 2;
        const sin = Math.sin(v3);
        const cos = -Math.cos(v3);
        normal.x = cos * N2.x + sin * B.x;
        normal.y = cos * N2.y + sin * B.y;
        normal.z = cos * N2.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex.x = P2.x + radius * normal.x;
        vertex.y = P2.y + radius * normal.y;
        vertex.z = P2.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    __name(generateSegment, "generateSegment");
    function generateIndices() {
      for (let j3 = 1; j3 <= tubularSegments; j3++) {
        for (let i3 = 1; i3 <= radialSegments; i3++) {
          const a3 = (radialSegments + 1) * (j3 - 1) + (i3 - 1);
          const b3 = (radialSegments + 1) * j3 + (i3 - 1);
          const c3 = (radialSegments + 1) * j3 + i3;
          const d3 = (radialSegments + 1) * (j3 - 1) + i3;
          indices.push(a3, b3, d3);
          indices.push(b3, c3, d3);
        }
      }
    }
    __name(generateIndices, "generateIndices");
    function generateUVs() {
      for (let i3 = 0; i3 <= tubularSegments; i3++) {
        for (let j3 = 0; j3 <= radialSegments; j3++) {
          uv.x = i3 / tubularSegments;
          uv.y = j3 / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
    __name(generateUVs, "generateUVs");
  }
  toJSON() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.path = this.parameters.path.toJSON();
    return data;
  }
};
__name(TubeGeometry, "TubeGeometry");
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
};
__name(ShadowMaterial, "ShadowMaterial");
ShadowMaterial.prototype.isShadowMaterial = true;
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
};
__name(RawShaderMaterial, "RawShaderMaterial");
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.flatShading = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
__name(MeshStandardMaterial, "MeshStandardMaterial");
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.flatShading = source.flatShading;
  this.vertexTangents = source.vertexTangents;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
__name(MeshPhysicalMaterial, "MeshPhysicalMaterial");
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
__name(MeshPhongMaterial, "MeshPhongMaterial");
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {TOON: ""};
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
__name(MeshToonMaterial, "MeshToonMaterial");
MeshToonMaterial.prototype.isMeshToonMaterial = true;
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
__name(MeshNormalMaterial, "MeshNormalMaterial");
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  }
};
__name(MeshLambertMaterial, "MeshLambertMaterial");
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.defines = {MATCAP: ""};
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = {MATCAP: ""};
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.flatShading = source.flatShading;
    return this;
  }
};
__name(MeshMatcapMaterial, "MeshMatcapMaterial");
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
__name(LineDashedMaterial, "LineDashedMaterial");
LineDashedMaterial.prototype.isLineDashedMaterial = true;
var AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i3, j3) {
      return times[i3] - times[j3];
    }
    __name(compareTime, "compareTime");
    const n2 = times.length;
    const result = new Array(n2);
    for (let i3 = 0; i3 !== n2; ++i3)
      result[i3] = i3;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i3 = 0, dstOffset = 0; dstOffset !== nValues; ++i3) {
      const srcOffset = order[i3] * stride;
      for (let j3 = 0; j3 !== stride; ++j3) {
        result[dstOffset++] = values[srcOffset + j3];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i3 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i3++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i3++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i3++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i3++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i3 = 0; i3 < clip.tracks.length; ++i3) {
      const track = clip.tracks[i3];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j3 = 0; j3 < track.times.length; ++j3) {
        const frame = track.times[j3] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j3]);
        for (let k3 = 0; k3 < valueSize; ++k3) {
          values.push(track.values[j3 * valueSize + k3]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i3 = 0; i3 < clip.tracks.length; ++i3) {
      if (minStartTime > clip.tracks[i3].times[0]) {
        minStartTime = clip.tracks[i3].times[0];
      }
    }
    for (let i3 = 0; i3 < clip.tracks.length; ++i3) {
      clip.tracks[i3].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i3 = 0; i3 < numTracks; ++i3) {
      const referenceTrack = referenceClip.tracks[i3];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j3 = 0; j3 < numTimes; ++j3) {
        const valueStart = j3 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k3 = 0; k3 < valueEnd; ++k3) {
            targetTrack.values[valueStart + k3] -= referenceValue[k3];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
__name(Interpolant, "Interpolant");
Object.assign(Interpolant.prototype, {
  evaluate: function(t3) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t3 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t3 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t3, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t3 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t3 >= t0)) {
            const t1global = pp[1];
            if (t3 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t3, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t3 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t3 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t3, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t3);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t3, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset3 = index * stride;
    for (let i3 = 0; i3 !== stride; ++i3) {
      result[i3] = values[offset3 + i3];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
__name(CubicInterpolant, "CubicInterpolant");
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t3, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p3 = (t3 - t0) / (t1 - t0), pp = p3 * p3, ppp = pp * p3;
    const sP = -wP * ppp + 2 * wP * pp - wP * p3;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p3 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p3;
    const sN = wN * ppp - wN * pp;
    for (let i3 = 0; i3 !== stride; ++i3) {
      result[i3] = sP * values[oP + i3] + s0 * values[o0 + i3] + s1 * values[o1 + i3] + sN * values[oN + i3];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
__name(LinearInterpolant, "LinearInterpolant");
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t3, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t3 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i3 = 0; i3 !== stride; ++i3) {
      result[i3] = values[offset0 + i3] * weight0 + values[offset1 + i3] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
__name(DiscreteInterpolant, "DiscreteInterpolant");
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
var KeyframeTrack = class {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i3 = 0, n2 = times.length; i3 !== n2; ++i3) {
        times[i3] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i3 = 0, n2 = times.length; i3 !== n2; ++i3) {
        times[i3] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i3 = 0; i3 !== nKeys; i3++) {
      const currTime = times[i3];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i3, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i3, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i3 = 0, n2 = values.length; i3 !== n2; ++i3) {
          const value = values[i3];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i3, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i3 = 1; i3 < lastIndex; ++i3) {
      let keep = false;
      const time = times[i3];
      const timeNext = times[i3 + 1];
      if (time !== timeNext && (i3 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset3 = i3 * stride, offsetP = offset3 - stride, offsetN = offset3 + stride;
          for (let j3 = 0; j3 !== stride; ++j3) {
            const value = values[offset3 + j3];
            if (value !== values[offsetP + j3] || value !== values[offsetN + j3]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i3 !== writeIndex) {
          times[writeIndex] = times[i3];
          const readOffset = i3 * stride, writeOffset = writeIndex * stride;
          for (let j3 = 0; j3 !== stride; ++j3) {
            values[writeOffset + j3] = values[readOffset + j3];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j3 = 0; j3 !== stride; ++j3) {
        values[writeOffset + j3] = values[readOffset + j3];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
__name(KeyframeTrack, "KeyframeTrack");
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
__name(BooleanKeyframeTrack, "BooleanKeyframeTrack");
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
__name(ColorKeyframeTrack, "ColorKeyframeTrack");
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
__name(NumberKeyframeTrack, "NumberKeyframeTrack");
NumberKeyframeTrack.prototype.ValueTypeName = "number";
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
__name(QuaternionLinearInterpolant, "QuaternionLinearInterpolant");
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t3, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t3 - t0) / (t1 - t0);
    let offset3 = i1 * stride;
    for (let end = offset3 + stride; offset3 !== end; offset3 += 4) {
      Quaternion.slerpFlat(result, 0, values, offset3 - stride, values, offset3, alpha);
    }
    return result;
  }
});
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
__name(QuaternionKeyframeTrack, "QuaternionKeyframeTrack");
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
__name(StringKeyframeTrack, "StringKeyframeTrack");
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
__name(VectorKeyframeTrack, "VectorKeyframeTrack");
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i3 = 0, n2 = jsonTracks.length; i3 !== n2; ++i3) {
      tracks.push(parseKeyframeTrack(jsonTracks[i3]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode
    };
    for (let i3 = 0, n2 = clipTracks.length; i3 !== n2; ++i3) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i3]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i3 = 0; i3 < numMorphTargets; i3++) {
      let times = [];
      let values = [];
      times.push((i3 + numMorphTargets - 1) % numMorphTargets, i3, (i3 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i3].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o3 = objectOrClipArray;
      clipArray = o3.geometry && o3.geometry.animations || o3.animations;
    }
    for (let i3 = 0; i3 < clipArray.length; i3++) {
      if (clipArray[i3].name === name) {
        return clipArray[i3];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i3 = 0, il = morphTargets.length; i3 < il; i3++) {
      const morphTarget = morphTargets[i3];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = /* @__PURE__ */ __name(function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    }, "addNonemptyTrack");
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k3;
        for (k3 = 0; k3 < animationKeys.length; k3++) {
          if (animationKeys[k3].morphTargets) {
            for (let m3 = 0; m3 < animationKeys[k3].morphTargets.length; m3++) {
              morphTargetNames[animationKeys[k3].morphTargets[m3]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m3 = 0; m3 !== animationKeys[k3].morphTargets.length; ++m3) {
            const animationKey = animationKeys[k3];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i3 = 0, n2 = tracks.length; i3 !== n2; ++i3) {
      const track = this.tracks[i3];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i3 = 0; i3 < this.tracks.length; i3++) {
      this.tracks[i3].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i3 = 0; i3 < this.tracks.length; i3++) {
      valid = valid && this.tracks[i3].validate();
    }
    return valid;
  }
  optimize() {
    for (let i3 = 0; i3 < this.tracks.length; i3++) {
      this.tracks[i3].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i3 = 0; i3 < this.tracks.length; i3++) {
      tracks.push(this.tracks[i3].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
__name(AnimationClip, "AnimationClip");
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
__name(getTrackTypeForValueTypeName, "getTrackTypeForValueTypeName");
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
__name(parseKeyframeTrack, "parseKeyframeTrack");
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i3 = 0, l3 = handlers.length; i3 < l3; i3 += 2) {
      const regex = handlers[i3];
      const loader = handlers[i3 + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
__name(LoadingManager, "LoadingManager");
var DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.withCredentials = false;
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
__name(Loader, "Loader");
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function(path) {
    this.path = path;
    return this;
  },
  setResourcePath: function(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
var loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
__name(FileLoader, "FileLoader");
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64)
        data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data.length);
            for (let i3 = 0; i3 < data.length; i3++) {
              view[i3] = data.charCodeAt(i3);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], {type: mimeType});
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i3 = 0, il = callbacks.length; i3 < il; i3++) {
            const callback = callbacks[i3];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i3 = 0, il = callbacks.length; i3 < il; i3++) {
            const callback = callbacks[i3];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i3 = 0, il = callbacks.length; i3 < il; i3++) {
          const callback = callbacks[i3];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i3 = 0, il = callbacks.length; i3 < il; i3++) {
          const callback = callbacks[i3];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i3 = 0, il = callbacks.length; i3 < il; i3++) {
          const callback = callbacks[i3];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
__name(CompressedTextureLoader, "CompressedTextureLoader");
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i3) {
      loader.load(url[i3], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i3] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    __name(loadTexture, "loadTexture");
    if (Array.isArray(url)) {
      for (let i3 = 0, il = url.length; i3 < il; ++i3) {
        loadTexture(i3);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f3 = 0; f3 < faces; f3++) {
            images[f3] = {mipmaps: []};
            for (let i3 = 0; i3 < texDatas.mipmapCount; i3++) {
              images[f3].mipmaps.push(texDatas.mipmaps[f3 * texDatas.mipmapCount + i3]);
              images[f3].format = texDatas.format;
              images[f3].width = texDatas.width;
              images[f3].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    __name(onImageLoad, "onImageLoad");
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    __name(onImageError, "onImageError");
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
__name(ImageLoader, "ImageLoader");
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i3) {
      loader.load(urls[i3], function(image) {
        texture.images[i3] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    __name(loadTexture, "loadTexture");
    for (let i3 = 0; i3 < urls.length; ++i3) {
      loadTexture(i3);
    }
    return texture;
  }
};
__name(CubeTextureLoader, "CubeTextureLoader");
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
__name(DataTextureLoader, "DataTextureLoader");
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
__name(TextureLoader, "TextureLoader");
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
__name(Curve, "Curve");
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u3, optionalTarget) {
    const t3 = this.getUtoTmapping(u3);
    return this.getPoint(t3, optionalTarget);
  },
  getPoints: function(divisions = 5) {
    const points = [];
    for (let d3 = 0; d3 <= divisions; d3++) {
      points.push(this.getPoint(d3 / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions = 5) {
    const points = [];
    for (let d3 = 0; d3 <= divisions; d3++) {
      points.push(this.getPointAt(d3 / divisions));
    }
    return points;
  },
  getLength: function() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p3 = 1; p3 <= divisions; p3++) {
      current = this.getPoint(p3 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u3, distance) {
    const arcLengths = this.getLengths();
    let i3 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u3 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i3 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i3] - targetArcLength;
      if (comparison < 0) {
        low = i3 + 1;
      } else if (comparison > 0) {
        high = i3 - 1;
      } else {
        high = i3;
        break;
      }
    }
    i3 = high;
    if (arcLengths[i3] === targetArcLength) {
      return i3 / (il - 1);
    }
    const lengthBefore = arcLengths[i3];
    const lengthAfter = arcLengths[i3 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t3 = (i3 + segmentFraction) / (il - 1);
    return t3;
  },
  getTangent: function(t3, optionalTarget) {
    const delta = 1e-4;
    let t1 = t3 - delta;
    let t22 = t3 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function(u3, optionalTarget) {
    const t3 = this.getUtoTmapping(u3);
    return this.getTangent(t3, optionalTarget);
  },
  computeFrenetFrames: function(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i3 = 0; i3 <= segments; i3++) {
      const u3 = i3 / segments;
      tangents[i3] = this.getTangentAt(u3, new Vector3());
      tangents[i3].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i3 = 1; i3 <= segments; i3++) {
      normals[i3] = normals[i3 - 1].clone();
      binormals[i3] = binormals[i3 - 1].clone();
      vec.crossVectors(tangents[i3 - 1], tangents[i3]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i3 - 1].dot(tangents[i3]), -1, 1));
        normals[i3].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i3].crossVectors(tangents[i3], normals[i3]);
    }
    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i3 = 1; i3 <= segments; i3++) {
        normals[i3].applyMatrix4(mat.makeRotationAxis(tangents[i3], theta * i3));
        binormals[i3].crossVectors(tangents[i3], normals[i3]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t3, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t3 * deltaAngle;
    let x3 = this.aX + this.xRadius * Math.cos(angle);
    let y3 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x3 - this.aX;
      const ty = y3 - this.aY;
      x3 = tx * cos - ty * sin + this.aX;
      y3 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x3, y3);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
__name(EllipseCurve, "EllipseCurve");
EllipseCurve.prototype.isEllipseCurve = true;
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
};
__name(ArcCurve, "ArcCurve");
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c22 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c22 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  __name(init, "init");
  return {
    initCatmullRom: function(x0, x1, x22, x3, tension) {
      init(x1, x22, tension * (x22 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x22, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x22 - x0) / (dt0 + dt1) + (x22 - x1) / dt1;
      let t22 = (x22 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x22) / dt2;
      t1 *= dt1;
      t22 *= dt1;
      init(x1, x22, t1, t22);
    },
    calc: function(t3) {
      const t22 = t3 * t3;
      const t32 = t22 * t3;
      return c0 + c1 * t3 + c22 * t22 + c3 * t32;
    }
  };
}
__name(CubicPoly, "CubicPoly");
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t3, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l3 = points.length;
    const p3 = (l3 - (this.closed ? 0 : 1)) * t3;
    let intPoint = Math.floor(p3);
    let weight = p3 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l3) + 1) * l3;
    } else if (weight === 0 && intPoint === l3 - 1) {
      intPoint = l3 - 2;
      weight = 1;
    }
    let p0, p32;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l3];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l3];
    const p22 = points[(intPoint + 1) % l3];
    if (this.closed || intPoint + 2 < l3) {
      p32 = points[(intPoint + 2) % l3];
    } else {
      tmp.subVectors(points[l3 - 1], points[l3 - 2]).add(points[l3 - 1]);
      p32 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p32), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p32.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p32.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p32.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p32.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p32.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p32.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i3 = 0, l3 = source.points.length; i3 < l3; i3++) {
      const point = source.points[i3];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i3 = 0, l3 = this.points.length; i3 < l3; i3++) {
      const point = this.points[i3];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i3 = 0, l3 = json.points.length; i3 < l3; i3++) {
      const point = json.points[i3];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
__name(CatmullRomCurve3, "CatmullRomCurve3");
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t3, p0, p1, p22, p3) {
  const v0 = (p22 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t3 * t3;
  const t32 = t3 * t22;
  return (2 * p1 - 2 * p22 + v0 + v1) * t32 + (-3 * p1 + 3 * p22 - 2 * v0 - v1) * t22 + v0 * t3 + p1;
}
__name(CatmullRom, "CatmullRom");
function QuadraticBezierP0(t3, p3) {
  const k3 = 1 - t3;
  return k3 * k3 * p3;
}
__name(QuadraticBezierP0, "QuadraticBezierP0");
function QuadraticBezierP1(t3, p3) {
  return 2 * (1 - t3) * t3 * p3;
}
__name(QuadraticBezierP1, "QuadraticBezierP1");
function QuadraticBezierP2(t3, p3) {
  return t3 * t3 * p3;
}
__name(QuadraticBezierP2, "QuadraticBezierP2");
function QuadraticBezier(t3, p0, p1, p22) {
  return QuadraticBezierP0(t3, p0) + QuadraticBezierP1(t3, p1) + QuadraticBezierP2(t3, p22);
}
__name(QuadraticBezier, "QuadraticBezier");
function CubicBezierP0(t3, p3) {
  const k3 = 1 - t3;
  return k3 * k3 * k3 * p3;
}
__name(CubicBezierP0, "CubicBezierP0");
function CubicBezierP1(t3, p3) {
  const k3 = 1 - t3;
  return 3 * k3 * k3 * t3 * p3;
}
__name(CubicBezierP1, "CubicBezierP1");
function CubicBezierP2(t3, p3) {
  return 3 * (1 - t3) * t3 * t3 * p3;
}
__name(CubicBezierP2, "CubicBezierP2");
function CubicBezierP3(t3, p3) {
  return t3 * t3 * t3 * p3;
}
__name(CubicBezierP3, "CubicBezierP3");
function CubicBezier(t3, p0, p1, p22, p3) {
  return CubicBezierP0(t3, p0) + CubicBezierP1(t3, p1) + CubicBezierP2(t3, p22) + CubicBezierP3(t3, p3);
}
__name(CubicBezier, "CubicBezier");
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v22 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v22;
    this.v3 = v3;
  }
  getPoint(t3, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v22 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t3, v0.x, v1.x, v22.x, v3.x), CubicBezier(t3, v0.y, v1.y, v22.y, v3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
__name(CubicBezierCurve, "CubicBezierCurve");
CubicBezierCurve.prototype.isCubicBezierCurve = true;
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v22 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v22;
    this.v3 = v3;
  }
  getPoint(t3, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v22 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t3, v0.x, v1.x, v22.x, v3.x), CubicBezier(t3, v0.y, v1.y, v22.y, v3.y), CubicBezier(t3, v0.z, v1.z, v22.z, v3.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
__name(CubicBezierCurve3, "CubicBezierCurve3");
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v22 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v22;
  }
  getPoint(t3, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t3 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t3).add(this.v1);
    }
    return point;
  }
  getPointAt(u3, optionalTarget) {
    return this.getPoint(u3, optionalTarget);
  }
  getTangent(t3, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
__name(LineCurve, "LineCurve");
LineCurve.prototype.isLineCurve = true;
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v22 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v22;
  }
  getPoint(t3, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t3 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t3).add(this.v1);
    }
    return point;
  }
  getPointAt(u3, optionalTarget) {
    return this.getPoint(u3, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
__name(LineCurve3, "LineCurve3");
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v22 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v22;
  }
  getPoint(t3, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v22 = this.v2;
    point.set(QuadraticBezier(t3, v0.x, v1.x, v22.x), QuadraticBezier(t3, v0.y, v1.y, v22.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
__name(QuadraticBezierCurve, "QuadraticBezierCurve");
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v22 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v22;
  }
  getPoint(t3, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v22 = this.v2;
    point.set(QuadraticBezier(t3, v0.x, v1.x, v22.x), QuadraticBezier(t3, v0.y, v1.y, v22.y), QuadraticBezier(t3, v0.z, v1.z, v22.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
__name(QuadraticBezierCurve3, "QuadraticBezierCurve3");
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t3, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p3 = (points.length - 1) * t3;
    const intPoint = Math.floor(p3);
    const weight = p3 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p32 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p32.x), CatmullRom(weight, p0.y, p1.y, p22.y, p32.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i3 = 0, l3 = source.points.length; i3 < l3; i3++) {
      const point = source.points[i3];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i3 = 0, l3 = this.points.length; i3 < l3; i3++) {
      const point = this.points[i3];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i3 = 0, l3 = json.points.length; i3 < l3; i3++) {
      const point = json.points[i3];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
};
__name(SplineCurve, "SplineCurve");
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t3) {
    const d3 = t3 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i3 = 0;
    while (i3 < curveLengths.length) {
      if (curveLengths[i3] >= d3) {
        const diff = curveLengths[i3] - d3;
        const curve = this.curves[i3];
        const segmentLength = curve.getLength();
        const u3 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u3);
      }
      i3++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i3 = 0, l3 = this.curves.length; i3 < l3; i3++) {
      sums += this.curves[i3].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i3 = 0; i3 <= divisions; i3++) {
      points.push(this.getPoint(i3 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i3 = 0, curves = this.curves; i3 < curves.length; i3++) {
      const curve = curves[i3];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j3 = 0; j3 < pts.length; j3++) {
        const point = pts[j3];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i3 = 0, l3 = source.curves.length; i3 < l3; i3++) {
      const curve = source.curves[i3];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i3 = 0, l3 = this.curves.length; i3 < l3; i3++) {
      const curve = this.curves[i3];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i3 = 0, l3 = json.curves.length; i3 < l3; i3++) {
      const curve = json.curves[i3];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
__name(CurvePath, "CurvePath");
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i3 = 1, l3 = points.length; i3 < l3; i3++) {
      this.lineTo(points[i3].x, points[i3].y);
    }
    return this;
  }
  moveTo(x3, y3) {
    this.currentPoint.set(x3, y3);
    return this;
  }
  lineTo(x3, y3) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x3, y3));
    this.curves.push(curve);
    this.currentPoint.set(x3, y3);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
__name(Path, "Path");
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = MathUtils.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i3 = 0, l3 = this.holes.length; i3 < l3; i3++) {
      holesPts[i3] = this.holes[i3].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i3 = 0, l3 = source.holes.length; i3 < l3; i3++) {
      const hole = source.holes[i3];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i3 = 0, l3 = this.holes.length; i3 < l3; i3++) {
      const hole = this.holes[i3];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i3 = 0, l3 = json.holes.length; i3 < l3; i3++) {
      const hole = json.holes[i3];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
__name(Shape, "Shape");
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
__name(Light, "Light");
Light.prototype.isLight = true;
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
__name(HemisphereLight, "HemisphereLight");
HemisphereLight.prototype.isHemisphereLight = true;
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld);
    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
__name(LightShadow, "LightShadow");
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
};
__name(SpotLightShadow, "SpotLightShadow");
SpotLightShadow.prototype.isSpotLightShadow = true;
var SpotLight = class extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
__name(SpotLight, "SpotLight");
SpotLight.prototype.isSpotLight = true;
var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
var _lookTarget$1 = /* @__PURE__ */ new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.copy(camera.position);
    _lookTarget$1.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget$1);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z);
    _projScreenMatrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
  }
};
__name(PointLightShadow, "PointLightShadow");
PointLightShadow.prototype.isPointLightShadow = true;
var PointLight = class extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
__name(PointLight, "PointLight");
PointLight.prototype.isPointLight = true;
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y3;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
};
__name(OrthographicCamera, "OrthographicCamera");
OrthographicCamera.prototype.isOrthographicCamera = true;
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
};
__name(DirectionalLightShadow, "DirectionalLightShadow");
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
__name(DirectionalLight, "DirectionalLight");
DirectionalLight.prototype.isDirectionalLight = true;
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
};
__name(AmbientLight, "AmbientLight");
AmbientLight.prototype.isAmbientLight = true;
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
};
__name(RectAreaLight, "RectAreaLight");
RectAreaLight.prototype.isRectAreaLight = true;
var SphericalHarmonics3 = class {
  constructor() {
    this.coefficients = [];
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients[i3].copy(coefficients[i3]);
    }
    return this;
  }
  zero() {
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients[i3].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target2) {
    const x3 = normal.x, y3 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target2.copy(coeff[0]).multiplyScalar(0.282095);
    target2.addScaledVector(coeff[1], 0.488603 * y3);
    target2.addScaledVector(coeff[2], 0.488603 * z2);
    target2.addScaledVector(coeff[3], 0.488603 * x3);
    target2.addScaledVector(coeff[4], 1.092548 * (x3 * y3));
    target2.addScaledVector(coeff[5], 1.092548 * (y3 * z2));
    target2.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target2.addScaledVector(coeff[7], 1.092548 * (x3 * z2));
    target2.addScaledVector(coeff[8], 0.546274 * (x3 * x3 - y3 * y3));
    return target2;
  }
  getIrradianceAt(normal, target2) {
    const x3 = normal.x, y3 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target2.copy(coeff[0]).multiplyScalar(0.886227);
    target2.addScaledVector(coeff[1], 2 * 0.511664 * y3);
    target2.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target2.addScaledVector(coeff[3], 2 * 0.511664 * x3);
    target2.addScaledVector(coeff[4], 2 * 0.429043 * x3 * y3);
    target2.addScaledVector(coeff[5], 2 * 0.429043 * y3 * z2);
    target2.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target2.addScaledVector(coeff[7], 2 * 0.429043 * x3 * z2);
    target2.addScaledVector(coeff[8], 0.429043 * (x3 * x3 - y3 * y3));
    return target2;
  }
  add(sh) {
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients[i3].add(sh.coefficients[i3]);
    }
    return this;
  }
  addScaledSH(sh, s3) {
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients[i3].addScaledVector(sh.coefficients[i3], s3);
    }
    return this;
  }
  scale(s3) {
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients[i3].multiplyScalar(s3);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i3 = 0; i3 < 9; i3++) {
      this.coefficients[i3].lerp(sh.coefficients[i3], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i3 = 0; i3 < 9; i3++) {
      if (!this.coefficients[i3].equals(sh.coefficients[i3])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset3 = 0) {
    const coefficients = this.coefficients;
    for (let i3 = 0; i3 < 9; i3++) {
      coefficients[i3].fromArray(array, offset3 + i3 * 3);
    }
    return this;
  }
  toArray(array = [], offset3 = 0) {
    const coefficients = this.coefficients;
    for (let i3 = 0; i3 < 9; i3++) {
      coefficients[i3].toArray(array, offset3 + i3 * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x3 = normal.x, y3 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y3;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x3;
    shBasis[4] = 1.092548 * x3 * y3;
    shBasis[5] = 1.092548 * y3 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x3 * z2;
    shBasis[8] = 0.546274 * (x3 * x3 - y3 * y3);
  }
};
__name(SphericalHarmonics3, "SphericalHarmonics3");
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
};
__name(LightProbe, "LightProbe");
LightProbe.prototype.isLightProbe = true;
var LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s3 = "";
    for (let i3 = 0, il = array.length; i3 < il; i3++) {
      s3 += String.fromCharCode(array[i3]);
    }
    try {
      return decodeURIComponent(escape(s3));
    } catch (e3) {
      return s3;
    }
  },
  extractUrlBase: function(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
__name(InstancedBufferGeometry, "InstancedBufferGeometry");
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
__name(InstancedBufferAttribute, "InstancedBufferAttribute");
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    const data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = {premultiplyAlpha: "none"};
}
__name(ImageBitmapLoader, "ImageBitmapLoader");
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: /* @__PURE__ */ __name(function setOptions(options) {
    this.options = options;
    return this;
  }, "setOptions"),
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: "none"}));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e3) {
      if (onError)
        onError(e3);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
var ShapePath = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x3, y3) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x3, y3);
    return this;
  }
  lineTo(x3, y3) {
    this.currentPath.lineTo(x3, y3);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i3 = 0, l3 = inSubpaths.length; i3 < l3; i3++) {
        const tmpPath2 = inSubpaths[i3];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    __name(toShapesNoHoles, "toShapesNoHoles");
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p3 = polyLen - 1, q2 = 0; q2 < polyLen; p3 = q2++) {
        let edgeLowPt = inPolygon[p3];
        let edgeHighPt = inPolygon[q2];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q2];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p3];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
            continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x)
              return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0)
              return true;
            if (perpEdge < 0)
              continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y)
            continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
            return true;
        }
      }
      return inside;
    }
    __name(isPointInsidePolygon, "isPointInsidePolygon");
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0)
      return [];
    if (noHoles === true)
      return toShapesNoHoles(subPaths);
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i3 = 0, l3 = subPaths.length; i3 < l3; i3++) {
      tmpPath = subPaths[i3];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx])
          mainIdx++;
        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst)
          mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});
      }
    }
    if (!newShapes[0])
      return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx)
                toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous)
          newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i3 = 0, il = newShapes.length; i3 < il; i3++) {
      tmpShape = newShapes[i3].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i3];
      for (let j3 = 0, jl = tmpHoles.length; j3 < jl; j3++) {
        tmpShape.holes.push(tmpHoles[j3].h);
      }
    }
    return shapes;
  }
};
__name(ShapePath, "ShapePath");
var Font = class {
  constructor(data) {
    this.type = "Font";
    this.data = data;
  }
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p3 = 0, pl = paths.length; p3 < pl; p3++) {
      Array.prototype.push.apply(shapes, paths[p3].toShapes());
    }
    return shapes;
  }
};
__name(Font, "Font");
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i3 = 0; i3 < chars.length; i3++) {
    const char = chars[i3];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
__name(createPaths, "createPaths");
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x3, y3, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i3 = 0, l3 = outline.length; i3 < l3; ) {
      const action = outline[i3++];
      switch (action) {
        case "m":
          x3 = outline[i3++] * scale + offsetX;
          y3 = outline[i3++] * scale + offsetY;
          path.moveTo(x3, y3);
          break;
        case "l":
          x3 = outline[i3++] * scale + offsetX;
          y3 = outline[i3++] * scale + offsetY;
          path.lineTo(x3, y3);
          break;
        case "q":
          cpx = outline[i3++] * scale + offsetX;
          cpy = outline[i3++] * scale + offsetY;
          cpx1 = outline[i3++] * scale + offsetX;
          cpy1 = outline[i3++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i3++] * scale + offsetX;
          cpy = outline[i3++] * scale + offsetY;
          cpx1 = outline[i3++] * scale + offsetX;
          cpy1 = outline[i3++] * scale + offsetY;
          cpx2 = outline[i3++] * scale + offsetX;
          cpy2 = outline[i3++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {offsetX: glyph.ha * scale, path};
}
__name(createPath, "createPath");
Font.prototype.isFont = true;
var _context;
var AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context3 = AudioContext.getContext();
        context3.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e3) {
        if (onError) {
          onError(e3);
        } else {
          console.error(e3);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
};
__name(AudioLoader, "AudioLoader");
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
__name(HemisphereLightProbe, "HemisphereLightProbe");
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
__name(AmbientLightProbe, "AmbientLightProbe");
AmbientLightProbe.prototype.isAmbientLightProbe = true;
var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i3 = 1, l3 = this.filters.length; i3 < l3; i3++) {
        this.filters[i3 - 1].connect(this.filters[i3]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i3 = 1, l3 = this.filters.length; i3 < l3; i3++) {
        this.filters[i3 - 1].disconnect(this.filters[i3]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
__name(Audio, "Audio");
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i3 = 0; i3 < data.length; i3++) {
      value += data[i3];
    }
    return value / data.length;
  }
};
__name(AudioAnalyser, "AudioAnalyser");
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset3 = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i3 = 0; i3 !== stride; ++i3) {
        buffer[offset3 + i3] = buffer[i3];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset3, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset3 = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset3, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset3 = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset3, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset3, this._addIndex * stride, 1, stride);
    }
    for (let i3 = stride, e3 = stride + stride; i3 !== e3; ++i3) {
      if (buffer[i3] !== buffer[i3 + stride]) {
        binding.setValue(buffer, offset3);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i3 = stride, e3 = originalValueOffset; i3 !== e3; ++i3) {
      buffer[i3] = buffer[originalValueOffset + i3 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i3 = startIndex; i3 < endIndex; i3++) {
      this.buffer[i3] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i3 = 0; i3 < this.valueSize; i3++) {
      this.buffer[targetIndex + i3] = this.buffer[startIndex + i3];
    }
  }
  _select(buffer, dstOffset, srcOffset, t3, stride) {
    if (t3 >= 0.5) {
      for (let i3 = 0; i3 !== stride; ++i3) {
        buffer[dstOffset + i3] = buffer[srcOffset + i3];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t3) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t3);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t3, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t3);
  }
  _lerp(buffer, dstOffset, srcOffset, t3, stride) {
    const s3 = 1 - t3;
    for (let i3 = 0; i3 !== stride; ++i3) {
      const j3 = dstOffset + i3;
      buffer[j3] = buffer[j3] * s3 + buffer[srcOffset + i3] * t3;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t3, stride) {
    for (let i3 = 0; i3 !== stride; ++i3) {
      const j3 = dstOffset + i3;
      buffer[j3] = buffer[j3] + buffer[srcOffset + i3] * t3;
    }
  }
};
__name(PropertyMixer, "PropertyMixer");
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
var _supportedObjectNames = ["material", "materials", "bones"];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
__name(Composite, "Composite");
Object.assign(Composite.prototype, {
  getValue: function(array, offset3) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset3);
  },
  setValue: function(array, offset3) {
    const bindings = this._bindings;
    for (let i3 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i3 !== n2; ++i3) {
      bindings[i3].setValue(array, offset3);
    }
  },
  bind: function() {
    const bindings = this._bindings;
    for (let i3 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i3 !== n2; ++i3) {
      bindings[i3].bind();
    }
  },
  unbind: function() {
    const bindings = this._bindings;
    for (let i3 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i3 !== n2; ++i3) {
      bindings[i3].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
__name(PropertyBinding, "PropertyBinding");
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  },
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = /* @__PURE__ */ __name(function(children) {
        for (let i3 = 0; i3 < children.length; i3++) {
          const childNode = children[i3];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      }, "searchNodeSubtree");
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    /* @__PURE__ */ __name(function getValue_direct(buffer, offset3) {
      buffer[offset3] = this.node[this.propertyName];
    }, "getValue_direct"),
    /* @__PURE__ */ __name(function getValue_array(buffer, offset3) {
      const source = this.resolvedProperty;
      for (let i3 = 0, n2 = source.length; i3 !== n2; ++i3) {
        buffer[offset3++] = source[i3];
      }
    }, "getValue_array"),
    /* @__PURE__ */ __name(function getValue_arrayElement(buffer, offset3) {
      buffer[offset3] = this.resolvedProperty[this.propertyIndex];
    }, "getValue_arrayElement"),
    /* @__PURE__ */ __name(function getValue_toArray(buffer, offset3) {
      this.resolvedProperty.toArray(buffer, offset3);
    }, "getValue_toArray")
  ],
  SetterByBindingTypeAndVersioning: [
    [
      /* @__PURE__ */ __name(function setValue_direct(buffer, offset3) {
        this.targetObject[this.propertyName] = buffer[offset3];
      }, "setValue_direct"),
      /* @__PURE__ */ __name(function setValue_direct_setNeedsUpdate(buffer, offset3) {
        this.targetObject[this.propertyName] = buffer[offset3];
        this.targetObject.needsUpdate = true;
      }, "setValue_direct_setNeedsUpdate"),
      /* @__PURE__ */ __name(function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset3) {
        this.targetObject[this.propertyName] = buffer[offset3];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }, "setValue_direct_setMatrixWorldNeedsUpdate")
    ],
    [
      /* @__PURE__ */ __name(function setValue_array(buffer, offset3) {
        const dest = this.resolvedProperty;
        for (let i3 = 0, n2 = dest.length; i3 !== n2; ++i3) {
          dest[i3] = buffer[offset3++];
        }
      }, "setValue_array"),
      /* @__PURE__ */ __name(function setValue_array_setNeedsUpdate(buffer, offset3) {
        const dest = this.resolvedProperty;
        for (let i3 = 0, n2 = dest.length; i3 !== n2; ++i3) {
          dest[i3] = buffer[offset3++];
        }
        this.targetObject.needsUpdate = true;
      }, "setValue_array_setNeedsUpdate"),
      /* @__PURE__ */ __name(function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset3) {
        const dest = this.resolvedProperty;
        for (let i3 = 0, n2 = dest.length; i3 !== n2; ++i3) {
          dest[i3] = buffer[offset3++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }, "setValue_array_setMatrixWorldNeedsUpdate")
    ],
    [
      /* @__PURE__ */ __name(function setValue_arrayElement(buffer, offset3) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset3];
      }, "setValue_arrayElement"),
      /* @__PURE__ */ __name(function setValue_arrayElement_setNeedsUpdate(buffer, offset3) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset3];
        this.targetObject.needsUpdate = true;
      }, "setValue_arrayElement_setNeedsUpdate"),
      /* @__PURE__ */ __name(function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset3) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset3];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }, "setValue_arrayElement_setMatrixWorldNeedsUpdate")
    ],
    [
      /* @__PURE__ */ __name(function setValue_fromArray(buffer, offset3) {
        this.resolvedProperty.fromArray(buffer, offset3);
      }, "setValue_fromArray"),
      /* @__PURE__ */ __name(function setValue_fromArray_setNeedsUpdate(buffer, offset3) {
        this.resolvedProperty.fromArray(buffer, offset3);
        this.targetObject.needsUpdate = true;
      }, "setValue_fromArray_setNeedsUpdate"),
      /* @__PURE__ */ __name(function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset3) {
        this.resolvedProperty.fromArray(buffer, offset3);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }, "setValue_fromArray_setMatrixWorldNeedsUpdate")
    ]
  ],
  getValue: /* @__PURE__ */ __name(function getValue_unbound(targetArray, offset3) {
    this.bind();
    this.getValue(targetArray, offset3);
  }, "getValue_unbound"),
  setValue: /* @__PURE__ */ __name(function getValue_unbound2(sourceArray, offset3) {
    this.bind();
    this.setValue(sourceArray, offset3);
  }, "getValue_unbound"),
  bind: function() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i3 = 0; i3 < targetObject.length; i3++) {
            if (targetObject[i3].name === objectIndex) {
              objectIndex = i3;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
var AnimationObjectGroup = class {
  constructor() {
    this.uuid = MathUtils.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i3 = 0, n2 = arguments.length; i3 !== n2; ++i3) {
      indices[arguments[i3].uuid] = i3;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i3 = 0, n2 = arguments.length; i3 !== n2; ++i3) {
      const object = arguments[i3], uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (let j3 = 0, m3 = nBindings; j3 !== m3; ++j3) {
          bindings[j3].push(new PropertyBinding(object, paths[j3], parsedPaths[j3]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j3 = 0, m3 = nBindings; j3 !== m3; ++j3) {
          const bindingsForPath = bindings[j3], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j3], parsedPaths[j3]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i3 = 0, n2 = arguments.length; i3 !== n2; ++i3) {
      const object = arguments[i3], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j3 = 0, m3 = nBindings; j3 !== m3; ++j3) {
          const bindingsForPath = bindings[j3], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i3 = 0, n2 = arguments.length; i3 !== n2; ++i3) {
      const object = arguments[i3], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j3 = 0, m3 = nBindings; j3 !== m3; ++j3) {
            const bindingsForPath = bindings[j3], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j3 = 0, m3 = nBindings; j3 !== m3; ++j3) {
            const bindingsForPath = bindings[j3];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0)
      return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i3 = nCachedObjects, n2 = objects.length; i3 !== n2; ++i3) {
      const object = objects[i3];
      bindingsForPath[i3] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
__name(AnimationObjectGroup, "AnimationObjectGroup");
AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i3 = 0; i3 !== nTracks; ++i3) {
      const interpolant = tracks[i3].createInterpolant(null);
      interpolants[i3] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j3 = 0, m3 = interpolants.length; j3 !== m3; ++j3) {
            interpolants[j3].evaluate(clipTime);
            propertyMixers[j3].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j3 = 0, m3 = interpolants.length; j3 !== m3; ++j3) {
            interpolants[j3].evaluate(clipTime);
            propertyMixers[j3].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending2 = this.repetitions - loopCount;
        if (pending2 <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending2 === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
};
__name(AnimationAction, "AnimationAction");
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i3 = 0; i3 !== nTracks; ++i3) {
      const track = tracks[i3], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i3] = binding;
      } else {
        binding = bindings[i3];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i3].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i3] = binding;
      }
      interpolants[i3].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i3 = 0, n2 = bindings.length; i3 !== n2; ++i3) {
        const binding = bindings[i3];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i3 = 0, n2 = bindings.length; i3 !== n2; ++i3) {
        const binding = bindings[i3];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i3 = 0, n2 = bindings.length; i3 !== n2; ++i3) {
      const binding = bindings[i3];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i3 = nActions - 1; i3 >= 0; --i3) {
      actions[i3].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i3 = 0; i3 !== nActions; ++i3) {
      const action = actions[i3];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i3 = 0; i3 !== nBindings; ++i3) {
      bindings[i3].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i3 = 0; i3 < this._actions.length; i3++) {
      this._actions[i3].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i3 = 0, n2 = actionsToRemove.length; i3 !== n2; ++i3) {
        const action = actionsToRemove[i3];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
__name(AnimationMixer, "AnimationMixer");
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class {
  constructor(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  clone() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
__name(Uniform, "Uniform");
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
__name(InstancedInterleavedBuffer, "InstancedInterleavedBuffer");
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function(data) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function(data) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
__name(GLBufferAttribute, "GLBufferAttribute");
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function(buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function(itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function(count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near = 0, far = Infinity) {
  this.ray = new Ray(origin, direction);
  this.near = near;
  this.far = far;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {threshold: 1},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
__name(Raycaster, "Raycaster");
function ascSort(a3, b3) {
  return a3.distance - b3.distance;
}
__name(ascSort, "ascSort");
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i3 = 0, l3 = children.length; i3 < l3; i3++) {
      intersectObject(children[i3], raycaster, intersects2, true);
    }
  }
}
__name(intersectObject, "intersectObject");
Object.assign(Raycaster.prototype, {
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  },
  intersectObject: function(object, recursive = false, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive = false, intersects2 = []) {
    for (let i3 = 0, l3 = objects.length; i3 < l3; i3++) {
      intersectObject(objects[i3], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
var _vector$8 = /* @__PURE__ */ new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i3 = 0, il = points.length; i3 < il; i3++) {
      this.expandByPoint(points[i3]);
    }
    return this;
  }
  setFromCenterAndSize(center2, size) {
    const halfSize = _vector$8.copy(size).multiplyScalar(0.5);
    this.min.copy(center2).sub(halfSize);
    this.max.copy(center2).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box2) {
    this.min.copy(box2.min);
    this.max.copy(box2.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box2: .getCenter() target is now required");
      target2 = new Vector2();
    }
    return this.isEmpty() ? target2.set(0, 0) : target2.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box2: .getSize() target is now required");
      target2 = new Vector2();
    }
    return this.isEmpty() ? target2.set(0, 0) : target2.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box2) {
    return this.min.x <= box2.min.x && box2.max.x <= this.max.x && this.min.y <= box2.min.y && box2.max.y <= this.max.y;
  }
  getParameter(point, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box2: .getParameter() target is now required");
      target2 = new Vector2();
    }
    return target2.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(box2) {
    return box2.max.x < this.min.x || box2.min.x > this.max.x || box2.max.y < this.min.y || box2.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Box2: .clampPoint() target is now required");
      target2 = new Vector2();
    }
    return target2.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$8.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  intersect(box2) {
    this.min.max(box2.min);
    this.max.min(box2.max);
    return this;
  }
  union(box2) {
    this.min.min(box2.min);
    this.max.max(box2.max);
    return this;
  }
  translate(offset3) {
    this.min.add(offset3);
    this.max.add(offset3);
    return this;
  }
  equals(box2) {
    return box2.min.equals(this.min) && box2.max.equals(this.max);
  }
};
__name(Box2, "Box2");
Box2.prototype.isBox2 = true;
var _startP = /* @__PURE__ */ new Vector3();
var _startEnd = /* @__PURE__ */ new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Line3: .getCenter() target is now required");
      target2 = new Vector3();
    }
    return target2.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target2) {
    if (target2 === void 0) {
      console.warn("THREE.Line3: .delta() target is now required");
      target2 = new Vector3();
    }
    return target2.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t3, target2) {
    if (target2 === void 0) {
      console.warn("THREE.Line3: .at() target is now required");
      target2 = new Vector3();
    }
    return this.delta(target2).multiplyScalar(t3).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t3 = startEnd_startP / startEnd2;
    if (clampToLine) {
      t3 = MathUtils.clamp(t3, 0, 1);
    }
    return t3;
  }
  closestPointToPoint(point, clampToLine, target2) {
    const t3 = this.closestPointToPointParameter(point, clampToLine);
    if (target2 === void 0) {
      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
      target2 = new Vector3();
    }
    return this.delta(target2).multiplyScalar(t3).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
__name(Line3, "Line3");
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
__name(ImmediateRenderObject, "ImmediateRenderObject");
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
var _vector$a = /* @__PURE__ */ new Vector3();
var _boneMatrix = /* @__PURE__ */ new Matrix4();
var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors2 = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i3 = 0; i3 < bones.length; i3++) {
      const bone = bones[i3];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors2.push(color1.r, color1.g, color1.b);
        colors2.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true});
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i3 = 0, j3 = 0; i3 < bones.length; i3++) {
      const bone = bones[i3];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j3, _vector$a.x, _vector$a.y, _vector$a.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$a.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j3 + 1, _vector$a.x, _vector$a.y, _vector$a.z);
        j3 += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
__name(SkeletonHelper, "SkeletonHelper");
function getBoneList(object) {
  const boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (let i3 = 0; i3 < object.children.length; i3++) {
    boneList.push.apply(boneList, getBoneList(object.children[i3]));
  }
  return boneList;
}
__name(getBoneList, "getBoneList");
var GridHelper = class extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center2 = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors2 = [];
    for (let i3 = 0, j3 = 0, k3 = -halfSize; i3 <= divisions; i3++, k3 += step) {
      vertices.push(-halfSize, 0, k3, halfSize, 0, k3);
      vertices.push(k3, 0, -halfSize, k3, 0, halfSize);
      const color = i3 === center2 ? color1 : color2;
      color.toArray(colors2, j3);
      j3 += 3;
      color.toArray(colors2, j3);
      j3 += 3;
      color.toArray(colors2, j3);
      j3 += 3;
      color.toArray(colors2, j3);
      j3 += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});
    super(geometry, material);
    this.type = "GridHelper";
  }
};
__name(GridHelper, "GridHelper");
var _floatView = new Float32Array(1);
var _int32View = new Int32Array(_floatView.buffer);
var LOD_MIN = 4;
var LOD_MAX = 8;
var SIZE_MAX = Math.pow(2, LOD_MAX);
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
var ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};
var backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box2.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box2.prototype.empty = function() {
  console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box2.prototype.isIntersectionBox = function(box2) {
  console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box2);
};
Box2.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box2: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box2) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box2);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m3) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m3);
};
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
MathUtils.random16 = function() {
  console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
MathUtils.nearestPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
  return MathUtils.floorPowerOfTwo(value);
};
MathUtils.nextPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
  return MathUtils.ceilPowerOfTwo(value);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset3) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset3);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m3) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m3);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset3) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset3);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v3) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v3.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box2) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box2);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target2) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target2);
};
Triangle.prototype.midpoint = function(target2) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target2);
};
Triangle.prototypenormal = function(target2) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target2);
};
Triangle.prototype.plane = function(target2) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target2);
};
Triangle.barycoordFromPoint = function(point, a3, b3, c3, target2) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a3, b3, c3, target2);
};
Triangle.normal = function(a3, b3, c3, target2) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a3, b3, c3, target2);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options);
};
Shape.prototype.makeGeometry = function(options) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset3) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset3);
};
Vector2.prototype.distanceToManhattan = function(v3) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v3);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m3) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m3);
};
Vector3.prototype.getScaleFromMatrix = function(m3) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m3);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m3) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m3);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset3) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset3);
};
Vector3.prototype.distanceToManhattan = function(v3) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v3);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset3) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset3);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      return this.instanceCount;
    },
    set: function(value) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function() {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      return this.params.Line.threshold;
    },
    set: function(value) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function() {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function(value) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      this.setUsage(value);
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function() {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      return this.transmission;
    },
    set: function(value) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Object.defineProperties(Audio.prototype, {
  load: {
    value: function(file) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function() {
      console.warn("THREE.Audio: .startTime is now .play( delay ).");
    }
  }
});
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
    revision: REVISION
  }}));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
var BufferGeometryUtils = {
  computeTangents: function(geometry) {
    geometry.computeTangents();
    console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.");
  },
  mergeBufferGeometries: function(geometries, useGroups) {
    var isIndexed = geometries[0].index !== null;
    var attributesUsed = new Set(Object.keys(geometries[0].attributes));
    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
    var attributes = {};
    var morphAttributes = {};
    var morphTargetsRelative = geometries[0].morphTargetsRelative;
    var mergedGeometry = new BufferGeometry();
    var offset3 = 0;
    for (var i3 = 0; i3 < geometries.length; ++i3) {
      var geometry = geometries[i3];
      var attributesCount = 0;
      if (isIndexed !== (geometry.index !== null)) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i3 + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
        return null;
      }
      for (var name in geometry.attributes) {
        if (!attributesUsed.has(name)) {
          console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i3 + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
          return null;
        }
        if (attributes[name] === void 0)
          attributes[name] = [];
        attributes[name].push(geometry.attributes[name]);
        attributesCount++;
      }
      if (attributesCount !== attributesUsed.size) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i3 + ". Make sure all geometries have the same number of attributes.");
        return null;
      }
      if (morphTargetsRelative !== geometry.morphTargetsRelative) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i3 + ". .morphTargetsRelative must be consistent throughout all geometries.");
        return null;
      }
      for (var name in geometry.morphAttributes) {
        if (!morphAttributesUsed.has(name)) {
          console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i3 + ".  .morphAttributes must be consistent throughout all geometries.");
          return null;
        }
        if (morphAttributes[name] === void 0)
          morphAttributes[name] = [];
        morphAttributes[name].push(geometry.morphAttributes[name]);
      }
      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
      mergedGeometry.userData.mergedUserData.push(geometry.userData);
      if (useGroups) {
        var count;
        if (isIndexed) {
          count = geometry.index.count;
        } else if (geometry.attributes.position !== void 0) {
          count = geometry.attributes.position.count;
        } else {
          console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + i3 + ". The geometry must have either an index or a position attribute");
          return null;
        }
        mergedGeometry.addGroup(offset3, count, i3);
        offset3 += count;
      }
    }
    if (isIndexed) {
      var indexOffset = 0;
      var mergedIndex = [];
      for (var i3 = 0; i3 < geometries.length; ++i3) {
        var index = geometries[i3].index;
        for (var j3 = 0; j3 < index.count; ++j3) {
          mergedIndex.push(index.getX(j3) + indexOffset);
        }
        indexOffset += geometries[i3].attributes.position.count;
      }
      mergedGeometry.setIndex(mergedIndex);
    }
    for (var name in attributes) {
      var mergedAttribute = this.mergeBufferAttributes(attributes[name]);
      if (!mergedAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " attribute.");
        return null;
      }
      mergedGeometry.setAttribute(name, mergedAttribute);
    }
    for (var name in morphAttributes) {
      var numMorphTargets = morphAttributes[name][0].length;
      if (numMorphTargets === 0)
        break;
      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
      mergedGeometry.morphAttributes[name] = [];
      for (var i3 = 0; i3 < numMorphTargets; ++i3) {
        var morphAttributesToMerge = [];
        for (var j3 = 0; j3 < morphAttributes[name].length; ++j3) {
          morphAttributesToMerge.push(morphAttributes[name][j3][i3]);
        }
        var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);
        if (!mergedMorphAttribute) {
          console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + name + " morphAttribute.");
          return null;
        }
        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
      }
    }
    return mergedGeometry;
  },
  mergeBufferAttributes: function(attributes) {
    var TypedArray;
    var itemSize;
    var normalized;
    var arrayLength = 0;
    for (var i3 = 0; i3 < attributes.length; ++i3) {
      var attribute = attributes[i3];
      if (attribute.isInterleavedBufferAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");
        return null;
      }
      if (TypedArray === void 0)
        TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
        return null;
      }
      if (itemSize === void 0)
        itemSize = attribute.itemSize;
      if (itemSize !== attribute.itemSize) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
        return null;
      }
      if (normalized === void 0)
        normalized = attribute.normalized;
      if (normalized !== attribute.normalized) {
        console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
        return null;
      }
      arrayLength += attribute.array.length;
    }
    var array = new TypedArray(arrayLength);
    var offset3 = 0;
    for (var i3 = 0; i3 < attributes.length; ++i3) {
      array.set(attributes[i3].array, offset3);
      offset3 += attributes[i3].array.length;
    }
    return new BufferAttribute(array, itemSize, normalized);
  },
  interleaveAttributes: function(attributes) {
    var TypedArray;
    var arrayLength = 0;
    var stride = 0;
    for (var i3 = 0, l3 = attributes.length; i3 < l3; ++i3) {
      var attribute = attributes[i3];
      if (TypedArray === void 0)
        TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error("AttributeBuffers of different types cannot be interleaved");
        return null;
      }
      arrayLength += attribute.array.length;
      stride += attribute.itemSize;
    }
    var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);
    var offset3 = 0;
    var res = [];
    var getters = ["getX", "getY", "getZ", "getW"];
    var setters = ["setX", "setY", "setZ", "setW"];
    for (var j3 = 0, l3 = attributes.length; j3 < l3; j3++) {
      var attribute = attributes[j3];
      var itemSize = attribute.itemSize;
      var count = attribute.count;
      var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset3, attribute.normalized);
      res.push(iba);
      offset3 += itemSize;
      for (var c3 = 0; c3 < count; c3++) {
        for (var k3 = 0; k3 < itemSize; k3++) {
          iba[setters[k3]](c3, attribute[getters[k3]](c3));
        }
      }
    }
    return res;
  },
  estimateBytesUsed: function(geometry) {
    var mem = 0;
    for (var name in geometry.attributes) {
      var attr = geometry.getAttribute(name);
      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }
    var indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
  },
  mergeVertices: function(geometry, tolerance = 1e-4) {
    tolerance = Math.max(tolerance, Number.EPSILON);
    var hashToIndex = {};
    var indices = geometry.getIndex();
    var positions = geometry.getAttribute("position");
    var vertexCount = indices ? indices.count : positions.count;
    var nextIndex = 0;
    var attributeNames = Object.keys(geometry.attributes);
    var attrArrays = {};
    var morphAttrsArrays = {};
    var newIndices = [];
    var getters = ["getX", "getY", "getZ", "getW"];
    for (var i3 = 0, l3 = attributeNames.length; i3 < l3; i3++) {
      var name = attributeNames[i3];
      attrArrays[name] = [];
      var morphAttr = geometry.morphAttributes[name];
      if (morphAttr) {
        morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);
      }
    }
    var decimalShift = Math.log10(1 / tolerance);
    var shiftMultiplier = Math.pow(10, decimalShift);
    for (var i3 = 0; i3 < vertexCount; i3++) {
      var index = indices ? indices.getX(i3) : i3;
      var hash = "";
      for (var j3 = 0, l3 = attributeNames.length; j3 < l3; j3++) {
        var name = attributeNames[j3];
        var attribute = geometry.getAttribute(name);
        var itemSize = attribute.itemSize;
        for (var k3 = 0; k3 < itemSize; k3++) {
          hash += `${~~(attribute[getters[k3]](index) * shiftMultiplier)},`;
        }
      }
      if (hash in hashToIndex) {
        newIndices.push(hashToIndex[hash]);
      } else {
        for (var j3 = 0, l3 = attributeNames.length; j3 < l3; j3++) {
          var name = attributeNames[j3];
          var attribute = geometry.getAttribute(name);
          var morphAttr = geometry.morphAttributes[name];
          var itemSize = attribute.itemSize;
          var newarray = attrArrays[name];
          var newMorphArrays = morphAttrsArrays[name];
          for (var k3 = 0; k3 < itemSize; k3++) {
            var getterFunc = getters[k3];
            newarray.push(attribute[getterFunc](index));
            if (morphAttr) {
              for (var m3 = 0, ml = morphAttr.length; m3 < ml; m3++) {
                newMorphArrays[m3].push(morphAttr[m3][getterFunc](index));
              }
            }
          }
        }
        hashToIndex[hash] = nextIndex;
        newIndices.push(nextIndex);
        nextIndex++;
      }
    }
    const result = geometry.clone();
    for (var i3 = 0, l3 = attributeNames.length; i3 < l3; i3++) {
      var name = attributeNames[i3];
      var oldAttribute = geometry.getAttribute(name);
      var buffer = new oldAttribute.array.constructor(attrArrays[name]);
      var attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);
      result.setAttribute(name, attribute);
      if (name in morphAttrsArrays) {
        for (var j3 = 0; j3 < morphAttrsArrays[name].length; j3++) {
          var oldMorphAttribute = geometry.morphAttributes[name][j3];
          var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j3]);
          var morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
          result.morphAttributes[name][j3] = morphAttribute;
        }
      }
    }
    result.setIndex(newIndices);
    return result;
  },
  toTrianglesDrawMode: function(geometry, drawMode) {
    if (drawMode === TrianglesDrawMode) {
      console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
      return geometry;
    }
    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
      var index = geometry.getIndex();
      if (index === null) {
        var indices = [];
        var position = geometry.getAttribute("position");
        if (position !== void 0) {
          for (var i3 = 0; i3 < position.count; i3++) {
            indices.push(i3);
          }
          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
          return geometry;
        }
      }
      var numberOfTriangles = index.count - 2;
      var newIndices = [];
      if (drawMode === TriangleFanDrawMode) {
        for (var i3 = 1; i3 <= numberOfTriangles; i3++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(i3));
          newIndices.push(index.getX(i3 + 1));
        }
      } else {
        for (var i3 = 0; i3 < numberOfTriangles; i3++) {
          if (i3 % 2 === 0) {
            newIndices.push(index.getX(i3));
            newIndices.push(index.getX(i3 + 1));
            newIndices.push(index.getX(i3 + 2));
          } else {
            newIndices.push(index.getX(i3 + 2));
            newIndices.push(index.getX(i3 + 1));
            newIndices.push(index.getX(i3));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      }
      var newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      newGeometry.clearGroups();
      return newGeometry;
    } else {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
      return geometry;
    }
  },
  computeMorphedAttributes: function(object) {
    if (object.geometry.isBufferGeometry !== true) {
      console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.");
      return null;
    }
    var _vA2 = new Vector3();
    var _vB2 = new Vector3();
    var _vC2 = new Vector3();
    var _tempA2 = new Vector3();
    var _tempB2 = new Vector3();
    var _tempC2 = new Vector3();
    var _morphA2 = new Vector3();
    var _morphB2 = new Vector3();
    var _morphC2 = new Vector3();
    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a4, b4, c4, modifiedAttributeArray) {
      _vA2.fromBufferAttribute(attribute, a4);
      _vB2.fromBufferAttribute(attribute, b4);
      _vC2.fromBufferAttribute(attribute, c4);
      var morphInfluences = object2.morphTargetInfluences;
      if (material2.morphTargets && morphAttribute && morphInfluences) {
        _morphA2.set(0, 0, 0);
        _morphB2.set(0, 0, 0);
        _morphC2.set(0, 0, 0);
        for (var i4 = 0, il2 = morphAttribute.length; i4 < il2; i4++) {
          var influence = morphInfluences[i4];
          var morph = morphAttribute[i4];
          if (influence === 0)
            continue;
          _tempA2.fromBufferAttribute(morph, a4);
          _tempB2.fromBufferAttribute(morph, b4);
          _tempC2.fromBufferAttribute(morph, c4);
          if (morphTargetsRelative2) {
            _morphA2.addScaledVector(_tempA2, influence);
            _morphB2.addScaledVector(_tempB2, influence);
            _morphC2.addScaledVector(_tempC2, influence);
          } else {
            _morphA2.addScaledVector(_tempA2.sub(_vA2), influence);
            _morphB2.addScaledVector(_tempB2.sub(_vB2), influence);
            _morphC2.addScaledVector(_tempC2.sub(_vC2), influence);
          }
        }
        _vA2.add(_morphA2);
        _vB2.add(_morphB2);
        _vC2.add(_morphC2);
      }
      if (object2.isSkinnedMesh) {
        object2.boneTransform(a4, _vA2);
        object2.boneTransform(b4, _vB2);
        object2.boneTransform(c4, _vC2);
      }
      modifiedAttributeArray[a4 * 3 + 0] = _vA2.x;
      modifiedAttributeArray[a4 * 3 + 1] = _vA2.y;
      modifiedAttributeArray[a4 * 3 + 2] = _vA2.z;
      modifiedAttributeArray[b4 * 3 + 0] = _vB2.x;
      modifiedAttributeArray[b4 * 3 + 1] = _vB2.y;
      modifiedAttributeArray[b4 * 3 + 2] = _vB2.z;
      modifiedAttributeArray[c4 * 3 + 0] = _vC2.x;
      modifiedAttributeArray[c4 * 3 + 1] = _vC2.y;
      modifiedAttributeArray[c4 * 3 + 2] = _vC2.z;
    }
    __name(_calculateMorphedAttributeData, "_calculateMorphedAttributeData");
    var geometry = object.geometry;
    var material = object.material;
    var a3, b3, c3;
    var index = geometry.index;
    var positionAttribute = geometry.attributes.position;
    var morphPosition = geometry.morphAttributes.position;
    var morphTargetsRelative = geometry.morphTargetsRelative;
    var normalAttribute = geometry.attributes.normal;
    var morphNormal = geometry.morphAttributes.position;
    var groups = geometry.groups;
    var drawRange = geometry.drawRange;
    var i3, j3, il, jl;
    var group, groupMaterial;
    var start, end;
    var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
    var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
    if (index !== null) {
      if (Array.isArray(material)) {
        for (i3 = 0, il = groups.length; i3 < il; i3++) {
          group = groups[i3];
          groupMaterial = material[group.materialIndex];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j3 = start, jl = end; j3 < jl; j3 += 3) {
            a3 = index.getX(j3);
            b3 = index.getX(j3 + 1);
            c3 = index.getX(j3 + 2);
            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a3, b3, c3, modifiedPosition);
            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a3, b3, c3, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(index.count, drawRange.start + drawRange.count);
        for (i3 = start, il = end; i3 < il; i3 += 3) {
          a3 = index.getX(i3);
          b3 = index.getX(i3 + 1);
          c3 = index.getX(i3 + 2);
          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a3, b3, c3, modifiedPosition);
          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a3, b3, c3, modifiedNormal);
        }
      }
    } else if (positionAttribute !== void 0) {
      if (Array.isArray(material)) {
        for (i3 = 0, il = groups.length; i3 < il; i3++) {
          group = groups[i3];
          groupMaterial = material[group.materialIndex];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j3 = start, jl = end; j3 < jl; j3 += 3) {
            a3 = j3;
            b3 = j3 + 1;
            c3 = j3 + 2;
            _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a3, b3, c3, modifiedPosition);
            _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a3, b3, c3, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (i3 = start, il = end; i3 < il; i3 += 3) {
          a3 = i3;
          b3 = i3 + 1;
          c3 = i3 + 2;
          _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a3, b3, c3, modifiedPosition);
          _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a3, b3, c3, modifiedNormal);
        }
      }
    }
    var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);
    var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);
    return {
      positionAttribute,
      normalAttribute,
      morphedPositionAttribute,
      morphedNormalAttribute
    };
  }
};

// node_modules/notextures/dist/index.js
var __defProp2 = Object.defineProperty;
var __export2 = /* @__PURE__ */ __name((target2, all) => {
  for (var name in all)
    __defProp2(target2, name, {get: all[name], enumerable: true});
}, "__export");
var materials_exports = {};
__export2(materials_exports, {
  faceColorMaterial: () => faceColorMaterial,
  waterMaterial: () => waterMaterial
});
var faceColorMaterial = new MeshPhongMaterial({
  vertexColors: true,
  flatShading: true
});
var waterMaterial = new MeshPhongMaterial({
  color: 1581456,
  flatShading: true,
  opacity: 0.5,
  transparent: true
});
var LordaeronSummerRock = {
  name: "Lordaeron Summer Rock",
  color: "#876b62"
};
var LordaeronSummerGrass = {
  name: "Lordaeron Summer Grass",
  color: "#0c4013"
};
var LordaeronSummerDarkGrass = {
  name: "Lordaeron Summer Dark Grass",
  color: "#043609"
};
var LordaeronSummerDirtCliff = {
  name: "Lordaeron Summer Dirt Cliff",
  color: "#2f373f"
};
var objects_exports = {};
__export2(objects_exports, {
  Barn: () => Barn,
  BrokenHayCart: () => BrokenHayCart,
  BrokenWheelbarrow: () => BrokenWheelbarrow,
  Fence: () => Fence,
  Grid: () => Grid,
  HayCart: () => HayCart,
  PileOfJunk: () => PileOfJunk,
  PineTree: () => PineTree,
  RockChunks: () => RockChunks,
  ScorchedBarn: () => ScorchedBarn,
  Terrain: () => Terrain,
  Trough: () => Trough,
  cliffMap: () => cliffMap,
  stringMap: () => stringMap
});
var wood = new Color(3876103);
var stone = new Color(5858662);
var cloth = new Color(4796691);
var rope = new Color(4990997);
var steel = new Color(14738917);
var water = new Color(1581456);
var getVertexCount = /* @__PURE__ */ __name((geometry) => {
  const positions = geometry.getAttribute("position");
  return positions.count;
}, "getVertexCount");
var getColorAttribute = /* @__PURE__ */ __name((geometry) => {
  const existingAttribute = geometry.getAttribute("color");
  if (existingAttribute)
    return existingAttribute;
  const attribute = new BufferAttribute(new Float32Array(getVertexCount(geometry) * 3), 3);
  geometry.setAttribute("color", attribute);
  return attribute;
}, "getColorAttribute");
var colorFace = /* @__PURE__ */ __name((geometry, face, color) => {
  const colorAttribute = getColorAttribute(geometry);
  const vertexIdx = face * 3;
  colorAttribute.setXYZ(vertexIdx, color.r, color.g, color.b);
  colorAttribute.setXYZ(vertexIdx + 1, color.r, color.g, color.b);
  colorAttribute.setXYZ(vertexIdx + 2, color.r, color.g, color.b);
}, "colorFace");
var getFaceCount = /* @__PURE__ */ __name((geometry) => getVertexCount(geometry) / 3, "getFaceCount");
var Randomizer = /* @__PURE__ */ __name(class {
  constructor(geometry, builder) {
    this.geometry = geometry;
    this.builder = builder;
  }
  static flatSpread(value = 0, spread = 1 / 16) {
    return value + (Math.random() - 0.5) * 2 * spread;
  }
  static flatSpreader(spread = 1 / 16) {
    return (v3) => v3 + (Math.random() - 0.5) * 2 * spread;
  }
  static percentSpread(value, spread = 1 / 32) {
    return value * (1 + (Math.random() - 0.5) * 2 * spread);
  }
  static percentSpreader(spread = 1 / 32) {
    return (v3) => v3 * (1 + (Math.random() - 0.5) * 2 * spread);
  }
  static spread(value, flat = 1 / 16, percent = 1 / 32) {
    return (value + (Math.random() - 0.5) * 2 * flat) * (1 + (Math.random() - 0.5) * 2 * percent);
  }
  static spreader(flat = 1 / 16, percent = 1 / 32) {
    return (v3) => (v3 + (Math.random() - 0.5) * 2 * flat) * (1 + (Math.random() - 0.5) * 2 * percent);
  }
  static colorSpread(color, variation = this.flatSpreader(1 / 32)) {
    return new Color(variation(color.r), variation(color.g), variation(color.b));
  }
  static colorize(geometry, color, variation = this.spreader()) {
    color = this.colorSpread(color, variation);
    const vertices = getVertexCount(geometry);
    const colorAttribute = getColorAttribute(geometry);
    for (let i3 = 0; i3 < vertices; i3 += 3) {
      const vertexColor = this.colorSpread(color, variation);
      colorAttribute.setXYZ(i3, vertexColor.r, vertexColor.g, vertexColor.b);
      colorAttribute.setXYZ(i3 + 1, vertexColor.r, vertexColor.g, vertexColor.b);
      colorAttribute.setXYZ(i3 + 2, vertexColor.r, vertexColor.g, vertexColor.b);
    }
    return geometry;
  }
  colorize(color, variation) {
    Randomizer.colorize(this.geometry, color, variation);
    return this;
  }
  static translate(geometry, position, variation = this.spreader()) {
    return geometry.translate(variation(position?.x || 0), variation(position?.y || 0), variation(position?.z || 0));
  }
  translate(position, variation) {
    Randomizer.translate(this.geometry, position, variation);
    return this;
  }
  static blur(geometry, degree = 0.01) {
    geometry.computeBoundingBox();
    const positionAttribute = geometry.getAttribute("position");
    const vertexGroupsMap = [];
    for (let i3 = 0; i3 < positionAttribute.count; i3++) {
      const x3 = positionAttribute.getX(i3);
      if (!vertexGroupsMap[x3])
        vertexGroupsMap[x3] = [];
      const y3 = positionAttribute.getY(i3);
      if (!vertexGroupsMap[x3][y3])
        vertexGroupsMap[x3][y3] = [];
      const z2 = positionAttribute.getZ(i3);
      if (!vertexGroupsMap[x3][y3][z2])
        vertexGroupsMap[x3][y3][z2] = [];
      vertexGroupsMap[x3][y3][z2].push(i3);
    }
    const vertexGroups = Object.values(vertexGroupsMap).flatMap((v3) => Object.values(v3).flatMap((v22) => Object.values(v22)));
    for (const vertexGroup of vertexGroups) {
      const x3 = this.flatSpread(positionAttribute.getX(vertexGroup[0]), (geometry.boundingBox.max.x - geometry.boundingBox.min.x) * degree);
      const y3 = this.flatSpread(positionAttribute.getY(vertexGroup[0]), (geometry.boundingBox.max.y - geometry.boundingBox.min.y) * degree);
      const z2 = this.flatSpread(positionAttribute.getZ(vertexGroup[0]), (geometry.boundingBox.max.z - geometry.boundingBox.min.z) * degree);
      for (const idx of vertexGroup)
        positionAttribute.setXYZ(idx, x3, y3, z2);
    }
    return geometry;
  }
  blur(degree) {
    Randomizer.blur(this.geometry, degree);
    return this;
  }
  static rotate(geometry, rotation, variation = Randomizer.spread) {
    geometry.rotateX(variation(rotation.x));
    geometry.rotateY(variation(rotation.y));
    geometry.rotateZ(variation(rotation.z));
    return geometry;
  }
  rotate(rotation, variation) {
    Randomizer.rotate(this.geometry, rotation, variation);
    return this;
  }
  static scale(geometry, scale, variation = Randomizer.spread) {
    geometry.scale(variation(scale.x || 1), variation(scale.y || 1), variation(scale.z || 1));
    return geometry;
  }
  scale(scale, variation) {
    Randomizer.scale(this.geometry, scale, variation);
    return this;
  }
  static randomize(geometry, {
    colorize,
    translate,
    blur,
    rotate: rotate2
  } = {}) {
    if (colorize)
      this.colorize(geometry, colorize.color, colorize.variation);
    if (translate)
      this.translate(geometry, translate.position, translate.variation);
    if (blur)
      this.blur(geometry, blur);
    if (rotate2)
      this.rotate(geometry, rotate2.rotation, rotate2.variation);
    return geometry;
  }
}, "Randomizer");
var Randomizer_default = Randomizer;
var createBufferGeometry = /* @__PURE__ */ __name(() => {
  const geo = new BufferGeometry();
  geo.setAttribute("position", new BufferAttribute(new Float32Array(0), 3));
  geo.setAttribute("color", new BufferAttribute(new Float32Array(0), 3));
  geo.setAttribute("normal", new BufferAttribute(new Float32Array(0), 3));
  geo.setAttribute("uv", new BufferAttribute(new Float32Array(0), 2));
  return geo;
}, "createBufferGeometry");
var compose = /* @__PURE__ */ __name((fns) => {
  if (!fns || fns.length === 0)
    return;
  if (fns.length === 1)
    return fns[0];
  return (val) => {
    for (let i3 = 0; i3 < fns.length; i3++)
      val = fns[i3](val);
    return val;
  };
}, "compose");
var IDENTITY = /* @__PURE__ */ __name((v3) => v3, "IDENTITY");
var LEFT = new Vector2(-1, 0);
var Builder = /* @__PURE__ */ __name(class {
  constructor(geometry, parent) {
    if (geometry && geometry.index)
      geometry = geometry.toNonIndexed();
    this._geometry = geometry;
    this.parent = parent;
    this.children = [];
  }
  group() {
    const group = new Builder(void 0, this);
    this.children.push(group);
    return group;
  }
  box(...args) {
    const box2 = new Builder(new BoxGeometry(...args), this);
    this.children.push(box2);
    return box2;
  }
  cone(...args) {
    const cone = new Builder(new ConeGeometry(...args), this);
    this.children.push(cone);
    return cone;
  }
  cylinder(...args) {
    const cylinder2 = new Builder(new CylinderGeometry(...args), this);
    this.children.push(cylinder2);
    return cylinder2;
  }
  octahedron(...args) {
    const octahedron = new Builder(new OctahedronGeometry(...args), this);
    this.children.push(octahedron);
    return octahedron;
  }
  sphere(...args) {
    const sphere = new Builder(new SphereGeometry(...args), this);
    this.children.push(sphere);
    return sphere;
  }
  tetrahedron(...args) {
    const tetrahedron2 = new Builder(new TetrahedronGeometry(...args), this);
    this.children.push(tetrahedron2);
    return tetrahedron2;
  }
  tube(...args) {
    const tube = new Builder(new TubeGeometry(...args), this);
    this.children.push(tube);
    return tube;
  }
  lathe(...args) {
    const lathe = new Builder(new LatheGeometry(...args), this);
    this.children.push(lathe);
    return lathe;
  }
  thickLathe(points, thickness = 1 / 32, direction = LEFT, ...rest) {
    const adjustment = direction.clone().multiplyScalar(thickness);
    const allPoints = [
      ...points,
      ...[...points].reverse().map((p3) => p3.clone().add(adjustment)),
      points[0]
    ];
    return this.lathe(allPoints, ...rest);
  }
  color(color, variation) {
    this._color = color;
    if (variation)
      if (this._colorVariation)
        this._colorVariation.push(variation);
      else
        this._colorVariation = [variation];
    return this;
  }
  translate(x3 = 0, y3 = 0, z2 = 0, variation) {
    const position = new Vector3(x3, y3, z2);
    this._position = this._position ? this._position.add(position) : position;
    if (variation)
      if (this._positionVariation)
        this._positionVariation.push(variation);
      else
        this._positionVariation = [variation];
    return this;
  }
  translateX(x3) {
    if (this._position)
      this._position.x += x3;
    else
      this._position = new Vector3(x3, 0, 0);
    return this;
  }
  translateY(y3) {
    if (this._position)
      this._position.y += y3;
    else
      this._position = new Vector3(0, y3, 0);
    return this;
  }
  translateZ(z2) {
    if (this._position)
      this._position.z += z2;
    else
      this._position = new Vector3(0, 0, z2);
    return this;
  }
  rotate(x3, y3, z2, variation) {
    if (x3 === void 0)
      return this;
    const rotation = new Vector3(x3 ?? 0, y3 ?? 0, z2 ?? 0);
    this._rotation = this._rotation ? this._rotation.add(rotation) : rotation;
    if (variation)
      if (this._rotationVariation)
        this._rotationVariation.push(variation);
      else
        this._rotationVariation = [variation];
    return this;
  }
  rotateX(x3) {
    if (this._rotation)
      this._rotation.x += x3;
    else
      this._rotation = new Vector3(x3, 0, 0);
    return this;
  }
  rotateY(y3) {
    if (this._rotation)
      this._rotation.y += y3;
    else
      this._rotation = new Vector3(0, y3, 0);
    return this;
  }
  rotateZ(z2) {
    if (this._rotation)
      this._rotation.z += z2;
    else
      this._rotation = new Vector3(0, 0, z2);
    return this;
  }
  scale(x3, y3, z2, variation) {
    const scale = new Vector3(x3, y3, z2);
    if (this._scale)
      this._scale.multiply(scale);
    else
      this._scale = scale;
    if (variation)
      if (this._scaleVariation)
        this._scaleVariation.push(variation);
      else
        this._scaleVariation = [variation];
    return this;
  }
  scaleX(x3) {
    if (this._scale)
      this._scale.x += x3;
    else
      this._scale = new Vector3(x3, 0, 0);
    return this;
  }
  scaleY(y3) {
    if (this._scale)
      this._scale.y += y3;
    else
      this._scale = new Vector3(0, y3, 0);
    return this;
  }
  scaleZ(z2) {
    if (this._scale)
      this._scale.z += z2;
    else
      this._scale = new Vector3(0, 0, z2);
    return this;
  }
  randomize(props = {
    color: Randomizer_default.flatSpreader(1 / 24),
    position: Randomizer_default.percentSpreader(),
    rotation: Randomizer_default.flatSpreader(),
    scale: Randomizer_default.percentSpreader(),
    blur: 0.01
  }) {
    let color, position, rotation, scale, blur;
    if (typeof props === "number") {
      color = Randomizer_default.flatSpreader(1 / 24 * props);
      position = Randomizer_default.percentSpreader(1 / 32 * props);
      rotation = Randomizer_default.flatSpreader(1 / 16 * props);
      blur = 0.01 * props;
    } else
      ({color, position, rotation, scale, blur} = props);
    if (color) {
      if (typeof color === "number")
        color = Randomizer_default.flatSpreader(color);
      if (this._colorVariation)
        this._colorVariation.push(color);
      else
        this._colorVariation = [color];
    }
    if (position) {
      if (typeof position === "number")
        position = Randomizer_default.percentSpreader(position);
      if (this._positionVariation)
        this._positionVariation.push(position);
      else
        this._positionVariation = [position];
    }
    if (rotation) {
      if (typeof rotation === "number")
        rotation = Randomizer_default.flatSpreader(rotation);
      if (this._rotationVariation)
        this._rotationVariation.push(rotation);
      else
        this._rotationVariation = [rotation];
    }
    if (scale) {
      if (typeof scale === "number")
        scale = Randomizer_default.percentSpreader(scale);
      if (this._scaleVariation)
        this._scaleVariation.push(scale);
      else
        this._scaleVariation = [scale];
    }
    return this.blur(blur);
  }
  blur(degree = 0.01) {
    this._blur = (this._blur || 0) + degree;
    return this;
  }
  repeat(count, fn) {
    const mid = (count - 1) / 2;
    for (let i3 = 0; i3 < count; i3++)
      fn(this, i3 - mid, mid - Math.abs(i3 - mid), mid, i3, count);
    return this;
  }
  for(count, fn) {
    const mid = (count - 1) / 2;
    for (let i3 = 0; i3 < count; i3++)
      fn(this, i3, count, i3 - mid, mid - Math.abs(i3 - mid), mid);
    return this;
  }
  do(fn) {
    fn(this);
    return this;
  }
  map(fn, centered = true) {
    const mid = (this.children.length - 1) / 2;
    if (centered)
      for (let i3 = 0; i3 < this.children.length; i3++)
        fn(this.children[i3], i3 - mid, mid - Math.abs(i3 - mid), mid, i3, this.children.length);
    else
      for (let i3 = 0; i3 < this.children.length; i3++)
        fn(this.children[i3], i3, this.children.length, i3 - mid, mid - Math.abs(i3 - mid), mid);
    return this;
  }
  add(builder) {
    this.children.push(builder);
    return this;
  }
  root() {
    let cur = this;
    while (cur.parent)
      cur = cur.parent;
    return cur;
  }
  geometry() {
    let geometry = this._geometry ? this._geometry.clone() : createBufferGeometry();
    if (this.children.length)
      geometry = BufferGeometryUtils.mergeBufferGeometries([
        geometry,
        ...this.children.map((c3) => {
          const geo = c3.geometry();
          getColorAttribute(geo);
          return geo;
        })
      ]);
    if (this._color)
      Randomizer_default.colorize(geometry, this._color, compose(this._colorVariation) ?? IDENTITY);
    if (this._rotation || this._rotationVariation)
      Randomizer_default.rotate(geometry, this._rotation ?? new Vector3(0, 0, 0), compose(this._rotationVariation) ?? IDENTITY);
    if (this._position || this._positionVariation)
      Randomizer_default.translate(geometry, this._position, compose(this._positionVariation) ?? IDENTITY);
    if (this._scale || this._scaleVariation)
      Randomizer_default.scale(geometry, this._scale ?? new Vector3(1, 1, 1), compose(this._scaleVariation) ?? IDENTITY);
    if (this._blur)
      Randomizer_default.blur(geometry, this._blur);
    return geometry;
  }
  mesh() {
    return new Mesh(this.geometry(), faceColorMaterial);
  }
}, "Builder");
var Builder_default = Builder;
var Barn = /* @__PURE__ */ __name(class extends Mesh {
  constructor() {
    const color = Randomizer_default.colorSpread(wood);
    const paneling = color.clone();
    const roof = color.clone().offsetHSL(0, -0.05, 0.05);
    const door = color.clone().offsetHSL(0, 0.1, -0.1);
    const length = 15;
    const width = 11;
    const thickness = 1 / 32;
    const geometry = new Builder_default().repeat(2, (b3, y3) => b3.repeat(width, (b22, x3, _0, mid) => {
      const angle = Math.acos(x3 / mid);
      const height = 1 / 2 + Math.sin(angle) * 8 / length;
      return b22.box(1 / 8, thickness, height).translate(x3 / 8, y3 * length / 8, height / 2).color(paneling).randomize(1 / 2);
    })).repeat(2, (b3, x3) => b3.repeat(length, (b22, y3) => b22.box(thickness, 1 / 8, 1 / 2).translate(x3 * width / 8, y3 / 8, 1 / 4).color(paneling).randomize())).repeat(width, (b3, x3, _0, mid) => b3.repeat(length + 1, (b22, y3) => {
      const width2 = Math.PI / 2 * x3 / mid;
      return b22.box(thickness, 1 / 8, (1 / 8 + thickness) * Math.PI / 2).translate(Math.sin(width2) * ((mid + 0.5) / 8 + thickness), y3 / 8, 1 / 4 + 2 * thickness + Math.abs(Math.cos(width2) * ((mid + 0.5) / 8 + thickness))).rotateY(-Math.acos(Math.sin(width2))).color(roof).randomize();
    })).box(1 / 2, thickness, 3 / 4).translate(0, -length / 2 / 8 - thickness / 2, 3 / 8).color(door).randomize().parent.rotateZ(-Math.PI / 4).geometry();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "Barn");
var HAY = new Color("#e4d96f");
var BrokenHayCart = /* @__PURE__ */ __name(class extends Mesh {
  constructor() {
    const color = Randomizer_default.colorSpread(wood);
    const wheels = Randomizer_default.colorSpread(color);
    const axis = Randomizer_default.colorSpread(color);
    const basket = Randomizer_default.colorSpread(color);
    const hay = Randomizer_default.colorSpread(HAY);
    const brokenWheel = -0.5;
    let geometry = new Builder_default().repeat(2, (b3, x3) => {
      const wheel = b3.cylinder(1 / 4, 1 / 4, 1 / 16).translate(x3, 0, 7 / 32).rotateZ(Math.PI / 2).color(wheels);
      if (x3 === brokenWheel) {
        wheel.rotateX(Math.PI / 2);
        1 + 1;
        wheel.translateZ(-6 / 32);
      }
    }).cylinder(1 / 32, 1 / 32, 1).rotateZ(Math.PI / 2).translateZ(7 / 32).color(axis).parent.box(1 / 2, 1 / 2, 1 / 32).translateZ(1 / 4).color(basket).parent.thickLathe([
      new Vector2(2 / 4 / Math.SQRT2, 1 / 4 / Math.SQRT2 + 1 / 16),
      new Vector2(3 / 4 / Math.SQRT2, 1 / 2 / Math.SQRT2 + 1 / 16)
    ], 1 / 32, new Vector2(-1, 0), 4, Math.PI / 4).rotateX(Math.PI / 2).color(basket).parent.repeat(2, (b3, x3) => b3.cylinder(1 / 64, 1 / 64, 1).translate(x3 * 47 / 64, -1 / 8, 1 / 2 - 1 / 16 - 1 / 64).rotate(...x3 === brokenWheel ? [
      Randomizer_default.flatSpread(0, 1 / 5),
      Randomizer_default.flatSpread(0, 1 / 5),
      Randomizer_default.flatSpread(0, 1 / 5)
    ] : []).color(axis)).root().rotateY(brokenWheel < 0 ? -Math.PI / 8 : Math.PI / 8).rotateX(Math.PI / 8).randomize().geometry();
    geometry = BufferGeometryUtils.mergeBufferGeometries([
      geometry,
      new Builder_default().for(3, (b3, z2) => b3.sphere(1 / 3 - z2 / 24, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2).rotateX(Math.PI / 2).translate(Randomizer_default.flatSpread(-5 / 16, 1 / 4), Randomizer_default.flatSpread(-5 / 16, 1 / 4)).color(hay)).root().randomize().geometry()
    ]);
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "BrokenHayCart");
var nudge = Randomizer_default.spreader(1 / 16, 1 / 4);
var colorNudge = Randomizer_default.spreader(0, 1 / 24);
var randColor = /* @__PURE__ */ __name((color, colorVariation = colorNudge) => new Color(colorVariation(color.r), colorVariation(color.g), colorVariation(color.b)), "randColor");
var randomizeColor = /* @__PURE__ */ __name((geometry, color, colorVariation) => {
  const positionAttribute = geometry.getAttribute("position");
  const positions = positionAttribute.count;
  const colorAttribute = getColorAttribute(geometry);
  color = randColor(color, colorVariation);
  for (let i3 = 0; i3 < positions; i3 += 3) {
    const vertexColor = randColor(color, colorVariation);
    colorAttribute.setXYZ(i3, vertexColor.r, vertexColor.g, vertexColor.b);
    colorAttribute.setXYZ(i3 + 1, vertexColor.r, vertexColor.g, vertexColor.b);
    colorAttribute.setXYZ(i3 + 2, vertexColor.r, vertexColor.g, vertexColor.b);
  }
  return geometry;
}, "randomizeColor");
var randomize = /* @__PURE__ */ __name((geometry, {
  color,
  vertexVariation
}) => {
  if (color)
    randomizeColor(geometry, color);
  if (vertexVariation)
    Randomizer_default.blur(geometry, vertexVariation);
  const positionVariation = nudge;
  geometry.position = new Vector3(positionVariation(0), positionVariation(0), positionVariation(0));
  return geometry;
}, "randomize");
var cylinder = /* @__PURE__ */ __name(({
  length,
  radius,
  color
}) => randomize(new CylinderGeometry(radius * (1 + MathUtils.randFloatSpread(radius / 16)), radius * (1 + MathUtils.randFloatSpread(radius / 16)), length * (1 + MathUtils.randFloatSpread(length / 16))).toNonIndexed(), {color}), "cylinder");
var box = /* @__PURE__ */ __name(({
  width,
  height,
  depth,
  color
}) => randomize(new BoxGeometry(width, height, depth).toNonIndexed(), {color}), "box");
var tetrahedron = /* @__PURE__ */ __name(({
  radius,
  detail,
  color,
  vertexVariation
}) => randomize(new TetrahedronGeometry(radius, detail).toNonIndexed(), {
  color,
  vertexVariation
}), "tetrahedron");
var dodecahedron = /* @__PURE__ */ __name(({
  radius,
  vertexVariation,
  color
}) => randomize(new DodecahedronGeometry(radius).toNonIndexed(), {
  vertexVariation,
  color
}), "dodecahedron");
var BrokenWheelbarrow = /* @__PURE__ */ __name(class extends Mesh {
  constructor({
    color: inColor,
    colorVariation = nudge
  } = {}) {
    const color = inColor ?? randColor(wood, colorVariation);
    const wheel = /* @__PURE__ */ __name((x3) => cylinder({length: 1 / 16, radius: 1 / 4, color: randColor(color)}).rotateX(nudge(Math.PI / 2)).translate(nudge(x3), nudge(1 / 2), 1 / 64), "wheel");
    const leftWheel = wheel(-3 / 5);
    const rightWheel = wheel(3 / 5);
    const corner = /* @__PURE__ */ __name((x3, y3) => box({
      width: 1 / 16,
      height: 1 / 2,
      depth: 2 / 16,
      color: randColor(color)
    }).rotateX(Math.PI / 2).translate(x3, y3, 1 / 4), "corner");
    const leftCorner = corner(-3 / 8, 1 / 2);
    const rightCorner = corner(3 / 8, 1 / 2);
    const support = /* @__PURE__ */ __name((x3) => box({
      width: 1 / 16,
      height: 1 / 2,
      depth: 1 / 16,
      color: randColor(color)
    }).rotateX(Math.PI / 2).translate(x3, 0, 1 / 4), "support");
    const leftSupport = support(-3 / 8);
    const rightSupport = support(3 / 8);
    const plank = /* @__PURE__ */ __name((x3 = 0, long = true) => box({
      width: 2 / 16,
      height: long ? 1 : 3 / 4,
      depth: 1 / 16,
      color: randColor(color)
    }).rotateZ(MathUtils.randFloatSpread(1 / 12)).translate(x3, 0, 0), "plank");
    const bottomPlank1 = plank(-3 / 9);
    const bottomPlank2 = plank(-1 / 9);
    const bottomPlank3 = plank(1 / 9);
    const bottomPlank4 = plank(3 / 9);
    const leftSide1 = plank().rotateY(Math.PI / 2).translate(-3 / 9, 0, 3 / 16);
    const leftSide2 = plank().rotateY(Math.PI / 2).translate(-3 / 9, 0, 7 / 16);
    const rightSide1 = plank().rotateY(Math.PI / 2).translate(3 / 9, 0, 3 / 16);
    const rightSide2 = plank().rotateY(Math.PI / 2).translate(3 / 9, 0, 7 / 16);
    const frontSide = plank(0, false).rotateY(Math.PI / 2).rotateZ(Math.PI / 2).translate(0, 1 / 2, 0);
    const backSide1 = plank(0, false).rotateY(Math.PI / 2).rotateZ(Math.PI / 2).translate(0, 1 / 2, 7 / 32);
    const backSide2 = plank(0, false).rotateY(Math.PI / 2).rotateZ(Math.PI / 2).translate(0, 1 / 2, 14 / 32);
    const back1 = plank(0, false).rotateY(Math.PI / 2).rotateZ(Math.PI / 2).translate(0, -1 / 2, 0);
    const back2 = plank(0, false).rotateY(Math.PI / 2).rotateZ(Math.PI / 2).translate(0, -1 / 2, 7 / 32);
    const back3 = plank(0, false).rotateY(Math.PI / 2).rotateZ(Math.PI / 2).translate(0, -1 / 2, 14 / 32);
    const back4 = corner(-3 / 8, -1 / 2);
    const back5 = corner(3 / 8, -1 / 2);
    const back = BufferGeometryUtils.mergeBufferGeometries([
      back1,
      back2,
      back3,
      back4,
      back5
    ]);
    back.center().rotateX(Math.PI / 2).rotateZ(Math.PI / 4).translate(1 / 4, -7 / 8, 0);
    const handles = /* @__PURE__ */ __name((x3) => box({
      width: 1 / 16,
      height: 3 / 4,
      depth: 1 / 16,
      color: randColor(color)
    }).translate(x3, -1 / 2 - 3 / 4 / 2, 0), "handles");
    const handle1 = handles(-3 / 8);
    const handle2 = handles(3 / 8);
    const geometry = BufferGeometryUtils.mergeBufferGeometries([
      leftWheel,
      rightWheel,
      leftCorner,
      rightCorner,
      leftSupport,
      rightSupport,
      bottomPlank1,
      bottomPlank2,
      bottomPlank3,
      bottomPlank4,
      leftSide1,
      leftSide2,
      rightSide1,
      rightSide2,
      frontSide,
      backSide1,
      backSide2,
      handle1,
      handle2,
      back
    ]);
    geometry.computeVertexNormals();
    geometry.rotateZ(Randomizer_default.flatSpread(Math.PI / 2, Math.PI / 16));
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "BrokenWheelbarrow");
var createPost = /* @__PURE__ */ __name(({
  height,
  width,
  color
}) => {
  const post = new CylinderGeometry(width + Math.random() / 24, width + Math.random() / 24, height + Math.random() / 16).toNonIndexed();
  const faces = getFaceCount(post);
  for (let i3 = 0; i3 < faces; i3++)
    colorFace(post, i3, color.clone().offsetHSL(MathUtils.randFloatSpread(1 / 36), 0, 0));
  post.rotateX(Math.PI / 2 + (Math.random() - 0.5) / 6);
  post.rotateZ(Math.PI * Math.random());
  post.rotateY((Math.random() - 0.5) / 16);
  post.translate(0, 0, height / 2);
  return post;
}, "createPost");
var createPosts = /* @__PURE__ */ __name(({
  length,
  width,
  height,
  angle,
  color
}) => {
  const postDisplacement = length / 2 - Math.random() / 16;
  const leftPost = createPost({height, width, color});
  leftPost.translate(Math.cos(angle + Math.PI / 2) * -postDisplacement, Math.sin(angle + Math.PI / 2) * -postDisplacement, 0);
  const rightPost = createPost({height, width, color});
  rightPost.translate(Math.cos(angle + Math.PI / 2) * postDisplacement, Math.sin(angle + Math.PI / 2) * postDisplacement, 0);
  return [leftPost, rightPost];
}, "createPosts");
var createRail = /* @__PURE__ */ __name(({
  width,
  length,
  color
}) => {
  const rail = new CylinderGeometry(width + Math.random() / 24, width + Math.random() / 24, length + width + Math.random() / 4).toNonIndexed();
  const faces = getFaceCount(rail);
  for (let i3 = 0; i3 < faces; i3++)
    colorFace(rail, i3, color.clone().offsetHSL(MathUtils.randFloatSpread(1 / 36), 0, 0));
  rail.rotateY(Math.PI * Math.random());
  rail.rotateX((Math.random() - 0.5) / 4 / length);
  return rail;
}, "createRail");
var createRails = /* @__PURE__ */ __name(({
  length,
  height,
  width,
  angle,
  color
}) => {
  const topRail = createRail({width, length, color});
  topRail.translate(0, 0, height / 3);
  topRail.rotateZ(angle);
  const bottomRail = createRail({width, length, color});
  bottomRail.translate(0, 0, height / 3 * 2);
  bottomRail.rotateZ(angle);
  return [topRail, bottomRail];
}, "createRails");
var Fence = /* @__PURE__ */ __name(class extends Mesh {
  constructor({
    length = 2 - 1 / 4,
    width = 1 / 24,
    height = 1 / 2,
    angle = 0,
    color = wood.clone().offsetHSL(MathUtils.randFloatSpread(1 / 36), 0, 0)
  } = {}) {
    const geometry = BufferGeometryUtils.mergeBufferGeometries([
      ...createPosts({length, width, height, angle, color}),
      ...createRails({length, width, height, angle, color})
    ]);
    geometry.computeVertexNormals();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "Fence");
var _ColorAttribute = /* @__PURE__ */ __name(class extends BufferAttribute {
  constructor(faces) {
    const data = new Float32Array(faces * _ColorAttribute.COMPONNETS_PER_COLOR * _ColorAttribute.VERTICES_PER_FACE);
    super(data, _ColorAttribute.ITEM_SIZE);
    this.data = data;
  }
  setFace(index, red, blue, green) {
    const base = index * _ColorAttribute.COMPONNETS_PER_COLOR * _ColorAttribute.VERTICES_PER_FACE;
    for (let i3 = 0; i3 < _ColorAttribute.VERTICES_PER_FACE; i3++) {
      this.data[base + i3 * _ColorAttribute.VERTICES_PER_FACE] = red;
      this.data[base + i3 * _ColorAttribute.VERTICES_PER_FACE + 1] = blue;
      this.data[base + i3 * _ColorAttribute.VERTICES_PER_FACE + 2] = green;
    }
    this.needsUpdate = true;
  }
}, "_ColorAttribute");
var ColorAttribute = _ColorAttribute;
ColorAttribute.COMPONNETS_PER_COLOR = 3;
ColorAttribute.VERTICES_PER_FACE = 3;
ColorAttribute.ITEM_SIZE = 3;
var SquareColorAttribute = /* @__PURE__ */ __name(class extends ColorAttribute {
  constructor(faces) {
    super(faces * 2);
  }
  setFaces(index, red, blue, green) {
    super.setFace(index * 2, red, blue, green);
    super.setFace(index * 2 + 1, red, blue, green);
  }
}, "SquareColorAttribute");
var GridColorAttribute = /* @__PURE__ */ __name(class extends SquareColorAttribute {
  constructor(width, height) {
    super(width * height);
    this.width = width;
    this.height = height;
  }
  setColor(x3, y3, red, blue, green) {
    super.setFaces(y3 * this.width + x3, red, blue, green);
  }
}, "GridColorAttribute");
var Grid = /* @__PURE__ */ __name(class extends Mesh {
  constructor(width = 1, height = 1) {
    const plane = new PlaneGeometry(width, height, width, height).toNonIndexed();
    const colors2 = new GridColorAttribute(width, height);
    plane.setAttribute("color", colors2);
    super(plane, faceColorMaterial);
    this.colors = colors2;
  }
  setColor(x3, y3, red, blue, green) {
    this.colors.setColor(x3, y3, red, blue, green);
  }
}, "Grid");
var HAY2 = new Color("#e4d96f");
var HayCart = /* @__PURE__ */ __name(class extends Mesh {
  constructor() {
    const color = Randomizer_default.colorSpread(wood);
    const wheels = Randomizer_default.colorSpread(color);
    const axis = Randomizer_default.colorSpread(color);
    const basket = Randomizer_default.colorSpread(color);
    const hay = Randomizer_default.colorSpread(HAY2);
    const geometry = new Builder_default().repeat(2, (b3, x3) => b3.cylinder(1 / 4, 1 / 4, 1 / 16).translate(x3, 0, 7 / 32).rotateZ(Math.PI / 2).color(wheels)).cylinder(1 / 32, 1 / 32, 1).rotateZ(Math.PI / 2).translateZ(7 / 32).color(axis).parent.box(1 / 2, 1 / 2, 1 / 32).translateZ(1 / 4).color(basket).parent.thickLathe([
      new Vector2(2 / 4 / Math.SQRT2, 1 / 4 / Math.SQRT2 + 1 / 16),
      new Vector2(3 / 4 / Math.SQRT2, 1 / 2 / Math.SQRT2 + 1 / 16)
    ], 1 / 32, new Vector2(-1, 0), 4, Math.PI / 4).rotateX(Math.PI / 2).color(basket).parent.repeat(2, (b3, x3) => b3.cylinder(1 / 64, 1 / 64, 1).translate(x3 * 47 / 64, -1 / 8, 1 / 2 - 1 / 16 - 1 / 64).color(axis)).for(3, (b3, z2) => b3.sphere(1 / 3 - z2 / 24, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2).rotateX(Math.PI / 2).translateZ(1 / 4 + Array(z2).fill(0).reduce((sum, _2, i3) => sum + (1 / 3 - i3 / 24) / 2, 0)).color(hay)).root().randomize().geometry();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "HayCart");
var nearPoint = /* @__PURE__ */ __name((objects, min) => {
  let spread = min;
  while (spread < Infinity) {
    const newPoint = new Vector2(MathUtils.randFloatSpread(spread), MathUtils.randFloatSpread(spread));
    if (objects.length === 0)
      return newPoint;
    else {
      const minDistObject = objects.reduce((min2, test) => newPoint.distanceTo(test.point) - min2.radius - test.radius < newPoint.distanceTo(min2.point) - min2.radius - test.radius ? test : min2, {point: new Vector2(Infinity, Infinity), radius: 0});
      if (minDistObject.point.distanceTo(newPoint) - minDistObject.radius - min > min)
        return newPoint;
      spread *= 1.05;
    }
  }
}, "nearPoint");
var spear = {
  radius: 1 / 128,
  builder: (b3) => b3.cylinder(1 / 96, 1 / 96, 17 / 16).translateY(17 / 32).color(Randomizer_default.colorSpread(wood)).blur(0.01).parent.octahedron(1 / 32).scale(4 / 7, 0, 2 / 5).translateY(17 / 16).color(Randomizer_default.colorSpread(stone)).blur(0.01).parent.rotate(MathUtils.randFloatSpread(1 / 8), MathUtils.randFloatSpread(1 / 8), MathUtils.randFloatSpread(1 / 8))
};
var shortSpear = {
  radius: 1 / 128,
  builder: (b3) => b3.cylinder(1 / 96, 1 / 96, 15 / 16).translateY(15 / 32).color(Randomizer_default.colorSpread(wood)).blur(0.01).parent.octahedron(1 / 32).scale(4 / 7, 0, 2 / 5).translateY(15 / 16).color(Randomizer_default.colorSpread(stone)).blur(0.01).parent.rotate(MathUtils.randFloatSpread(1 / 8), MathUtils.randFloatSpread(1 / 8), MathUtils.randFloatSpread(1 / 8))
};
var Helix = /* @__PURE__ */ __name(class extends Curve {
  constructor(length = Math.PI * 4, height = 2, bottomRadius = 1, topRadius = bottomRadius) {
    super();
    this.length = length;
    this.height = height;
    this.bottomRadius = bottomRadius;
    this.topRadius = topRadius;
  }
  getPoint(t3) {
    const lerp = MathUtils.lerp(this.bottomRadius, this.topRadius, t3);
    return new Vector3(Math.cos(t3 * this.length) * lerp, Math.sin(t3 * this.length) * lerp, t3 * this.height);
  }
}, "Helix");
var sword = {
  radius: 1 / 96,
  builder: (b3) => b3.cylinder(1 / 96, 1 / 96, 15 / 16).scale(2, 1, 1 / 4).translateY(15 / 32).color(steel).parent.cone(1 / 96, 2 / 96).translateY(30 / 32 + 2 / 96 / 2).scale(2, 1, 1 / 4).color(steel).parent.cylinder(1 / 96, 1 / 96, 1 / 8).rotateZ(Math.PI / 2).color(wood).parent.cylinder(1 / 64 / 4, 1 / 96, 1 / 8).color(steel).parent.tube(new Helix(Math.PI * 64, 1 / 16, 1 / 128, 1 / 96), 256, 1 / 1024).rotateX(Math.PI / 2).color(rope).parent.rotateZ(Math.PI).translateY(30 / 32 + 2 / 96).rotateY(Math.PI * Math.random())
};
var vaseContentTypes = [spear, shortSpear, sword];
var vase = {
  radius: 1 / 8,
  builder: (b3) => {
    const count = MathUtils.randInt(0, 3);
    const objects = [];
    return b3.thickLathe([
      new Vector2(0, 0),
      new Vector2(1 / 16, 0),
      new Vector2(2 / 16, 1 / 32),
      new Vector2(3 / 16, 1 / 2),
      new Vector2(2 / 16, 24 / 32),
      new Vector2(3 / 32, 26 / 32)
    ]).color(new Color().setHSL(Math.random(), MathUtils.randFloat(0.25, 0.8), MathUtils.randFloat(0.25, 0.75))).parent.repeat(count, (b22) => {
      const type = vaseContentTypes[Math.floor(Math.random() * vaseContentTypes.length)];
      const center2 = nearPoint(objects, type.radius);
      if (!center2)
        throw new Error();
      const center3 = new Vector3(center2.x, 0, center2.y);
      objects.push({point: center2, radius: type.radius});
      type.builder(b22.group()).translate(center3.x, center3.y, center3.z);
    });
  }
};
var pot = {
  radius: 1 / 8,
  builder: (b3) => b3.thickLathe([
    new Vector2(0, 0),
    new Vector2(1 / 16, 0),
    new Vector2(2 / 16, 1 / 64),
    new Vector2(3 / 16, 16 / 64),
    new Vector2(2 / 16, 24 / 64)
  ]).color(new Color().setHSL(Math.random(), MathUtils.randFloat(0.25, 0.8), MathUtils.randFloat(0.25, 0.75)))
};
var bag = {
  radius: 1 / 16,
  builder: (b3) => b3.thickLathe([
    new Vector2(0, 0),
    new Vector2(1 / 32, 0),
    new Vector2(2 / 32, 1 / 64),
    new Vector2(3 / 32, 8 / 64),
    new Vector2(3 / 64, 13 / 64),
    new Vector2(1 / 128, 14 / 64),
    new Vector2(4 / 128, 16 / 64)
  ]).color(Randomizer_default.colorSpread(cloth, Randomizer_default.flatSpreader(1 / 32)))
};
var types = [vase, pot, bag];
var PileOfJunk = /* @__PURE__ */ __name(class extends Mesh {
  constructor() {
    const count = MathUtils.randInt(3, 5);
    const objects = [];
    const geometry = new Builder_default().repeat(count, (b3) => {
      const type = types[Math.floor(Math.random() * types.length)];
      const center2 = nearPoint(objects, type.radius);
      if (!center2)
        throw new Error();
      objects.push({point: center2, radius: type.radius});
      const child = b3.group();
      type.builder(child);
      child.rotateX(Math.PI / 2).translate(center2.x, center2.y);
    }).root().geometry();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "PileOfJunk");
var TRUNK_COLOR = new Color(4734233);
var LEAVES_COLOR = new Color(159277);
var createTrunk = /* @__PURE__ */ __name(({
  radius,
  height,
  color
}) => new Builder_default().cylinder(radius / 16, radius / 10, height / 3).color(color).rotateX(Math.PI / 2).rotateZ(Math.PI * Math.random()).translateZ(height / 8).parent.geometry(), "createTrunk");
var createShelfs = /* @__PURE__ */ __name(({
  height,
  radius,
  shelfs,
  color
}) => {
  let shelfRadius = height * radius / shelfs * (Math.random() + 4) / 300;
  const shelfRadiusGrowth = height / shelfs / 10;
  let Class = ConeGeometry;
  const xTilt = MathUtils.randFloatSpread(height / 20);
  const yTilt = MathUtils.randFloatSpread(height / 20);
  const shelfGeometries = [];
  for (let i3 = 0; i3 < shelfs; i3++) {
    color.offsetHSL(MathUtils.randFloatSpread(1 / 16), MathUtils.randFloatSpread(1 / 2), MathUtils.randFloatSpread(1 / 12));
    const args = [
      shelfRadius += Math.random() * shelfRadiusGrowth + radius / shelfs / 5,
      shelfRadius * (Class === CylinderGeometry ? 1.5 * 0.9 : 2 * 0.9)
    ];
    if (Class === CylinderGeometry)
      args.unshift(args[0] / 6);
    const shelf = new Class(...args).toNonIndexed();
    if (Class === ConeGeometry)
      Class = CylinderGeometry;
    const faces = getFaceCount(shelf);
    for (let i22 = 0; i22 < faces; i22++)
      colorFace(shelf, i22, color.clone().offsetHSL(MathUtils.randFloatSpread(1 / 24), 0, 0));
    shelf.radius = shelfRadius;
    shelf.height = shelfRadius * 2;
    height -= shelfRadius ** 0.65 / shelfs * (Math.random() / 3 + 2.5);
    shelf.rotateX(Math.PI / 2);
    shelf.rotateZ(Math.PI * Math.random());
    shelf.rotateY(MathUtils.randFloatSpread(1 / 6));
    shelf.translate((shelfs - i3) ** 0.75 * xTilt, (shelfs - i3) ** 0.75 * yTilt, height);
    shelfGeometries.push(shelf);
  }
  return shelfGeometries;
}, "createShelfs");
var PineTree = /* @__PURE__ */ __name(class extends Mesh {
  constructor({
    scale = 1,
    height = Math.random() + 3,
    radius = Math.random() / 4 + 3,
    shelfs = void 0,
    trunk = TRUNK_COLOR.clone().offsetHSL(MathUtils.randFloatSpread(1 / 24), 0, 0),
    leaves = LEAVES_COLOR.clone().offsetHSL(MathUtils.randFloatSpread(1 / 24), 0, 0)
  } = {}) {
    height = height * scale;
    radius = radius * scale;
    if (shelfs === void 0)
      shelfs = height > 10 / 3 ? 3 + (Math.random() > 0.5 ? 1 : 0) : 3;
    const geometry = BufferGeometryUtils.mergeBufferGeometries([
      createTrunk({radius, height, color: trunk}),
      ...createShelfs({height, radius, shelfs, color: leaves})
    ]);
    geometry.computeVertexNormals();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "PineTree");
var RockChunks = /* @__PURE__ */ __name(class extends Mesh {
  constructor({
    color: inColor,
    colorVariation = colorNudge
  } = {}) {
    const color = inColor ?? randColor(stone, colorVariation);
    const base = dodecahedron({
      radius: 1,
      color: randColor(color, colorVariation),
      vertexVariation: 1 / 8
    });
    base.rotateX(Math.PI / 2);
    base.rotateZ(MathUtils.randFloatSpread(Math.PI));
    base.translate(0, 0, 3 / 8);
    const fallenChunks = MathUtils.randInt(0, 3);
    const chunks = [];
    for (let i3 = 0; i3 < fallenChunks; i3++) {
      const chunk = tetrahedron({
        radius: 1 / 3,
        detail: MathUtils.randInt(0, 1),
        color: randColor(color, colorVariation),
        vertexVariation: 1 / 8
      });
      const angle = MathUtils.randFloatSpread(2 * Math.PI);
      const dist = MathUtils.randFloat(1, 5 / 4);
      chunk.translate(dist * Math.cos(angle), dist * Math.sin(angle), 1 / 10);
      chunks.push(chunk);
    }
    const geometry = BufferGeometryUtils.mergeBufferGeometries([
      base,
      ...chunks
    ]);
    geometry.computeVertexNormals();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "RockChunks");
var ScorchedBarn = /* @__PURE__ */ __name(class extends Mesh {
  constructor() {
    const color = Randomizer_default.colorSpread(wood.clone().offsetHSL(0, 0.1, -0.1));
    const paneling = color.clone();
    const roof = color.clone().offsetHSL(0, -0.05, 0.05);
    const length = 15;
    const width = 11;
    const thickness = 1 / 32;
    const geometry = new Builder_default().repeat(2, (b3, y3) => b3.repeat(width, (b22, x3, _0, mid) => {
      if (Math.abs(x3) <= 1)
        return;
      const angle = Math.acos(x3 / mid);
      const height = (1 / 2 + Math.sin(angle) * 8 / length) * (Math.random() < 1 / 3 ? Math.random() : 1);
      b22.box(1 / 8, thickness, height).translate(x3 / 8, y3 * length / 8, height / 2).color(paneling).randomize(1 / 2);
    })).repeat(2, (b3, x3) => b3.repeat(length, (b22, y3) => {
      const height = 1 / 2 * (Math.random() < 0.5 ? Math.random() : 1);
      b22.box(thickness, 1 / 8, height).translate(x3 * width / 8, y3 / 8, height / 2).color(paneling).randomize();
    })).repeat(length + 1, (b3, y3) => {
      const leftShingles = Math.floor(width / 2 * Math.random());
      const rigthShingles = Math.floor(width / 2 * Math.random());
      b3.repeat(width, (b22, x3, x22, mid) => {
        if (x3 < 0) {
          if (x22 > leftShingles)
            return;
        }
        if (x3 > 0) {
          if (x22 > rigthShingles)
            return;
        }
        if (x3 === 0) {
          if (leftShingles !== mid && rigthShingles !== mid)
            return;
        }
        const width2 = Math.PI / 2 * x3 / mid;
        return b22.box(thickness, 1 / 8, (1 / 8 + thickness) * Math.PI / 2).translate(Math.sin(width2) * ((mid + 0.5) / 8 + thickness), y3 / 8, 9 / 4 * thickness + Math.abs(Math.cos(width2) * ((mid + 0.5) / 8 + thickness))).rotateY(-Math.acos(Math.sin(width2))).color(roof).randomize();
      });
    }).rotateZ(-Math.PI / 4).geometry();
    super(geometry, faceColorMaterial);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "ScorchedBarn");
var fetchCache = /* @__PURE__ */ __name((rootCache, args) => {
  let cache = rootCache;
  for (let i3 = 0; i3 < args.length - 1; i3++) {
    if (!(args[i3] in cache))
      cache[args[i3]] = {};
    cache = cache[args[i3]];
  }
  const lastArg = args[args.length - 1];
  return [cache[lastArg], cache, lastArg in cache, lastArg];
}, "fetchCache");
var memoize_default = /* @__PURE__ */ __name((fn) => {
  const cache = {};
  const memoizedFn = /* @__PURE__ */ __name(function(...args) {
    const [value, container2, contains, lastArg] = fetchCache(cache, args);
    if (contains)
      return value;
    return container2[lastArg] = fn.apply(this, args);
  }, "memoizedFn");
  return memoizedFn;
}, "memoize_default");
var memoizedColor = memoize_default((hex) => new Color(hex));
var tileFaceVertices = /* @__PURE__ */ __name((vertices, which) => (which ? [1, 0, 2] : [1, 2, 3]).map((index) => vertices[index]), "tileFaceVertices");
var wallVertices = /* @__PURE__ */ __name((vertices, vertical, low, first) => (vertical && low && first && [1, 0, 2] || vertical && low && !first && [1, 2, 3] || vertical && !low && first && [2, 0, 1] || vertical && !low && !first && [2, 1, 3] || !vertical && low && first && [2, 0, 1] || !vertical && low && !first && [2, 1, 3] || !vertical && !low && first && [1, 0, 2] || [1, 2, 3]).map((index) => vertices[index]), "wallVertices");
var rotate = /* @__PURE__ */ __name((faces) => {
  for (let i3 = 0; i3 < faces.length / 2; i3++)
    if (Math.random() < 0.5) {
      faces[i3 * 2].c = faces[i3 * 2 + 1].c;
      faces[i3 * 2 + 1].a = faces[i3 * 2].b;
    }
}, "rotate");
var nudge2 = /* @__PURE__ */ __name((factor = 1) => (Math.random() - 0.5) * (Math.random() - 0.5) * factor, "nudge2");
var noise = /* @__PURE__ */ __name((vertexMap) => {
  for (const l1 of vertexMap)
    if (l1) {
      for (const l22 of l1)
        if (l22)
          for (const l3 of l22) {
            if (!l3)
              continue;
            l3.x += nudge2(0.75);
            l3.y += nudge2(0.75);
            l3.z += nudge2(0.5);
          }
    }
}, "noise");
var findLastIndex = /* @__PURE__ */ __name((arr, fn, fromIndex = arr.length - 1) => {
  for (let i3 = fromIndex; i3 >= 0; i3--)
    if (fn(arr[i3]))
      return i3;
  return -1;
}, "findLastIndex");
var CORNERS = {
  TOP_LEFT: {x: -1, y: -1},
  TOP_RIGHT: {x: 1, y: -1},
  BOTTOM_LEFT: {x: -1, y: 1},
  BOTTOM_RIGHT: {x: 1, y: 1}
};
var calcCliffHeightCorner = /* @__PURE__ */ __name((cliffMask, x3, y3, direction) => {
  const cliffHeight2 = cliffMask[y3]?.[x3];
  if (typeof cliffHeight2 === "number")
    return cliffHeight2;
  const checks = [{...direction}];
  if (direction.x !== 0 && direction.y !== 0)
    checks.push({x: 0, y: direction.y}, {x: direction.x, y: 0});
  const heights = checks.map(({x: xD, y: yD}) => cliffMask[y3 + yD]?.[x3 + xD]);
  const max = heights.reduce((max2, v3) => typeof v3 === "number" && v3 > max2 ? v3 : max2, -Infinity);
  if (heights.every((v3) => typeof v3 === "number"))
    return max;
  const rampHeights = heights.map((v3, i3) => {
    if (v3 !== "r")
      return NaN;
    let cornerHeight = "r";
    let xCorner = x3 + checks[i3].x;
    let yCorner = y3 + checks[i3].y;
    while (cornerHeight === "r") {
      cornerHeight = cliffMask[yCorner][xCorner];
      xCorner += checks[i3].x;
      yCorner += checks[i3].y;
    }
    let oppositeHeight = "r";
    let xOpposite = x3 - checks[i3].x;
    let yOpposite = y3 - checks[i3].y;
    while (oppositeHeight === "r") {
      oppositeHeight = cliffMask[yOpposite][xOpposite];
      xOpposite -= checks[i3].x;
      yOpposite -= checks[i3].y;
    }
    if (cornerHeight === oppositeHeight && checks[i3].x !== 0 && checks[i3].y !== 0) {
      let adjacentHeight = "r";
      let xAdjacent = x3 - checks[i3].x;
      let yAdjacent = y3 + checks[i3].y;
      while (adjacentHeight === "r") {
        adjacentHeight = cliffMask[yAdjacent][xAdjacent];
        xAdjacent -= checks[i3].x;
        yAdjacent += checks[i3].y;
      }
      let adjacentOppositeHeight = "r";
      let xAdjacentOpposite = x3 + checks[i3].x;
      let yAdjacentOpposite = y3 - checks[i3].y;
      while (adjacentOppositeHeight === "r") {
        adjacentOppositeHeight = cliffMask[yAdjacentOpposite][xAdjacentOpposite];
        xAdjacentOpposite += checks[i3].x;
        yAdjacentOpposite -= checks[i3].y;
      }
      return Math.max((adjacentHeight + adjacentOppositeHeight) / 2, max);
    }
    return Math.max((cornerHeight + oppositeHeight) / 2, max);
  });
  const rampHeight = rampHeights.reduce((max2, v3) => !isNaN(v3) && v3 > max2 ? v3 : max2, -Infinity);
  return rampHeight;
}, "calcCliffHeightCorner");
var calcCliffHeight = /* @__PURE__ */ __name((cliffMask, x3, y3) => {
  const cliffHeight2 = cliffMask[y3]?.[x3];
  if (typeof cliffHeight2 === "number")
    return {
      topLeft: cliffHeight2,
      topRight: cliffHeight2,
      bottomLeft: cliffHeight2,
      bottomRight: cliffHeight2
    };
  const [topLeft, topRight, bottomLeft, bottomRight] = Object.values(CORNERS).map((direction) => calcCliffHeightCorner(cliffMask, x3, y3, direction));
  return {
    topLeft,
    topRight,
    bottomLeft,
    bottomRight
  };
}, "calcCliffHeight");
var Face3 = /* @__PURE__ */ __name(class {
  constructor(a3, b3, c3, color) {
    this.a = a3;
    this.b = b3;
    this.c = c3;
    this.color = color;
  }
}, "Face3");
var Terrain = /* @__PURE__ */ __name(class extends Group {
  constructor(terrain2) {
    super();
    this.groundFaces = [];
    this.vertices = [];
    this.groundColor = memoize_default((x3, y3) => {
      try {
        const hex = terrain2.tiles[terrain2.masks.groundTile[y3][x3]].color.toUpperCase();
        return memoizedColor(hex);
      } catch (err) {
        throw new Error(`Tile ( ${x3}, ${y3} ) uses undefined color ${terrain2.masks.groundTile[y3][x3]}.`);
      }
    });
    this.cliffColor = memoize_default((x3, y3) => {
      try {
        const hex = terrain2.tiles[terrain2.masks.cliffTile[y3][x3]].color.toUpperCase();
        return memoizedColor(hex);
      } catch (err) {
        throw new Error(`Tile ( ${x3}, ${y3} ) uses undefined color ${terrain2.masks.cliffTile[y3][x3]}.`);
      }
    });
    const {width, height} = terrain2.size;
    this.width = width;
    this.height = height;
    {
      const {geometry, material} = this._computeGround({
        height: terrain2.masks.height,
        cliff: terrain2.masks.cliff,
        offset: terrain2.offset
      });
      this.ground = geometry;
      const mesh = new Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      this.add(mesh);
    }
    {
      const {geometry, material} = this._computeWater({
        water: terrain2.masks.water,
        waterHeight: terrain2.masks.waterHeight,
        offset: terrain2.offset
      });
      this.water = geometry;
      this.add(new Mesh(geometry, material));
    }
  }
  _computeGround({
    height: heightMask,
    cliff: cliffMask,
    offset: offset3
  }) {
    const allFaces = [];
    const vertex = /* @__PURE__ */ __name((x3, y3, z2, offset22) => {
      const existing = this.vertices[x3]?.[y3]?.[z2];
      if (existing !== void 0)
        return existing;
      if (this.vertices[x3] === void 0)
        this.vertices[x3] = [];
      if (this.vertices[x3][y3] === void 0)
        this.vertices[x3][y3] = [];
      const vector = new Vector3(x3, -y3, z2 + offset22);
      this.vertices[x3][y3][z2] = vector;
      return vector;
    }, "vertex");
    const rampWalls = [];
    for (let y3 = this.height - 1; y3 >= 0; y3--)
      for (let x3 = 0; x3 < this.width; x3++) {
        const cliffTile = cliffMask[y3][x3];
        if (cliffTile !== "r" && isNaN(cliffTile))
          continue;
        const topLeft = heightMask[y3][x3];
        const topRight = heightMask[y3][x3 + 1];
        const botLeft = heightMask[y3 + 1][x3];
        const botRight = heightMask[y3 + 1][x3 + 1];
        if (typeof cliffTile === "number") {
          const vertices = [
            vertex(x3, y3, cliffTile, topLeft),
            vertex(x3 + 1, y3, cliffTile, topRight),
            vertex(x3, y3 + 1, cliffTile, botLeft),
            vertex(x3 + 1, y3 + 1, cliffTile, botRight)
          ];
          const aVertices = tileFaceVertices(vertices, true);
          const bVertices = tileFaceVertices(vertices, false);
          const faces = [
            new Face3(aVertices[0], aVertices[1], aVertices[2], this.groundColor(x3, y3)),
            new Face3(bVertices[0], bVertices[1], bVertices[2], this.groundColor(x3, y3))
          ];
          if (!this.groundFaces[y3])
            this.groundFaces[y3] = [];
          this.groundFaces[y3][x3] = faces;
          allFaces.push(...faces);
          if (x3 > 0 && cliffMask[y3][x3 - 1] !== void 0) {
            const altHeight = this._tileHeight(cliffMask, x3 - 1, y3);
            const currentIsLow = cliffTile < altHeight;
            const low = currentIsLow ? cliffTile : altHeight;
            const high = currentIsLow ? altHeight : cliffTile;
            for (let z2 = low; z2 < high; z2++) {
              const vertices2 = [
                vertex(x3, y3, z2, topLeft),
                vertex(x3, y3 + 1, z2, botLeft),
                vertex(x3, y3, z2 + 1, topLeft),
                vertex(x3, y3 + 1, z2 + 1, botLeft)
              ];
              const aVertices2 = wallVertices(vertices2, true, currentIsLow, true);
              const bVertices2 = wallVertices(vertices2, true, currentIsLow, false);
              allFaces.push(new Face3(aVertices2[0], aVertices2[1], aVertices2[2], this.cliffColor(x3, y3)), new Face3(bVertices2[0], bVertices2[1], bVertices2[2], this.cliffColor(x3, y3)));
            }
          }
          if (y3 > 0 && cliffMask[y3 - 1][x3] !== void 0) {
            const altHeight = this._tileHeight(cliffMask, x3, y3 - 1);
            const currentIsLow = cliffTile < altHeight;
            const low = currentIsLow ? cliffTile : altHeight;
            const high = currentIsLow ? altHeight : cliffTile;
            for (let z2 = low; z2 < high; z2++) {
              const vertices2 = [
                vertex(x3, y3, z2, topLeft),
                vertex(x3 + 1, y3, z2, topRight),
                vertex(x3, y3, z2 + 1, topLeft),
                vertex(x3 + 1, y3, z2 + 1, topRight)
              ];
              const aVertices2 = wallVertices(vertices2, false, currentIsLow, true);
              const bVertices2 = wallVertices(vertices2, false, currentIsLow, false);
              allFaces.push(new Face3(aVertices2[0], aVertices2[1], aVertices2[2], this.cliffColor(x3, y3)), new Face3(bVertices2[0], bVertices2[1], bVertices2[2], this.cliffColor(x3, y3)));
            }
          }
        } else if (cliffTile.toLowerCase() === "r") {
          const {
            topLeft: topLeftCliff,
            topRight: topRightCliff,
            bottomLeft: botLeftCliff,
            bottomRight: botRightCliff
          } = calcCliffHeight(cliffMask, x3, y3);
          const vertices = [
            vertex(x3, y3, topLeftCliff, topLeft),
            vertex(x3 + 1, y3, topRightCliff, topRight),
            vertex(x3, y3 + 1, botLeftCliff, botLeft),
            vertex(x3 + 1, y3 + 1, botRightCliff, botRight)
          ];
          const aVertices = tileFaceVertices(vertices, true);
          const bVertices = tileFaceVertices(vertices, false);
          const faces = [
            new Face3(aVertices[0], aVertices[1], aVertices[2], this.groundColor(x3, y3)),
            new Face3(bVertices[0], bVertices[1], bVertices[2], this.groundColor(x3, y3))
          ];
          if (!this.groundFaces[y3])
            this.groundFaces[y3] = [];
          this.groundFaces[y3][x3] = faces;
          allFaces.push(...faces);
          const corners = [
            topLeftCliff,
            topRightCliff,
            botLeftCliff,
            botRightCliff
          ];
          const walls = [
            {a: 0, b: 1, neighbor: {x: 0, y: -1}},
            {a: 1, b: 3, neighbor: {x: 1, y: 0}},
            {a: 3, b: 2, neighbor: {x: 0, y: 1}},
            {a: 2, b: 0, neighbor: {x: -1, y: 0}}
          ];
          for (let i3 = 0; i3 < walls.length; i3++) {
            const neighborCliffMaskTile = cliffMask[y3 + walls[i3].neighbor.y]?.[x3 + walls[i3].neighbor.x];
            if (neighborCliffMaskTile !== void 0 && typeof neighborCliffMaskTile === "string")
              continue;
            const z2 = Math.min(corners[walls[i3].a], corners[walls[i3].b]);
            const a3 = vertices[walls[i3].a];
            const b3 = vertices[walls[i3].b];
            if (a3.z !== b3.z && (a3.x === b3.x || a3.y === b3.y)) {
              const height = Math.min(a3.z, b3.z);
              const {x: vX, y: vY} = a3.z === height ? b3 : a3;
              const v3 = vertex(vX, -vY, z2, height - z2);
              rampWalls.push(new Face3(a3, b3, v3, this.cliffColor(x3, y3)));
            }
          }
          const minHeight = Math.min(topLeftCliff, topRightCliff, botLeftCliff, botRightCliff);
          if (isNaN(minHeight))
            console.warn("Got a NaN!");
          if (topLeftCliff !== botLeftCliff && x3 > 0) {
            const rawCliffLeft = cliffMask[y3][x3 - 1];
            const cliffLeft = typeof rawCliffLeft === "number" ? rawCliffLeft : -Infinity;
            const currentIsLow = minHeight < cliffLeft;
            const low = currentIsLow ? minHeight : cliffLeft;
            const high = currentIsLow ? cliffLeft : minHeight;
            if (isNaN(low) || isNaN(high) || !isFinite(low) || !isFinite(high))
              continue;
            for (let z2 = low; z2 < high; z2++) {
              const vertices2 = [
                vertex(x3, y3, z2, topLeft),
                vertex(x3, y3 + 1, z2, botLeft),
                vertex(x3, y3, z2 + 1, topLeft),
                vertex(x3, y3 + 1, z2 + 1, botLeft)
              ];
              const aVertices2 = wallVertices(vertices2, true, currentIsLow, true);
              const bVertices2 = wallVertices(vertices2, true, currentIsLow, false);
              allFaces.push(new Face3(aVertices2[0], aVertices2[1], aVertices2[2], this.cliffColor(x3, y3)), new Face3(bVertices2[0], bVertices2[1], bVertices2[2], this.cliffColor(x3, y3)));
            }
          }
          if (topLeftCliff !== topRightCliff && y3 > 0) {
            const rawCliffAbove = cliffMask[y3 - 1][x3];
            const cliffAbove = typeof rawCliffAbove === "number" ? rawCliffAbove : -Infinity;
            const currentIsLow = minHeight < cliffAbove;
            const low = currentIsLow ? minHeight : cliffAbove;
            const high = currentIsLow ? cliffAbove : minHeight;
            if (isNaN(low) || isNaN(high) || !isFinite(low) || !isFinite(high))
              continue;
            for (let z2 = low; z2 < high; z2++) {
              const vertices2 = [
                vertex(x3, y3, z2, topLeft),
                vertex(x3 + 1, y3, z2, topRight),
                vertex(x3, y3, z2 + 1, topLeft),
                vertex(x3 + 1, y3, z2 + 1, topRight)
              ];
              const aVertices2 = wallVertices(vertices2, false, currentIsLow, true);
              const bVertices2 = wallVertices(vertices2, false, currentIsLow, false);
              allFaces.push(new Face3(aVertices2[0], aVertices2[1], aVertices2[2], this.cliffColor(x3, y3)), new Face3(bVertices2[0], bVertices2[1], bVertices2[2], this.cliffColor(x3, y3)));
            }
          }
        }
      }
    rotate(allFaces);
    allFaces.push(...rampWalls);
    noise(this.vertices);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new BufferAttribute(new Float32Array(allFaces.flatMap((face) => [face.a, face.b, face.c].flatMap((v3) => [
      v3.x,
      v3.y,
      v3.z
    ]))), 3));
    geometry.setAttribute("color", new BufferAttribute(new Float32Array(allFaces.flatMap((face) => [
      face.color.r,
      face.color.g,
      face.color.b,
      face.color.r,
      face.color.g,
      face.color.b,
      face.color.r,
      face.color.g,
      face.color.b
    ])), 3));
    geometry.computeVertexNormals();
    geometry.translate(-offset3.x, offset3.y, offset3.z);
    return {geometry, material: faceColorMaterial};
  }
  _computeWater({
    water: waterMask,
    waterHeight: waterHeightMask,
    offset: offset3
  }) {
    const faces = [];
    const vertex = /* @__PURE__ */ __name((x3, y3, waterHeight) => {
      const existing = this.vertices[x3]?.[y3]?.water;
      if (existing !== void 0)
        return existing;
      if (this.vertices[x3] === void 0)
        this.vertices[x3] = [];
      if (this.vertices[x3][y3] === void 0)
        this.vertices[x3][y3] = [];
      waterHeight += 3 / 8 + offset3.z;
      const groundVertices = this.vertices[x3][y3];
      if (!groundVertices || !groundVertices.length)
        throw new Error("Expected ground where there is water");
      const cliff = Math.floor(waterHeight);
      const trueLowIndex = findLastIndex(groundVertices, Boolean, cliff);
      const lowIndex = trueLowIndex < 0 ? groundVertices.findIndex(Boolean) : trueLowIndex;
      const low = groundVertices[lowIndex];
      const high = groundVertices.length - 1 !== lowIndex ? groundVertices[groundVertices.length - 1] : void 0;
      let vector;
      if (high) {
        const alpha = (waterHeight - low.z) / (high.z - low.z);
        vector = low.clone().lerp(high, alpha);
      } else
        vector = low.clone().setZ(waterHeight + nudge2(1 / 8));
      this.vertices[x3][y3].water = vector;
      return vector;
    }, "vertex");
    for (let y3 = this.height - 1; y3 >= 0; y3--)
      for (let x3 = 0; x3 < this.width; x3++)
        if (waterMask[y3][x3]) {
          const topLeft = waterHeightMask[y3][x3];
          const topRight = waterHeightMask[y3][x3 + 1];
          const botLeft = waterHeightMask[y3 + 1][x3];
          const botRight = waterHeightMask[y3 + 1][x3 + 1];
          const vertices = [
            vertex(x3, y3, topLeft),
            vertex(x3 + 1, y3, topRight),
            vertex(x3, y3 + 1, botLeft),
            vertex(x3 + 1, y3 + 1, botRight)
          ];
          faces.push(new Face3(...tileFaceVertices(vertices, true), water), new Face3(...tileFaceVertices(vertices, false), water));
        }
    rotate(faces);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new BufferAttribute(new Float32Array(faces.flatMap((face) => [face.a, face.b, face.c].flatMap((v3) => [
      v3.x,
      v3.y,
      v3.z
    ]))), 3));
    geometry.setAttribute("color", new BufferAttribute(new Float32Array(faces.flatMap((face) => [
      face.color.r,
      face.color.g,
      face.color.b,
      face.color.r,
      face.color.g,
      face.color.b,
      face.color.r,
      face.color.g,
      face.color.b
    ])), 3));
    geometry.translate(-offset3.x, offset3.y, offset3.z);
    return {geometry, material: waterMaterial};
  }
  _tileHeight(cliffMask, x3, y3) {
    const raw = cliffMask[y3][x3];
    if (typeof raw === "number")
      return raw;
    const {topLeft, topRight, bottomLeft, bottomRight} = calcCliffHeight(cliffMask, x3, y3);
    return Math.min(...[topLeft, topRight, bottomLeft, bottomRight].filter((v3) => !isNaN(v3) && Number.isFinite(v3)));
  }
}, "Terrain");
var leftTrim = /* @__PURE__ */ __name((v3) => {
  const match = v3.match(/^\s+/);
  return match ? match[0].length : 0;
}, "leftTrim");
var commonLeftTrim = /* @__PURE__ */ __name((rows) => rows.reduce((min, row) => {
  if (!row.trim())
    return min;
  return Math.min(min, leftTrim(row));
}, Infinity), "commonLeftTrim");
var stringMap = /* @__PURE__ */ __name((map, fill = 0) => {
  const rows = map.split("\n").filter((v3) => v3.trim());
  const minLeftTrim = commonLeftTrim(rows);
  return rows.map((row) => row.trimRight().slice(minLeftTrim).split("").map((v3) => {
    const num = parseInt(v3);
    if (isNaN(num))
      return fill;
    return num;
  }));
}, "stringMap");
var cliffMap = /* @__PURE__ */ __name((map) => {
  const rows = map.split("\n").filter((v3) => v3.trim());
  const minLeftTrim = commonLeftTrim(rows);
  const exploded = rows.map((row) => row.trimRight().slice(minLeftTrim).split(""));
  const newMap = [];
  for (let y3 = 0; y3 < exploded.length; y3++) {
    const row = [];
    newMap.push(row);
    for (let x3 = 0; x3 < exploded[y3].length; x3++) {
      const v3 = exploded[y3][x3];
      if (v3 === "r") {
        row.push("r");
        continue;
      }
      if (v3 === ".") {
        const left = row[x3 - 1];
        if (typeof left === "number") {
          row.push(left);
          continue;
        }
        const up = newMap[y3 - 1][x3];
        if (typeof up === "number") {
          row.push(up);
          continue;
        }
        throw new Error(`cannot determine height at (${x3}, ${y3})`);
      }
      row.push(parseInt(v3));
    }
  }
  return newMap;
}, "cliffMap");
var wall = /* @__PURE__ */ __name(({
  thickness,
  length,
  height
}) => {
  const wall2 = box({
    width: thickness,
    height: length,
    depth: height,
    color: randColor(wood)
  });
  wall2.translate(0, 0, height / 2);
  return wall2;
}, "wall");
var spoke = /* @__PURE__ */ __name(({
  thickness,
  height
}) => {
  const spoke2 = box({
    width: thickness * 1.25,
    height: thickness * 2,
    depth: height * 1.25,
    color: randColor(wood)
  });
  spoke2.translate(0, 0, height / 2 * 1.25);
  return spoke2;
}, "spoke");
var Trough = /* @__PURE__ */ __name(class extends Mesh {
  constructor({
    thickness = 1 / 16,
    length = 1 / 2,
    width = 1 / 4,
    height = 1 / 4,
    angle = 0
  } = {}) {
    const materials = [faceColorMaterial, waterMaterial];
    let geometry = wall({
      thickness,
      length: length + thickness,
      height
    });
    geometry.rotateY(-MathUtils.randFloat(1 / 5, 1 / 3));
    geometry.translate(-width / 2 + thickness / 2, 0, 0);
    const right = wall({thickness, length: length + thickness, height});
    right.rotateY(MathUtils.randFloat(1 / 5, 1 / 3));
    right.translate(width / 2 - thickness / 2, 0, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([geometry, right]);
    const top = wall({thickness, length: width, height});
    top.rotateY(MathUtils.randFloat(1 / 5, 1 / 3));
    top.rotateZ(Math.PI / 2);
    top.translate(0, length / 2 - thickness / 2, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([geometry, top]);
    const bottom = wall({thickness, length: width, height});
    bottom.rotateY(-MathUtils.randFloat(1 / 5, 1 / 3));
    bottom.rotateZ(Math.PI / 2);
    bottom.translate(0, -length / 2 + thickness / 2, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([
      geometry,
      bottom
    ]);
    const topLeft = spoke({thickness, height});
    topLeft.rotateY(MathUtils.randFloat(1 / 5, 1 / 3));
    topLeft.rotateX(-MathUtils.randFloat(1 / 5, 1 / 3));
    topLeft.rotateZ(Math.PI / 2);
    topLeft.translate(-width / 2 + thickness / 2, length / 2 - thickness / 2, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([
      geometry,
      topLeft
    ]);
    const topRight = spoke({thickness, height});
    topRight.rotateY(MathUtils.randFloat(1 / 5, 1 / 3));
    topRight.rotateX(MathUtils.randFloat(1 / 5, 1 / 3));
    topRight.rotateZ(Math.PI / 2);
    topRight.translate(width / 2 - thickness / 2, length / 2 - thickness / 2, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([
      geometry,
      topRight
    ]);
    const bottomLeft = spoke({thickness, height});
    bottomLeft.rotateY(-MathUtils.randFloat(1 / 5, 1 / 3));
    bottomLeft.rotateX(-MathUtils.randFloat(1 / 5, 1 / 3));
    bottomLeft.rotateZ(Math.PI / 2);
    bottomLeft.translate(-width / 2 + thickness / 2, -length / 2 + thickness / 2, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([
      geometry,
      bottomLeft
    ]);
    const bottomRight = spoke({thickness, height});
    bottomRight.rotateY(-MathUtils.randFloat(1 / 5, 1 / 3));
    bottomRight.rotateX(MathUtils.randFloat(1 / 5, 1 / 3));
    bottomRight.rotateZ(Math.PI / 2);
    bottomRight.translate(width / 2 - thickness / 2, -length / 2 + thickness / 2, 0);
    geometry = BufferGeometryUtils.mergeBufferGeometries([
      geometry,
      bottomRight
    ]);
    geometry.addGroup(0, geometry.getAttribute("position").count * 2, 0);
    const water2 = new PlaneGeometry(width, length).toNonIndexed();
    const waterColorAttribute = new BufferAttribute(new Float32Array(6 * 3), 3);
    water2.setAttribute("color", waterColorAttribute);
    water2.translate(0, 0, height * 3 / 4);
    for (let i3 = 0; i3 < 6; i3++)
      waterColorAttribute.setXYZ(i3, water.r, water.g, water.b);
    geometry = BufferGeometryUtils.mergeBufferGeometries([geometry, water2], true);
    geometry.rotateZ(angle - Math.PI / 4);
    geometry.computeVertexNormals();
    super(geometry, materials);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}, "Trough");

// node_modules/webcraft/dist/index.js
var import_marked = __toModule(require_marked());
var __defProp3 = Object.defineProperty;
var __markAsModule2 = /* @__PURE__ */ __name((target2) => __defProp3(target2, "__esModule", {value: true}), "__markAsModule");
var __name2 = /* @__PURE__ */ __name((target2, value) => __defProp3(target2, "name", {value, configurable: true}), "__name");
var __commonJS2 = /* @__PURE__ */ __name((callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
}, "__commonJS");
var __export3 = /* @__PURE__ */ __name((target2, all) => {
  for (var name in all)
    __defProp3(target2, name, {get: all[name], enumerable: true});
}, "__export");
var require_App = __commonJS2((exports2) => {
  __markAsModule2(exports2);
  __export3(exports2, {
    initialize: () => initialize
  });
  var App2 = /* @__PURE__ */ __name2(({game}) => {
    const [loggingIn, setLoggingIn] = l2(true);
    return /* @__PURE__ */ a(Game.Provider, {
      value: game
    }, /* @__PURE__ */ a("div", {
      className: "App"
    }, loggingIn && /* @__PURE__ */ a(Login, {
      onSuccess: () => setLoggingIn(true)
    }), /* @__PURE__ */ a("div", {
      id: "top-right",
      className: "h-spacing-8"
    }, /* @__PURE__ */ a(Resources, null), /* @__PURE__ */ a(TimerWindows2, null), /* @__PURE__ */ a(Clock, null), /* @__PURE__ */ a("span", {
      id: "scores"
    })), /* @__PURE__ */ a("div", {
      id: "bottom-left",
      className: "h-spacing-8"
    }, /* @__PURE__ */ a(Ping, null), /* @__PURE__ */ a(FPS, null))));
  }, "App");
  var initialize = /* @__PURE__ */ __name2((game) => {
    N(/* @__PURE__ */ a(App2, {
      game
    }), doc.getElementById("preact"));
  }, "initialize");
});
var Context = /* @__PURE__ */ __name(class {
  constructor(context3) {
    this.memory = new WeakMap();
    this._current = context3;
  }
  get current() {
    return this._current;
  }
  _setCurrent(context3) {
    this._current = context3;
    return context3;
  }
  with(context3, fn) {
    const old = this._current;
    this._current = context3;
    const ret = fn(context3);
    this._current = old;
    return ret;
  }
  wrap(context3, fn) {
    if (!context3)
      throw new Error("Expected context");
    let innerMemory;
    if (!this.memory.has(context3)) {
      innerMemory = new WeakMap();
      this.memory.set(context3, innerMemory);
    } else
      innerMemory = this.memory.get(context3);
    if (innerMemory.has(fn))
      return innerMemory.get(fn);
    const wrapped = /* @__PURE__ */ __name2((...args) => this.with(context3, () => fn(...args)), "wrapped");
    innerMemory.set(fn, wrapped);
    return wrapped;
  }
}, "Context");
__name2(Context, "Context");
var context = new Context(void 0);
var withApp = context.with.bind(context);
var wrapApp = context.wrap.bind(context);
var currentApp = /* @__PURE__ */ __name2(() => {
  const app = context.current;
  if (!app)
    throw new Error("Expected an App context");
  return app;
}, "currentApp");
var context2 = new Context({replacing: false});
var whileReplacingComponent = /* @__PURE__ */ __name2((fn) => context2.with({
  ...context2.current,
  replacing: true
}, fn), "whileReplacingComponent");
var isReplacingComponent = /* @__PURE__ */ __name2(() => context2.current.replacing, "isReplacingComponent");
var Component = /* @__PURE__ */ __name(class {
  constructor(entity, ...rest) {
    this.derived = false;
    this.entity = entity;
    const constructor = this.constructor;
    entity.add(constructor, this);
    if (this.initialize)
      this.initialize(...rest);
    currentApp().entityComponentUpdated(entity, this.constructor);
  }
  static has(entity) {
    return entity.has(this);
  }
  static clear(entity) {
    return entity.clear(this);
  }
  dispose() {
    if (!isReplacingComponent())
      currentApp().entityComponentUpdated(this.entity, this.constructor);
  }
  replace(...args) {
    return whileReplacingComponent(() => {
      this.entity.clear(this);
      return new this.constructor(this.entity, ...args);
    });
  }
  toJSON() {
    const {entity, derived, ...props} = this;
    return {type: this.constructor.name, ...props};
  }
  static fromJSON(...args) {
    return new this(...args);
  }
}, "Component");
Component.argMap = [];
__name2(Component, "Component");
var emitter = /* @__PURE__ */ __name2((host) => {
  let events = {};
  const modifiedHost = host;
  if (!modifiedHost.addEventListener)
    modifiedHost.addEventListener = (name, callback) => {
      const callbacks = events[name] ?? [];
      if (!events[name])
        events[name] = callbacks;
      callbacks.push(callback);
    };
  if (!modifiedHost.removeEventListener)
    modifiedHost.removeEventListener = (name, callback) => {
      const callbacks = events[name] ?? void 0;
      if (!callbacks)
        return;
      const index = callbacks.indexOf(callback);
      if (index >= 0)
        callbacks.splice(index, 1);
    };
  if (!modifiedHost.removeEventListeners)
    modifiedHost.removeEventListeners = (name) => {
      if (!name) {
        events = {};
        return;
      }
      events[name] = [];
    };
  if (!modifiedHost.dispatchEvent)
    modifiedHost.dispatchEvent = (name, ...args) => {
      const callbacks = events[name] ?? void 0;
      if (!callbacks)
        return;
      callbacks.forEach((callback) => callback.apply(host, args));
    };
  return modifiedHost;
}, "emitter");
var Entity = /* @__PURE__ */ __name(class {
  constructor(id) {
    this.map = new Map();
    if (id && typeof id === "object")
      id = id.id;
    this.id = id ?? currentApp().entityId++;
  }
  get(klass) {
    if (!klass)
      return Array.from(this.map.values()).flat();
    return this.map.get(klass) ?? [];
  }
  add(klass, component) {
    const components = this.map.get(klass) ?? [];
    components.push(component);
    this.map.set(klass, components);
  }
  has(klass) {
    return (this.map.get(klass)?.length ?? 0) > 0;
  }
  clear(arg) {
    let cleared = false;
    if (!arg) {
      const oldMap = this.map;
      this.map = new Map();
      for (const [, components2] of oldMap)
        for (const component2 of components2) {
          cleared = true;
          component2.dispose();
        }
      return cleared;
    }
    if (typeof arg === "function") {
      const klass2 = arg;
      const components2 = this.map.get(klass2);
      if (!components2)
        return false;
      this.map.set(klass2, []);
      for (const component2 of components2) {
        cleared = true;
        component2.dispose();
      }
      return cleared;
    }
    const component = arg;
    const klass = arg.constructor;
    const components = this.map.get(klass);
    if (!components)
      return false;
    const index = components.indexOf(component);
    if (index >= 0) {
      cleared = true;
      components.splice(index, 1);
      component.dispose();
    }
    return cleared;
  }
  get components() {
    return Array.from(this.map.values()).flat();
  }
  toJSON() {
    return {
      id: this.id,
      components: Array.from(this.map.values()).flatMap((v3) => v3.filter((c3) => !c3.derived).map((c3) => c3.toJSON()))
    };
  }
  static fromJSON({
    components,
    ...rest
  }) {
    if ("clonedDefaults" in this)
      rest = {...this.clonedDefaults, ...rest};
    const entity = new this(rest);
    const app = currentApp();
    for (const {type, ...componentProps} of components) {
      const constructor = app.componentsMap[type];
      if (!constructor) {
        console.warn(`Unable to hydrate unknown component ${type}`);
        continue;
      }
      const args = constructor.argMap.length > 0 ? constructor.argMap.map((k3) => componentProps[k3]) : [componentProps];
      constructor.fromJSON(entity, ...args);
    }
    return entity;
  }
}, "Entity");
Entity.isEntity = true;
__name2(Entity, "Entity");
var contexts = [];
var logLine = /* @__PURE__ */ __name2((...data) => {
  console.log(new Date(), ...contexts, ...data);
}, "logLine");
var Mechanism = /* @__PURE__ */ __name(class {
  update(delta, time) {
  }
  render(delta, time) {
  }
  dispose() {
  }
  addToApp(app) {
    app.addMechanism(this);
    return this;
  }
}, "Mechanism");
__name2(Mechanism, "Mechanism");
var System = /* @__PURE__ */ __name(class {
  constructor() {
    this.set = new Set();
  }
  _add(entity) {
    this.set.add(entity);
    this.onAddEntity?.(entity);
  }
  add(...entites) {
    for (const entity of entites)
      if (this.test(entity) && !this.set.has(entity))
        this._add(entity);
  }
  _remove(entity) {
    this.set.delete(entity);
    this.onRemoveEntity?.(entity);
  }
  remove(...entites) {
    for (const entity of entites)
      if (this.set.has(entity))
        this._remove(entity);
  }
  check(entity) {
    if (this.test(entity))
      if (!this.set.has(entity))
        this._add(entity);
      else
        this.modified?.(entity);
    else if (this.set.has(entity))
      this._remove(entity);
  }
  preUpdate(delta, time) {
  }
  postUpdate(delta, time) {
  }
  preRender(delta, time) {
  }
  postRender(delta, time) {
  }
  dispose() {
    for (const entity of this.set)
      this._remove(entity);
  }
  [Symbol.iterator]() {
    return this.set[Symbol.iterator]();
  }
  addToApp(app) {
    app.addSystem(this);
    return this;
  }
}, "System");
System.isSystem = true;
System.components = [];
__name2(System, "System");
var swallow = /* @__PURE__ */ __name2((obj = {}) => {
  const memory = obj;
  return new Proxy(Object.assign(() => {
  }, {valueOf: () => 0}), {
    get: (_2, prop) => {
      const p3 = prop;
      if (prop in memory)
        return memory[p3];
      memory[p3] = p3 === Symbol.toPrimitive ? () => 1 : swallow();
      return memory[p3];
    },
    set: (_2, prop, value) => {
      memory[prop] = value;
      return true;
    },
    apply: () => swallow()
  });
}, "swallow");
var cAF = typeof cancelAnimationFrame === "undefined" ? swallow() : cancelAnimationFrame;
var doc = typeof document === "undefined" ? swallow({
  createElement: () => swallow({
    getContext: () => swallow({
      getParameter: () => "WebGL 2.0 (OpenGL ES 3.0 Chromium)"
    })
  })
}) : document;
var loc = typeof location === "undefined" ? swallow() : location;
var rAF = typeof requestAnimationFrame === "undefined" ? swallow() : requestAnimationFrame;
var storage = typeof localStorage === "undefined" ? swallow() : localStorage;
var win = typeof window === "undefined" ? swallow() : window;
var ActiveComponent = /* @__PURE__ */ __name(class extends Component {
  initialize(tag) {
    if (tag === void 0)
      return;
    const mutable = this;
    mutable.tag = tag;
  }
}, "ActiveComponent");
__name2(ActiveComponent, "ActiveComponent");
var isEntity = /* @__PURE__ */ __name2((obj) => "isEntity" in obj.constructor, "isEntity");
var isWidget = /* @__PURE__ */ __name2((obj) => "isWidget" in obj.constructor, "isWidget");
var isSelectionCircle = /* @__PURE__ */ __name2((obj) => "isSelectionCircle" in obj.constructor, "isSelectionCircle");
var isSprite = /* @__PURE__ */ __name2((obj) => "isSprite" in obj.constructor, "isSprite");
var isProjectile = /* @__PURE__ */ __name2((obj) => "isProjectile" in obj.constructor, "isProjectile");
var isUnit = /* @__PURE__ */ __name2((obj) => "isUnit" in obj.constructor, "isUnit");
var isObstruction = /* @__PURE__ */ __name2((obj) => "isObstruction" in obj.constructor, "isObstruction");
var isGame = /* @__PURE__ */ __name2((obj) => "isGame" in obj.constructor, "isGame");
var withGame = /* @__PURE__ */ __name2((game, fn) => withApp(game, fn), "withGame");
var wrapGame = /* @__PURE__ */ __name2((game, fn) => wrapApp(game, fn), "wrapGame");
var currentGame = /* @__PURE__ */ __name2(() => {
  const app = currentApp();
  if (!isGame(app))
    throw new Error("Expected a Game context");
  return app;
}, "currentGame");
var Animation = /* @__PURE__ */ __name(class extends Component {
  constructor(entity, animation, duration) {
    super(entity, animation, duration);
  }
  initialize(animation, duration) {
    const mutable = this;
    mutable.animation = animation;
    setTimeout(wrapGame(currentGame(), () => this.entity.clear(this)), duration * 1e3);
  }
}, "Animation");
__name2(Animation, "Animation");
var MeshBuilderComponent = /* @__PURE__ */ __name(class extends Component {
  initialize({
    shape,
    targetable,
    color,
    colorFilter,
    scale = 1,
    shadow,
    opacity = 1,
    shadows = true,
    mutator
  }) {
    const mutable = this;
    mutable.shape = shape;
    mutable.targetable = targetable;
    mutable.color = color;
    mutable.colorFilter = colorFilter;
    mutable.scale = scale;
    mutable.shadow = shadow;
    mutable.opacity = opacity;
    mutable.shadows = shadows;
    mutable.mutator = mutator;
  }
}, "MeshBuilderComponent");
__name2(MeshBuilderComponent, "MeshBuilderComponent");
var PathingComponent = /* @__PURE__ */ __name(class extends Component {
}, "PathingComponent");
__name2(PathingComponent, "PathingComponent");
var PATHING_TYPES = {
  WALKABLE: 1,
  BUILDABLE: 2
};
var DIRECTION = {
  DOWN: 0,
  RIGHT: 1,
  UP: 2,
  LEFT: 3
};
var INITIAL_OBSTRUCTION_PROGRESS = 0.1;
var MIRROR_SEPARATION = 2;
var BUILD_DISTANCE = 1.4;
var getMirroringPosition = /* @__PURE__ */ __name2((pos2, entity, layer) => {
  const pathingSystem = currentGame().pathingSystem;
  const nearest = pathingSystem.nearestSpiralPathing(pos2.x, pos2.y, entity);
  if (pathingSystem.layer(nearest.x, nearest.y) === layer)
    return nearest;
  return pathingSystem.nearestSpiralPathing(nearest.x, nearest.y, entity, layer);
}, "getMirroringPosition");
var isMirroring = /* @__PURE__ */ __name2((unit) => {
  const activities = unit.get(ActiveComponent);
  return activities.some((a3) => a3?.tag === "mirror");
}, "isMirroring");
var mirror = /* @__PURE__ */ __name2((unit) => {
  if (isMirroring(unit))
    return;
  const game = currentGame();
  if (unit.mirrors)
    unit.mirrors.forEach((u3) => u3.kill());
  unit.mirrors = [];
  unit.stop();
  const meshBuilderComponent = unit.get(MeshBuilderComponent)[0];
  if (meshBuilderComponent)
    new Animation(unit, "cast", 0.5);
  const activity = new ActiveComponent(unit, "mirror");
  game.setTimeout(() => {
    unit.clear(activity);
    if (!unit.isAlive)
      return;
    const angle1 = unit.facing + Math.PI / 2;
    const angle2 = unit.facing - Math.PI / 2;
    let pos1 = {
      x: unit.position.x + Math.cos(angle1) * MIRROR_SEPARATION,
      y: unit.position.y + Math.sin(angle1) * MIRROR_SEPARATION
    };
    let pos2 = {
      x: unit.position.x + Math.cos(angle2) * MIRROR_SEPARATION,
      y: unit.position.y + Math.sin(angle2) * MIRROR_SEPARATION
    };
    if (game.random() < 0.5) {
      const temp = pos1;
      pos1 = pos2;
      pos2 = temp;
    }
    const pathingSystem = game.pathingSystem;
    const layer = pathingSystem.layer(unit.position.x, unit.position.y);
    const realPosition = pathingSystem.withoutEntity(unit, () => getMirroringPosition(pos1, unit, layer));
    unit.position.setXY(realPosition.x, realPosition.y);
    const klass = unit.constructor;
    const mirror2 = new klass({
      x: unit.position.x,
      y: unit.position.y,
      owner: unit.owner,
      isIllusion: true,
      facing: unit.facing
    });
    const mirrorPos = getMirroringPosition(pos2, mirror2, layer);
    mirror2.position.setXY(mirrorPos.x, mirrorPos.y);
    new PathingComponent(mirror2);
    unit.mirrors?.push(mirror2);
  }, 0.5);
}, "mirror");
var mirrorAction = {
  name: "Mirror Image",
  hotkey: "r",
  type: "custom",
  localHandler: ({player}) => {
    const ownUnits = player.game.selectionSystem.selection.filter((u3) => isUnit(u3) && u3.owner === player);
    const realUntis = ownUnits.filter((u3) => isUnit(u3) && !u3.isIllusion && !isMirroring(u3));
    if (realUntis.length)
      player.game.transmit({
        type: "mirror",
        sprites: realUntis.map((u3) => u3.id)
      });
  },
  syncHandler: ({time, connection, sprites}) => {
    const game = currentGame();
    game.update({time});
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    player.sprites.filter((s3) => sprites.includes(s3.id) && isUnit(s3) && s3.actions.includes(mirrorAction)).forEach((u3) => mirror(u3));
  }
};
var DamageComponent = /* @__PURE__ */ __name(class extends Component {
  initialize(weapons, autoAttack) {
    const mutable = this;
    mutable.weapons = weapons;
    mutable.autoAttack = autoAttack;
  }
}, "DamageComponent");
__name2(DamageComponent, "DamageComponent");
var ThreeObjectComponent = /* @__PURE__ */ __name(class extends Component {
  constructor() {
    super(...arguments);
    this.derived = true;
  }
  initialize(object) {
    const mutable = this;
    mutable.object = object;
    mutable.mixer = new AnimationMixer(object);
  }
}, "ThreeObjectComponent");
__name2(ThreeObjectComponent, "ThreeObjectComponent");
var defined = /* @__PURE__ */ __name2((value) => !!value, "defined");
var isObject = /* @__PURE__ */ __name2((obj) => typeof obj === "object" && !!obj, "isObject");
var _Position = /* @__PURE__ */ __name(class extends Component {
  static setXY(entity, x3, y3, zOffset) {
    return whileReplacingComponent(() => {
      const component = entity.get(_Position)[0];
      if (component)
        entity.clear(this);
      return new _Position(entity, x3, y3, {
        zOffset: zOffset ?? component?.zOffset
      });
    });
  }
  constructor(entity, x3, y3, {zOffset = 0} = {}) {
    super(entity, x3, y3, {zOffset});
  }
  initialize(x3, y3, {zOffset}) {
    const mutable = this;
    mutable.x = x3;
    mutable.y = y3;
    mutable.zOffset = zOffset;
  }
  setXY(x3, y3, zOffset) {
    return _Position.setXY(this.entity, x3, y3, zOffset);
  }
}, "_Position");
var Position = _Position;
Position.argMap = ["x", "y"];
__name2(Position, "Position");
var hasPositionProp = /* @__PURE__ */ __name2((entity) => isObject(entity) && isObject(entity.position) && typeof entity.position.x === "number" && typeof entity.position.y === "number", "hasPositionProp");
var getXY = /* @__PURE__ */ __name2((entity) => {
  if (isEntity(entity)) {
    const position = entity.get(Position)[0];
    if (position)
      return {x: position.x, y: position.y};
  }
  if (hasPositionProp(entity))
    return {x: entity.position.x, y: entity.position.y};
  if ("x" in entity && typeof entity.x === "number" && typeof entity.y === "number")
    return {x: entity.x, y: entity.y};
  throw new Error("Could not get XY from object");
}, "getXY");
var Widget = /* @__PURE__ */ __name(class extends Entity {
  constructor({id, x: x3, y: y3, zOffset}) {
    super(id);
    new Position(this, x3, y3, {zOffset});
  }
  get position() {
    const pos2 = this.get(Position);
    if (pos2.length !== 1)
      throw new Error(`Expected a Position, got ${pos2.length}`);
    return pos2[0];
  }
  get model() {
    const mdl = this.get(ThreeObjectComponent);
    if (mdl.length !== 1)
      throw new Error(`Expected a ThreeObjectComponent, got ${mdl.length}`);
    return mdl[0];
  }
}, "Widget");
Widget.isWidget = true;
__name2(Widget, "Widget");
var SELECTION_CRICLE_ZOFFSET = 0.0625;
var SelectionCircle = /* @__PURE__ */ __name(class extends Widget {
  constructor({
    radius,
    color,
    x: x3,
    y: y3,
    zOffset = 0
  }) {
    super({
      id: "SELECTION_CIRCLE",
      x: x3,
      y: y3,
      zOffset: zOffset + SELECTION_CRICLE_ZOFFSET
    });
    const geometry = new TorusGeometry(radius, radius * 0.05, 3, 24);
    const material = new MeshBasicMaterial({
      color
    });
    const mesh = new Mesh(geometry, material);
    new ThreeObjectComponent(this, mesh);
    currentGame().add(this);
  }
}, "SelectionCircle");
SelectionCircle.isSelectionCircle = true;
__name2(SelectionCircle, "SelectionCircle");
var hasCollisionRadius = /* @__PURE__ */ __name2((entity) => "collisionRadius" in entity, "hasCollisionRadius");
var Circle = /* @__PURE__ */ __name(class extends Component {
  constructor(entity, props = {}) {
    const xy = getXY(entity);
    super(entity, {
      radius: props.radius ?? (hasCollisionRadius(entity) ? entity.collisionRadius * 1.25 : 1),
      color: props.color ?? "#00FF00",
      x: xy?.x ?? 999999,
      y: xy?.y ?? 999999,
      zOffset: entity.get(Position)[0]?.zOffset ?? 0
    });
  }
  initialize({radius, color, x: x3, y: y3, zOffset}) {
    this.circle = new SelectionCircle({
      radius,
      color,
      x: x3,
      y: y3,
      zOffset
    });
  }
  dispose() {
    currentGame().remove(this.circle);
    super.dispose();
  }
}, "Circle");
__name2(Circle, "Circle");
var Hover = /* @__PURE__ */ __name(class extends Circle {
  constructor(entity, props = {}) {
    if (!props.color)
      props.color = "#FFFF00";
    super(entity, props);
  }
}, "Hover");
__name2(Hover, "Hover");
var distanceBetweenPoints = /* @__PURE__ */ __name2(({x: x1, y: y1}, {x: x22, y: y22}) => Math.sqrt((x22 - x1) ** 2 + (y22 - y1) ** 2), "distanceBetweenPoints");
var elems = false;
var shortenPath = /* @__PURE__ */ __name2((points, amount) => {
  if (amount <= 0)
    return points;
  if (points.length === 1)
    return points;
  let index = points.length - 2;
  const origin = points[index + 1];
  let distance = Math.sqrt((origin.x - points[index].x) ** 2 + (origin.y - points[index].y) ** 2);
  while (distance < amount && index >= 0) {
    index--;
    if (index < 0)
      break;
    distance = Math.sqrt((origin.x - points[index].x) ** 2 + (origin.y - points[index].y) ** 2);
  }
  if (index < 0)
    return [points[0]];
  const u3 = {
    x: points[index].x - origin.x,
    y: points[index].y - origin.y
  };
  const v3 = {
    x: points[index + 1].x - origin.x,
    y: points[index + 1].y - origin.y
  };
  const a3 = (u3.x - v3.x) ** 2 + (u3.y - v3.y) ** 2;
  const b3 = 2 * (v3.x * (u3.x - v3.x) + v3.y * (u3.y - v3.y));
  const c3 = v3.x ** 2 + v3.y ** 2 - amount ** 2;
  const disc = b3 ** 2 - 4 * a3 * c3;
  const progress = (-b3 + Math.sqrt(disc)) / (2 * a3);
  const path = points.slice(0, index + 1);
  path.push({
    x: points[index + 1].x + (points[index].x - points[index + 1].x) * progress,
    y: points[index + 1].y + (points[index].y - points[index + 1].y) * progress
  });
  return path;
}, "shortenPath");
var tweenPoints = /* @__PURE__ */ __name2((points) => {
  points = points.filter((p3, i3) => points.findIndex((p22) => p22.x === p3.x && p22.y === p3.y) === i3);
  if (points.some((p3) => isNaN(p3.x) || isNaN(p3.y)))
    console.error(new Error("received bad point"));
  if (typeof document !== "undefined") {
    if (elems) {
      elems.forEach((elem2) => document.body.removeChild(elem2));
      elems.splice(0);
      points.forEach((p3) => {
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.top = p3.y * 32 - 2 + "px";
        div.style.left = p3.x * 32 - 2 + "px";
        div.style.zIndex = 1e4 .toString();
        div.style.width = "4px";
        div.style.height = "4px";
        div.style.background = "black";
        document.body.appendChild(div);
        elems.push(div);
      });
    }
  }
  const annotatedPoints = points.map((p3) => ({
    x: p3.x,
    y: p3.y,
    start: 0,
    end: 0,
    xDeltaToNext: NaN,
    yDeltaToNext: NaN,
    distance: NaN
  }));
  if (points[1])
    annotatedPoints[0].end = distanceBetweenPoints(points[1], points[0]);
  for (let i3 = 0; i3 < points.length; i3++) {
    if (i3 > 0)
      annotatedPoints[i3].start = annotatedPoints[i3 - 1].end;
    if (i3 < points.length - 1) {
      annotatedPoints[i3].xDeltaToNext = annotatedPoints[i3 + 1].x - annotatedPoints[i3].x;
      annotatedPoints[i3].yDeltaToNext = annotatedPoints[i3 + 1].y - annotatedPoints[i3].y;
      annotatedPoints[i3].end = (annotatedPoints[i3].start ?? 0) + distanceBetweenPoints(points[i3], points[i3 + 1]);
      annotatedPoints[i3].distance = (annotatedPoints[i3].end ?? 0) - (annotatedPoints[i3].start ?? 0);
    }
  }
  let curPoint = 0;
  const func = points.length > 1 ? (progress) => {
    if (progress < 0)
      throw new Error("Progress should be greater than 0");
    while (progress < annotatedPoints[curPoint].start)
      curPoint--;
    while (progress > annotatedPoints[curPoint].end && curPoint < points.length - 1)
      curPoint++;
    if (annotatedPoints[curPoint].end === void 0)
      return annotatedPoints[curPoint];
    const percentProgress = (progress - annotatedPoints[curPoint].start) / (annotatedPoints[curPoint].distance || Infinity);
    if (curPoint === points.length - 1)
      return points[curPoint];
    if (isNaN(annotatedPoints[curPoint].x) || isNaN(percentProgress * annotatedPoints[curPoint].xDeltaToNext))
      throw "NaN";
    return {
      x: annotatedPoints[curPoint].x + percentProgress * annotatedPoints[curPoint].xDeltaToNext,
      y: annotatedPoints[curPoint].y + percentProgress * annotatedPoints[curPoint].yDeltaToNext
    };
  } : () => points[0];
  const distance = annotatedPoints[points.length - 1].start;
  let internalProgress = 0;
  Object.defineProperty(func, "remaining", {
    get: () => distance - internalProgress
  });
  return Object.assign(func, {
    distance,
    step: (deltaProgress) => {
      internalProgress = Math.min(distance, internalProgress + deltaProgress);
      return func(internalProgress);
    },
    origin: points[0],
    target: points[points.length - 1],
    radialStepBack: (amount) => {
      if (points.length === 1)
        return points[0];
      let index = points.length - 2;
      const origin = points[index + 1];
      let distance2 = Math.sqrt((origin.x - points[index].x) ** 2 + (origin.y - points[index].y) ** 2);
      while (distance2 < amount && index >= 0) {
        index--;
        if (index < 0)
          break;
        distance2 = Math.sqrt((origin.x - points[index].x) ** 2 + (origin.y - points[index].y) ** 2);
      }
      if (index < 0)
        return points[0];
      const u3 = {
        x: points[index].x - origin.x,
        y: points[index].y - origin.y
      };
      const v3 = {
        x: points[index + 1].x - origin.x,
        y: points[index + 1].y - origin.y
      };
      const a3 = (u3.x - v3.x) ** 2 + (u3.y - v3.y) ** 2;
      const b3 = 2 * (v3.x * (u3.x - v3.x) + v3.y * (u3.y - v3.y));
      const c3 = v3.x ** 2 + v3.y ** 2 - amount ** 2;
      const disc = b3 ** 2 - 4 * a3 * c3;
      const progress = (-b3 + Math.sqrt(disc)) / (2 * a3);
      return {
        x: points[index + 1].x + (points[index].x - points[index + 1].x) * progress,
        y: points[index + 1].y + (points[index].y - points[index + 1].y) * progress
      };
    },
    points,
    toJSON: () => ({points})
  });
}, "tweenPoints");
var isPoint = /* @__PURE__ */ __name2((target2) => "x" in target2 && "y" in target2, "isPoint");
var calcAndTweenShortenedPath = /* @__PURE__ */ __name2((entity, target2, distanceToShorten) => {
  const targetPoint = isPoint(target2) ? target2 : target2.position;
  const pathingSystem = currentGame().pathingSystem;
  if (!pathingSystem)
    throw new Error("Expected pathingSystem to be instantiated");
  const path = isPoint(target2) ? pathingSystem.path(entity, targetPoint) : pathingSystem.withoutEntity(target2, () => pathingSystem.path(entity, targetPoint));
  const end = path[path.length - 1];
  const distanceFromPathEndToTarget = distanceBetweenPoints(end, targetPoint);
  const remainingDistance = distanceToShorten - distanceFromPathEndToTarget;
  if (remainingDistance <= 0)
    return tweenPoints(path);
  return tweenPoints(shortenPath(path, remainingDistance));
}, "calcAndTweenShortenedPath");
var MoveTarget = /* @__PURE__ */ __name(class extends Component {
  constructor({
    entity,
    target: target2,
    distance = 0,
    path
  }) {
    super(entity);
    this.ticks = 0;
    this.progress = 0;
    this.renderProgress = 0;
    this.target = target2;
    this.distance = distance;
    if (!path)
      path = calcAndTweenShortenedPath(entity, target2, distance);
    else if (distance > 0 && Math.abs(distanceBetweenPoints(path.target, getXY(target2)) - distance) < 1e-7)
      path = tweenPoints(shortenPath(path.points, distance));
    this.path = path;
  }
  recalc() {
    this.path = calcAndTweenShortenedPath(this.entity, this.target, this.distance);
    this.progress = 0;
    this.renderProgress = 0;
    this.ticks = 0;
  }
}, "MoveTarget");
__name2(MoveTarget, "MoveTarget");
var Selected = /* @__PURE__ */ __name(class extends Circle {
  constructor(entity, props = {}) {
    if (!props.color)
      props.color = "#00FF00";
    super(entity, props);
  }
}, "Selected");
__name2(Selected, "Selected");
var _Timer = /* @__PURE__ */ __name(class extends Component {
  constructor(entity, fn, timeout, periodic = false, oncePerUpdate = true, next, derivedIndex) {
    super(entity, fn, timeout, periodic, oncePerUpdate, next, derivedIndex);
  }
  initialize(fn, timeout, periodic, oncePerUpdate, next, derivedIndex) {
    const mutable = this;
    mutable.fn = fn;
    mutable.timeout = timeout;
    mutable.periodic = periodic;
    mutable.oncePerUpdate = oncePerUpdate;
    if (typeof derivedIndex === "number")
      mutable.derivedIndex = derivedIndex;
    this.next = next ?? currentGame().time + timeout;
  }
  static fromJSON(entity, timeout, periodic, oncePerUpdate, next, derivedIndex) {
    if (typeof derivedIndex !== "number")
      throw new Error("Unable to hydrate timer without derivedIndex");
    const game = currentGame();
    const derivedCallbacks = _Timer.derivedCallbacks.get(game);
    const fn = derivedCallbacks?.[derivedIndex]();
    if (!fn)
      throw new Error("Unable to hydrate timer with invalid derivedIndex");
    return new _Timer(entity, fn, timeout, periodic, oncePerUpdate, next, derivedIndex);
  }
}, "_Timer");
var Timer = _Timer;
Timer.argMap = [
  "timeout",
  "periodic",
  "oncePerUpdate",
  "next",
  "derivedIndex"
];
Timer.derivedCallbacks = new WeakMap();
Timer.registerDerviedCallback = (fn) => {
  const game = currentGame();
  let derivedCallbacks = _Timer.derivedCallbacks.get(game);
  if (!derivedCallbacks) {
    derivedCallbacks = [];
    _Timer.derivedCallbacks.set(game, derivedCallbacks);
  }
  const existing = derivedCallbacks.indexOf(fn);
  if (existing >= 0)
    return existing;
  return derivedCallbacks.push(fn) - 1;
};
__name2(Timer, "Timer");
var TimerWindow = /* @__PURE__ */ __name(class extends Component {
  initialize(title) {
    const mutable = this;
    mutable.title = title;
  }
}, "TimerWindow");
TimerWindow.argMap = ["title"];
__name2(TimerWindow, "TimerWindow");
var polarProject = /* @__PURE__ */ __name2((point, angle, distance) => ({
  x: point.x + Math.cos(angle) * distance,
  y: point.y + Math.sin(angle) * distance
}), "polarProject");
var orientation = /* @__PURE__ */ __name2((p1, p22, p3) => (p3.x - p1.x) * (p22.y - p1.y) - (p3.y - p1.y) * (p22.x - p1.x), "orientation");
var behind = /* @__PURE__ */ __name2((leftTangent, rightTangent, x3, y3) => orientation(leftTangent, rightTangent, {x: x3, y: y3}) < 0, "behind");
var infront = /* @__PURE__ */ __name2((leftTangent, rightTangent, x3, y3) => orientation(leftTangent, rightTangent, {x: x3, y: y3}) > 0, "infront");
var trueMinX = /* @__PURE__ */ __name2((point, radius, y3, offValue) => {
  if (Math.abs(point.y - y3) - 0.5 <= 1)
    return offValue;
  if (y3 > point.y) {
    const squared2 = -(point.y ** 2) + 2 * point.y * y3 + radius ** 2 - y3 ** 2;
    const core2 = Math.sign(squared2) * Math.abs(squared2) ** 0.5;
    return Math.floor(point.x - core2);
  }
  const squared = -(point.y ** 2) + 2 * point.y * (y3 + 1) + radius ** 2 - (y3 + 1) ** 2;
  const core = Math.sign(squared) * Math.abs(squared) ** 0.5;
  return Math.floor(point.x - core);
}, "trueMinX");
var trueMaxX = /* @__PURE__ */ __name2((point, radius, y3, offValue) => {
  if (Math.abs(point.y - y3) - 0.5 <= 1)
    return offValue;
  if (y3 > point.y) {
    const squared2 = -(point.y ** 2) + 2 * point.y * y3 + radius ** 2 - y3 ** 2;
    const core2 = Math.sign(squared2) * Math.abs(squared2) ** 0.5;
    return Math.floor(point.x + core2);
  }
  const squared = -(point.y ** 2) + 2 * point.y * (y3 + 1) + radius ** 2 - (y3 + 1) ** 2;
  const core = Math.sign(squared) * Math.abs(squared) ** 0.5;
  return Math.floor(point.x + core);
}, "trueMaxX");
var offset = /* @__PURE__ */ __name2((point, offset22) => ({
  x: point.x + offset22,
  y: point.y + offset22
}), "offset");
var interpolateZ = /* @__PURE__ */ __name2(([a3, b3, c3], x3, y3) => {
  const v1 = a3.clone().sub(b3);
  const v22 = a3.clone().sub(c3);
  const n2 = v1.cross(v22);
  const k3 = n2.x * a3.x + n2.y * a3.y + n2.z * a3.z;
  return (k3 - n2.x * x3 - n2.y * y3) / n2.z;
}, "interpolateZ");
var Terrain2 = /* @__PURE__ */ __name(class extends Entity {
  constructor(arena) {
    super("TERRAIN");
    const vertexZeroes = Array(arena.height + 1).fill(new Array(arena.width + 1).fill(0));
    this.height = arena.height;
    const group = new Terrain({
      masks: {
        height: vertexZeroes,
        cliff: arena.cliffs,
        groundTile: arena.pathing,
        cliffTile: arena.cliffs.map((r3) => r3.map(() => 4)),
        water: arena.cliffs.map((r3) => r3.map((v3) => v3 === 0 ? 1 : 0)),
        waterHeight: vertexZeroes
      },
      offset: {
        x: 0,
        y: this.height,
        z: 0
      },
      tiles: [
        LordaeronSummerDarkGrass,
        LordaeronSummerGrass,
        LordaeronSummerRock,
        LordaeronSummerGrass,
        LordaeronSummerDirtCliff
      ],
      size: {
        width: arena.width,
        height: arena.height
      }
    });
    new ThreeObjectComponent(this, group);
    this.group = group;
  }
  groundHeight(x3, y3) {
    if (this.lastGroundHeight) {
      if (this.lastGroundHeight.x === x3 && this.lastGroundHeight.y === y3)
        return this.lastGroundHeight.height;
    }
    const pt = {x: x3, y: y3};
    let triangle;
    const faces = this.group.groundFaces[Math.floor(this.height - y3)]?.[Math.floor(x3)];
    if (!faces)
      return 0;
    {
      const v1 = faces[0].a;
      const v22 = faces[0].b;
      const v3 = faces[0].c;
      const side1 = Math.abs(orientation(pt, v1, v22)) < 1e-7;
      const side2 = Math.abs(orientation(pt, v22, v3)) < 1e-7;
      const side3 = Math.abs(orientation(pt, v3, v1)) < 1e-7;
      triangle = side1 === side2 && side2 === side3 ? [v1, v22, v3] : [faces[1].a, faces[1].b, faces[1].c];
    }
    const height = interpolateZ(triangle, x3, -this.height + y3);
    this.lastGroundHeight = {x: x3, y: y3, height};
    return height;
  }
}, "Terrain");
__name2(Terrain2, "Terrain");
var UNPATHABLE = PATHING_TYPES.WALKABLE + PATHING_TYPES.BUILDABLE;
var getHeight = /* @__PURE__ */ __name2((arena) => arena.cliffs.length * 2, "getHeight");
var getWidth = /* @__PURE__ */ __name2((arena) => Math.max(...arena.cliffs.map((l3) => l3.length)) * 2, "getWidth");
var _asMaxNum = /* @__PURE__ */ __name2((v3) => typeof v3 === "number" ? v3 : -Infinity, "_asMaxNum");
var cliffHeight = /* @__PURE__ */ __name2((cliffs, x3, y3) => {
  const v3 = cliffs[y3][x3];
  if (typeof v3 === "number")
    return v3;
  return Math.max(_asMaxNum(cliffs[y3][x3 - 1]), _asMaxNum(cliffs[y3][x3 + 1]), _asMaxNum(cliffs[y3 - 1][x3]), _asMaxNum(cliffs[y3 + 1][x3]));
}, "cliffHeight");
var getPathingCliffs = /* @__PURE__ */ __name2((cliffs) => cliffs.map((row, y3) => row.map((_2, x3) => cliffHeight(cliffs, x3, y3))), "getPathingCliffs");
var neighbors = [
  {x: -1, y: -1},
  {x: 0, y: -1},
  {x: 1, y: -1},
  {x: -1, y: 0},
  {x: 1, y: 0},
  {x: -1, y: 1},
  {x: 0, y: 1},
  {x: 1, y: 1}
];
var double = /* @__PURE__ */ __name2((arr) => {
  const newArr = [];
  for (const row of arr) {
    const newRow = [];
    for (const value of row)
      newRow.push(value, value);
    newArr.push(newRow, [...newRow]);
  }
  return newArr;
}, "double");
var processArena = /* @__PURE__ */ __name2((arena) => {
  const height = getHeight(arena);
  const width = getWidth(arena);
  const cliffs = double(arena.cliffs.map((row) => row.map((v3) => v3 ?? 0)));
  const tiles = double(arena.tiles);
  const pathing = Array(height).fill(0).map((_2, y3) => Array(width).fill(0).map((_22, x3) => {
    if (y3 === 0 || y3 === height - 1 || x3 === 0 || x3 === width - 1)
      return UNPATHABLE;
    const cur = cliffs[y3][x3];
    let rampNeighbors = 0;
    let firstNonRampNeighrborHeight;
    let firstDiagRamp;
    for (const neighbor of neighbors) {
      const tile = cliffs[y3 + neighbor.y]?.[x3 + neighbor.x];
      if (tile === void 0)
        return UNPATHABLE;
      if (tile !== "r")
        if (firstNonRampNeighrborHeight !== void 0) {
          if (firstNonRampNeighrborHeight !== tile)
            return UNPATHABLE;
        } else
          firstNonRampNeighrborHeight = tile;
      else {
        rampNeighbors++;
        if (neighbor.x !== 0 && neighbor.y !== 0)
          firstDiagRamp = neighbor;
      }
    }
    if (rampNeighbors === 1 || rampNeighbors === 2 || cur === "r" && rampNeighbors === 3) {
      if (cliffs[y3 + firstDiagRamp.y]?.[x3 + firstDiagRamp.x * 3] !== "r" || cliffs[y3 + firstDiagRamp.y * 3]?.[x3 + firstDiagRamp.x] !== "r")
        return UNPATHABLE;
    }
    if (tiles[y3]?.[x3] === 1 || tiles[y3]?.[x3] === 2)
      return PATHING_TYPES.BUILDABLE;
    return 0;
  }));
  return {
    cliffs,
    height,
    name: arena.name,
    pathing,
    tiles,
    width,
    pathingCliffs: getPathingCliffs(cliffs)
  };
}, "processArena");
var leftTrim2 = /* @__PURE__ */ __name2((v3) => {
  const match = v3.match(/^\s+/);
  return match ? match[0].length : 0;
}, "leftTrim");
var commonLeftTrim2 = /* @__PURE__ */ __name2((rows) => rows.reduce((min, row) => Math.min(min, leftTrim2(row)), leftTrim2(rows[0])), "commonLeftTrim");
var trimMap = /* @__PURE__ */ __name2((map) => {
  const rows = map.split("\n").filter((v3) => v3.trim());
  const minLeftTrim = commonLeftTrim2(rows);
  return rows.map((row) => row.trimRight().slice(minLeftTrim)).join("\n");
}, "trimMap");
var stringMap2 = /* @__PURE__ */ __name2((map) => trimMap(map).split("\n").map((r3) => r3.split("").map((v3) => {
  const num = parseInt(v3);
  if (isNaN(num))
    return 0;
  return num;
})), "stringMap");
var stringMapWithRamps = /* @__PURE__ */ __name2((map, floor = 0) => trimMap(map).split("\n").map((r3) => r3.split("").map((v3) => {
  if (v3 === "r")
    return "r";
  if (v3 === " ")
    return floor;
  const num = parseInt(v3);
  return num;
})), "stringMapWithRamps");
var AttackTarget = /* @__PURE__ */ __name(class extends Component {
  initialize(target2) {
    const mutable = this;
    mutable.target = target2;
  }
}, "AttackTarget");
__name2(AttackTarget, "AttackTarget");
var GerminateComponent = /* @__PURE__ */ __name(class extends Component {
  constructor() {
    super(...arguments);
    this.progress = INITIAL_OBSTRUCTION_PROGRESS;
  }
}, "GerminateComponent");
__name2(GerminateComponent, "GerminateComponent");
var HoldPositionComponent = /* @__PURE__ */ __name(class extends Component {
}, "HoldPositionComponent");
__name2(HoldPositionComponent, "HoldPositionComponent");
var clone = /* @__PURE__ */ __name2((obj) => {
  const data = Array.isArray(obj) ? [] : {};
  for (const prop in obj)
    data[prop] = typeof obj[prop] === "object" && obj[prop] !== null ? clone(obj[prop]) : obj[prop];
  return data;
}, "clone");
var spriteDerivedComponents = [Position.name, MeshBuilderComponent.name];
var _Sprite = /* @__PURE__ */ __name(class extends Widget {
  constructor({
    armor = 0,
    blocksPathing = PATHING_TYPES.WALKABLE | PATHING_TYPES.BUILDABLE,
    color,
    facing = 3 / 2 * Math.PI,
    maxHealth = 1,
    health = maxHealth,
    meshBuilder = clone(_Sprite.defaults.meshBuilder),
    owner,
    priority = 0,
    collisionRadius = _Sprite.defaults.collisionRadius,
    requiresPathing = PATHING_TYPES.WALKABLE,
    selectable = true,
    ...props
  }) {
    super(props);
    this.effects = [];
    this.invulnerable = false;
    emitter(this);
    this.collisionRadius = collisionRadius;
    this.requiresPathing = requiresPathing;
    this.blocksPathing = blocksPathing;
    this.maxHealth = maxHealth;
    this.health = health;
    this.isAlive = this.health > 0;
    this.armor = armor;
    this.priority = priority;
    this.owner = owner;
    this.facing = facing;
    this.color = color;
    this.selectable = selectable;
    new MeshBuilderComponent(this, {
      ...meshBuilder,
      scale: meshBuilder.scale ?? collisionRadius,
      targetable: selectable
    });
    if (this.owner)
      this.owner.sprites.push(this);
    currentGame().add(this);
  }
  static get clonedDefaults() {
    return clone(this.defaults);
  }
  damage(amount) {
    if (this.invulnerable)
      return 0;
    const effectiveArmor = this.has(GerminateComponent) ? 0 : this.armor;
    const actualDamage = amount * (1 - effectiveArmor);
    if (this.health <= 0)
      return actualDamage;
    this.health -= actualDamage;
    return actualDamage;
  }
  kill({removeImmediately = false} = {}) {
    if (removeImmediately)
      this._death({removeImmediately: true});
    else
      this.health = 0;
  }
  set health(value) {
    this._health = Math.min(Math.max(value, 0), this.maxHealth);
    this.dispatchEvent("change", "health", this._health);
    if (value <= 0 && this.isAlive) {
      this.isAlive = false;
      this._death();
    } else
      this.isAlive = true;
  }
  get health() {
    return this._health;
  }
  _death({removeImmediately = false} = {}) {
    const game = currentGame();
    if (removeImmediately) {
      this._health = 0;
      this.isAlive = false;
    }
    this.clear(Selected);
    this.clear(Hover);
    this.clear(PathingComponent);
    if (this.owner) {
      const index = this.owner.sprites.indexOf(this);
      if (index >= 0)
        this.owner.sprites.splice(index, 1);
    }
    this.dispatchEvent("death");
    if (removeImmediately)
      this.remove();
    else
      game.setTimeout(() => this.remove(), 0.125);
  }
  remove(callInitializedFromApp = false) {
    const game = currentGame();
    this.isAlive = false;
    this.dispatchEvent("remove");
    if (!callInitializedFromApp)
      game.remove(this);
    this.removeEventListeners();
    if (this.owner) {
      const index = this.owner.sprites.indexOf(this);
      if (index >= 0)
        this.owner.sprites.splice(index, 1);
    }
  }
  get actions() {
    return [];
  }
  get idle() {
    return !ActiveComponent.has(this) && !MoveTarget.has(this) && !AttackTarget.has(this) && !HoldPositionComponent.has(this) && !GerminateComponent.has(this) && this.isAlive;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      type: this.constructor.name,
      health: this.health,
      owner: this.owner?.id
    };
  }
  static fromJSON({
    components,
    type,
    owner: ownerId,
    ...data
  }) {
    const game = currentGame();
    const map = components.reduce((map2, component) => {
      if (!map2[component.type])
        map2[component.type] = {
          class: game.componentsMap[component.type],
          components: []
        };
      map2[component.type].components.push(component);
      return map2;
    }, {});
    const position = map.Position?.components[0] ?? {x: 0, y: 0};
    const x3 = typeof position.x === "number" ? position.x : 0;
    const y3 = typeof position.y === "number" ? position.y : 0;
    const owner = ownerId === void 0 ? void 0 : game.players.find((p3) => p3.id === ownerId);
    const entity = new this({x: x3, y: y3, owner, ...data});
    for (const {type: type2, ...componentProps} of components.filter((c3) => !spriteDerivedComponents.includes(c3.type))) {
      const constructor = game.componentsMap[type2];
      if (!constructor) {
        console.warn(`Unable to hydrate unknown component ${type2}`);
        continue;
      }
      const args = constructor.argMap.map((k3) => componentProps[k3]);
      constructor.fromJSON(entity, ...args, componentProps);
    }
    return entity;
  }
}, "_Sprite");
var Sprite2 = _Sprite;
Sprite2.isSprite = true;
Sprite2.defaults = {
  collisionRadius: 1,
  meshBuilder: {shape: "circle"}
};
__name2(Sprite2, "Sprite");
var _Projectile = /* @__PURE__ */ __name(class extends Sprite2 {
  constructor({
    producer,
    target: target2,
    speed = _Projectile.defaults.speed,
    splash = _Projectile.defaults.splash,
    damage,
    onDamage,
    ...props
  }) {
    super({
      ..._Projectile.clonedDefaults,
      x: producer.position.x,
      y: producer.position.y,
      ...props
    });
    this.producer = producer;
    this.splash = splash;
    this.damageAmount = damage;
    this.onDamage = onDamage;
    this.speed = speed;
    new MoveTarget({entity: this, target: target2});
  }
}, "_Projectile");
var Projectile = _Projectile;
Projectile.isProjectile = true;
Projectile.defaults = {
  ...Sprite2.defaults,
  collisionRadius: 3,
  speed: 4,
  splash: 2.5,
  maxHealth: Infinity,
  selectable: false,
  blocksPathing: 0,
  requiresPathing: 0,
  meshBuilder: {
    ...Sprite2.defaults.meshBuilder,
    color: "#0000ff",
    opacity: 0.25,
    shadows: false
  }
};
__name2(Projectile, "Projectile");
var cancelAction = {
  name: "Cancel",
  hotkey: "Escape",
  type: "custom",
  localHandler: ({player}) => {
    player.game.obstructionPlacement?.stop();
  }
};
var holdPositionAction = {
  name: "Hold Position",
  hotkey: "h",
  type: "custom",
  localHandler: ({player}) => {
    const ownedUnits = player.game.selectionSystem.selection.filter((u3) => isUnit(u3) && u3.owner === player && u3.speed > 0);
    if (ownedUnits.length > 0)
      player.game.transmit({
        type: "holdPosition",
        sprites: ownedUnits.map((u3) => u3.id)
      });
  },
  syncHandler: ({time, connection, sprites}) => {
    const game = currentGame();
    game.update({time});
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    player.sprites.filter((s3) => sprites.includes(s3.id)).filter(isUnit).forEach((s3) => s3.holdPosition());
  }
};
var stopAction = {
  name: "Stop",
  hotkey: "s",
  type: "custom",
  localHandler: ({player}) => {
    const ownedUnits = player.game.selectionSystem.selection.filter((u3) => isUnit(u3) && u3.owner === player);
    if (ownedUnits.length > 0)
      player.game.transmit({
        type: "stop",
        sprites: ownedUnits.map((u3) => u3.id)
      });
  },
  syncHandler: ({time, connection, sprites}) => {
    const game = currentGame();
    game.update({time});
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    player.sprites.filter((s3) => sprites.includes(s3.id)).filter(isUnit).forEach((s3) => s3.stop());
  }
};
var isInAttackRange = /* @__PURE__ */ __name2((attacker, target2, includeRangeMotionBuffer = false) => {
  const damageComponent = attacker.get(DamageComponent)[0];
  if (!damageComponent)
    return false;
  const weapon = damageComponent.weapons[0];
  const distanceToTarget = Math.sqrt((target2.position.x - attacker.position.x) ** 2 + (target2.position.y - attacker.position.y) ** 2);
  return distanceToTarget <= weapon.range + attacker.collisionRadius + (isUnit(target2) ? target2.collisionRadius : 0) + (includeRangeMotionBuffer ? weapon.rangeMotionBuffer ?? 0 : 0);
}, "isInAttackRange");
var Blueprint = /* @__PURE__ */ __name(class extends Sprite2 {
  constructor({
    obstruction,
    ...props
  }) {
    const clonedDefaults = obstruction.clonedDefaults;
    super({
      ...clonedDefaults,
      selectable: false,
      id: Math.random() * -1,
      color: "rgba( 70, 145, 246 )",
      meshBuilder: {
        ...clonedDefaults.meshBuilder,
        colorFilter: void 0,
        opacity: 0.5
      },
      ...props
    });
  }
}, "Blueprint");
Blueprint.buildTime = 0;
__name2(Blueprint, "Blueprint");
var BuildTarget = /* @__PURE__ */ __name(class extends Component {
  constructor(entity, obstructionClass, target2) {
    super(entity);
    this.obstructionClass = obstructionClass;
    this.target = target2;
    this.blueprint = entity.owner === currentGame().localPlayer ? new Blueprint({
      ...target2,
      obstruction: obstructionClass
    }) : void 0;
  }
  dispose() {
    this.blueprint?.kill({removeImmediately: true});
  }
}, "BuildTarget");
__name2(BuildTarget, "BuildTarget");
var NoWeaponError = /* @__PURE__ */ __name(class extends Error {
  constructor() {
    super(...arguments);
    this.message = "No weapon";
  }
}, "NoWeaponError");
__name2(NoWeaponError, "NoWeaponError");
var TargetTooFarError = /* @__PURE__ */ __name(class extends Error {
  constructor() {
    super(...arguments);
    this.message = "Target too far";
  }
}, "TargetTooFarError");
__name2(TargetTooFarError, "TargetTooFarError");
var revealIllusion = /* @__PURE__ */ __name2((owner) => {
  const game = currentGame();
  return game.alliances.isAlly(owner, game.localPlayer);
}, "revealIllusion");
var darkBlue = new Color("#191966");
var _Unit = /* @__PURE__ */ __name(class extends Sprite2 {
  constructor({
    autoAttack = _Unit.defaults.autoAttack,
    builds = [],
    isIllusion = _Unit.defaults.isIllusion,
    name,
    speed = _Unit.defaults.speed,
    weapon,
    meshBuilder,
    ...props
  }) {
    super({
      ...props,
      meshBuilder: {
        ..._Unit.defaults.meshBuilder,
        ...meshBuilder,
        ...isIllusion && revealIllusion(props.owner) ? {
          colorFilter: (color) => color.lerp(darkBlue, 0.75)
        } : void 0
      }
    });
    this.obstructions = [];
    this.isIllusion = isIllusion;
    this.name = name ?? this.constructor.name;
    this.speed = speed;
    this.builds = builds;
    if (weapon)
      new DamageComponent(this, [weapon], autoAttack);
  }
  attack(target2) {
    const damageComponent = this.get(DamageComponent)[0];
    if (!damageComponent)
      throw new NoWeaponError();
    BuildTarget.clear(this);
    HoldPositionComponent.clear(this);
    if (!this.speed && !isInAttackRange(this, target2))
      throw new TargetTooFarError();
    new AttackTarget(this, target2);
    new MoveTarget({
      entity: this,
      target: target2,
      distance: this.collisionRadius + damageComponent.weapons[0].range + target2.collisionRadius - 1e-7
    });
  }
  walkTo(target2) {
    this.stop();
    new MoveTarget({entity: this, target: target2});
  }
  holdPosition() {
    this.stop();
    new HoldPositionComponent(this);
  }
  stop() {
    MoveTarget.clear(this);
    AttackTarget.clear(this);
    BuildTarget.clear(this);
    HoldPositionComponent.clear(this);
  }
  buildAt(target2, ObstructionClass) {
    this.stop();
    new MoveTarget({
      entity: this,
      target: target2,
      distance: BUILD_DISTANCE - 1e-7
    });
    new BuildTarget(this, ObstructionClass, target2);
  }
  get actions() {
    const buildList = this.builds.map((klass) => klass.buildAction);
    if (buildList.length > 0)
      buildList.push(cancelAction);
    const actions = buildList;
    if (this.speed > 0)
      actions.push(holdPositionAction, stopAction);
    return actions;
  }
  toJSON() {
    return {
      ...super.toJSON()
    };
  }
}, "_Unit");
var Unit = _Unit;
Unit.isUnit = true;
Unit.defaults = {
  ...Sprite2.clonedDefaults,
  isIllusion: false,
  speed: 5.938,
  autoAttack: false
};
__name2(Unit, "Unit");
var UpgradeComponent = /* @__PURE__ */ __name(class extends Component {
  initialize(obstruction) {
    const mutable = this;
    mutable.obstruction = obstruction;
  }
  toJSON() {
    return {
      type: this.constructor.name,
      obstruction: this.obstruction.name
    };
  }
}, "UpgradeComponent");
__name2(UpgradeComponent, "UpgradeComponent");
var HTMLElement2 = globalThis.HTMLElement || class {
};
var emptyElement = /* @__PURE__ */ __name2((element) => {
  while (element.firstChild && element.firstChild instanceof HTMLElement2 && element.removeChild(element.firstChild))
    ;
}, "emptyElement");
import_marked.default.setOptions({breaks: true});
var uiElem = doc.getElementById("ui");
var scratch = doc.createElement("span");
var sanitize = /* @__PURE__ */ __name2((text) => {
  scratch.textContent = text;
  return scratch.innerHTML;
}, "sanitize");
var maxLength = 256;
var chatLog = doc.getElementById("chat-log");
var chatInputContainer = doc.getElementById("chat-input-container");
var chatInput = doc.getElementById("chat-input");
var chatInputSuggestion = doc.getElementById("chat-input-suggestion");
var commands = [];
var Chat = /* @__PURE__ */ __name(class {
  constructor() {
    this.active = false;
  }
  activate() {
    chatInputContainer.style.visibility = "visible";
    chatInput.focus();
  }
  onEnter() {
    chatInputContainer.style.visibility = "hidden";
    const message = chatInput.value;
    if (message.length) {
      this.game.transmit({
        type: "chat",
        message: chatInput.value
      });
      chatInput.value = "";
      chatInputSuggestion.value = "";
    }
  }
  onEscape() {
    chatInput.value = "";
    chatInputSuggestion.value = "";
    chatInputContainer.style.visibility = "hidden";
  }
}, "Chat");
__name2(Chat, "Chat");
var chat = new Chat();
var initChatListeners = /* @__PURE__ */ __name2((game, ui) => {
  ui.addEventListener("keyDown", ({key, target: target2}) => {
    if (!chat.active && key === "Enter" && (!target2 || !(target2 instanceof HTMLElement) || !uiElem.contains(target2)))
      chat.activate();
  });
  game.addNetworkListener("chat", ({connection, message}) => {
    message = message.slice(0, maxLength);
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    const playerTag = `<span style="color: ${player.color?.hex}">${player.username}</span>`;
    appendMessage(`${playerTag}: ${sanitize(message)}`);
  });
  chat.game = game;
  chatInput.addEventListener("keydown", wrapGame(game, (e3) => {
    e3.stopPropagation();
    if (e3.key === "Enter")
      if (chatInput.value[0] === "/")
        return onCommandEnter(chatInput.value.slice(1));
      else
        return chat.onEnter();
    if (e3.key === "Escape")
      return chat.onEscape();
    if (e3.key === "Tab") {
      e3.preventDefault();
      onCommandTab(chatInput.value.slice(1));
      return;
    }
  }));
  chatInput.addEventListener("input", wrapGame(game, () => {
    if (chatInput.value[0] === "/")
      onCommandInput(chatInput.value.slice(1));
    else
      chatInputSuggestion.value = "";
  }));
}, "initChatListeners");
var _appendMessage = /* @__PURE__ */ __name2((html) => {
  chatLog.appendChild(html);
  setTimeout(() => {
    html.style.opacity = "0";
    setTimeout(() => html.remove(), 1e3);
  }, 1e4 + (html.textContent ?? "").replace(/\s+/g, " ").trim().length * 50);
}, "_appendMessage");
var appendMessage = /* @__PURE__ */ __name2((markdown) => {
  const div = doc.createElement("div");
  div.innerHTML = (0, import_marked.default)(markdown);
  _appendMessage(div);
}, "appendMessage");
var appendGameMessage = /* @__PURE__ */ __name2((markdown) => {
  const div = doc.createElement("div");
  div.classList.add("game");
  div.innerHTML = (0, import_marked.default)(markdown);
  _appendMessage(div);
}, "appendGameMessage");
var appendErrorMessage = /* @__PURE__ */ __name2((markdown) => {
  const div = doc.createElement("div");
  div.classList.add("error");
  div.innerHTML = (0, import_marked.default)(markdown);
  _appendMessage(div);
}, "appendErrorMessage");
var onCommandInput = /* @__PURE__ */ __name2((text) => {
  const words = text.trim().split(" ");
  const firstWord = words[0].toLowerCase();
  for (const command of commands)
    if (command.name.toLowerCase().startsWith(firstWord)) {
      const name = words[0] + command.name.slice(firstWord.length);
      const args = command.args && command.args.slice(words.length - 1).map((a3) => a3.required ? `<${a3.name}>` : `[${a3.name}]`).join(" ");
      const comment = command.comment && (!command.args || words.length <= command.args.length) ? "    " + command.comment.split("\n")[0] : false;
      chatInputSuggestion.value = "/" + [name, args, comment].filter(Boolean).join(" ");
      return;
    }
  chatInputSuggestion.value = "";
}, "onCommandInput");
var onCommandEnter = /* @__PURE__ */ __name2((text) => {
  const words = text.trim().split(" ");
  const firstWord = words[0].toLowerCase();
  for (const command of commands)
    if (command.name.toLowerCase() === firstWord) {
      if (!command.args || words.length > command.args.filter((a3) => a3.required).length) {
        command.handler(...words);
        chat.onEscape();
      }
      return;
    }
}, "onCommandEnter");
var onCommandTab = /* @__PURE__ */ __name2((text) => {
  const words = text.trim().split(" ");
  const firstWord = words[0].toLowerCase();
  for (const command of commands)
    if (command.name.toLowerCase().startsWith(firstWord)) {
      if (command.name.length <= firstWord.length)
        return;
      chatInput.value = "/" + command.name + (command.args ? " " : "");
      onCommandInput(chatInput.value.slice(1));
      return;
    }
}, "onCommandTab");
var registerCommand = /* @__PURE__ */ __name2(({
  name,
  aliases,
  args,
  comment,
  handler
}) => {
  const existingCommand = commands.find((c3) => c3.name === name || c3.aliases && c3.aliases.includes(name) || aliases && aliases.includes(c3.name) || c3.aliases && aliases && c3.aliases.some((a3) => aliases.includes(a3)));
  if (existingCommand)
    throw new Error(`Command ${name} conflicts with ${existingCommand.name}`);
  commands.push({name, aliases, args, comment, handler});
  commands.sort((a3, b3) => {
    if (a3.name === "help")
      return -1;
    if (b3.name === "help")
      return 1;
    return a3.name.localeCompare(b3.name);
  });
}, "registerCommand");
registerCommand({
  name: "help",
  comment: "Shows a list of all commands",
  handler: () => {
    appendGameMessage(commands.map((command) => {
      const args = command.args && command.args.map((a3) => a3.required ? `<${a3.name}>` : `[${a3.name}]`).join(" ");
      const comment = command.comment ? `
<span style="font-weight: normal;">${command.comment}</span>` : "";
      return "/" + [command.name, args].filter(Boolean).join(" ") + comment;
    }).join("\n\n"));
  }
});
registerCommand({
  name: "clear",
  comment: "Clears the chat log",
  handler: () => {
    emptyElement(chatLog);
  }
});
var calculateUpgradeCost = /* @__PURE__ */ __name2((from, to) => {
  const toCosts = Object.entries(to.defaults.cost);
  const fromCosts = from.defaults.cost;
  return Object.fromEntries(toCosts.map(([k3, v3]) => [
    k3,
    v3 - (k3 in fromCosts ? fromCosts[k3] ?? 0 : 0)
  ]));
}, "calculateUpgradeCost");
var upgradeSyncHandler = /* @__PURE__ */ __name2(({
  time,
  connection,
  obstructions: obstructionIds,
  upgrade
}) => {
  const game = currentGame();
  game.update({time});
  const player = game.players.find((p3) => p3.id === connection);
  if (!player)
    return;
  const obstructions = player.sprites.filter((s3) => obstructionIds.includes(s3.id));
  let obstructionClass;
  let hasUpgradedOne = false;
  for (const obstruction of obstructions) {
    if (!obstruction.isAlive)
      continue;
    let hasUpgrade = false;
    if (!obstructionClass) {
      const upgrades = obstruction.get(UpgradeComponent).filter((v3) => !!v3);
      obstructionClass = upgrades.find((u3) => u3.obstruction.name === upgrade)?.obstruction;
      if (!obstructionClass)
        continue;
      hasUpgrade = true;
    }
    if (!hasUpgrade && !obstruction.get(UpgradeComponent).some((v3) => v3 && v3.obstruction.name === upgrade))
      continue;
    const cost = calculateUpgradeCost(obstruction.constructor, obstructionClass);
    const check = player.checkResources(cost);
    if (check?.length) {
      if (!hasUpgradedOne)
        appendErrorMessage(`Not enough ${check.join(" ")}`);
      return;
    }
    hasUpgradedOne = true;
    player.subtractResources(cost);
    const {x: x3, y: y3} = obstruction.position;
    obstruction.remove();
    const newObstruction = new obstructionClass({x: x3, y: y3, owner: player});
    new PathingComponent(newObstruction);
  }
}, "upgradeSyncHandler");
var makeUpgradeAction = /* @__PURE__ */ __name2(({
  fromObstruction,
  toObsturction
}) => ({
  name: toObsturction.name,
  description: toObsturction.defaults.buildDescription,
  hotkey: toObsturction.defaults.buildHotkey,
  type: "custom",
  localHandler: ({player}) => {
    const u3 = player.getPrimarySelectedUnit();
    if (!u3 || u3.owner !== player)
      return;
    const cost = calculateUpgradeCost(fromObstruction, toObsturction);
    const check = player.checkResources(cost);
    if (check?.length) {
      appendErrorMessage(`Not enough ${check.join(" ")}`);
      return;
    }
    player.game.transmit({
      type: "upgrade",
      obstructions: [u3.id],
      upgrade: toObsturction.name
    });
  },
  syncHandler: upgradeSyncHandler
}), "makeUpgradeAction");
var toFootprint = /* @__PURE__ */ __name2((radius, pathing = PATHING_TYPES.WALKABLE | PATHING_TYPES.BUILDABLE) => {
  if (radius % 0.5 !== 0)
    throw new Error("radius must be a multiple of 0.5");
  return {
    map: Array((radius * 4) ** 2).fill(pathing),
    top: -radius * 2,
    left: -radius * 2,
    width: radius * 4,
    height: radius * 4
  };
}, "toFootprint");
var _Obstruction = /* @__PURE__ */ __name(class extends Unit {
  constructor({
    buildTime = 1,
    progress = _Obstruction.defaults.progress,
    upgradesTo = [],
    ...props
  }) {
    super({..._Obstruction.clonedDefaults, ...props});
    this.requiresTilemap = toFootprint(this.collisionRadius, this.requiresPathing);
    this.blocksTilemap = toFootprint(this.collisionRadius, this.blocksPathing);
    this.structure = true;
    this.health = Math.round(Math.max(this.maxHealth * progress, 1));
    this.buildTime = buildTime;
    if (progress < 1)
      new GerminateComponent(this);
    for (const upgradeTo of upgradesTo)
      new UpgradeComponent(this, upgradeTo);
  }
  static get buildAction() {
    if (this._buildAction)
      return this._buildAction;
    this._buildAction = {
      name: this.name,
      hotkey: this.defaults.buildHotkey,
      description: this.defaults.buildDescription,
      cost: this.defaults.cost,
      type: "build",
      obstruction: this
    };
    return this._buildAction;
  }
  static upgradeAction(from) {
    const existing = this._upgradeActionMap.get(from);
    if (existing)
      return existing;
    const action = makeUpgradeAction({
      fromObstruction: from,
      toObsturction: this
    });
    this._upgradeActionMap.set(from, action);
    return action;
  }
  get actions() {
    const actions = super.actions;
    const upgrades = this.get(UpgradeComponent);
    upgrades.forEach((u3) => {
      if (!u3)
        return;
      actions.push(u3.obstruction.upgradeAction(this.constructor));
    });
    return actions;
  }
}, "_Obstruction");
var Obstruction = _Obstruction;
Obstruction.isObstruction = true;
Obstruction.defaults = {
  ...Unit.defaults,
  buildHotkey: void 0,
  buildDescription: void 0,
  cost: {},
  requiresPathing: PATHING_TYPES.WALKABLE | PATHING_TYPES.BUILDABLE,
  speed: 0,
  meshBuilder: {
    ...Unit.defaults.meshBuilder,
    shape: "square"
  },
  progress: INITIAL_OBSTRUCTION_PROGRESS
};
Obstruction._upgradeActionMap = new WeakMap();
__name2(Obstruction, "Obstruction");
var PublicSetView = /* @__PURE__ */ __name(class {
  constructor(set) {
    this.set = set;
  }
  find(fn) {
    for (const value of this.set)
      if (fn(value))
        return value;
  }
  filter(fn) {
    const values = [];
    for (const value of this.set)
      if (fn(value))
        values.push(value);
    return values;
  }
  map(fn) {
    const arr = [];
    for (const value of this.set)
      arr.push(fn(value));
    return arr;
  }
  forEach(fn) {
    for (const value of this.set)
      fn(value);
  }
  [Symbol.iterator]() {
    return this.set[Symbol.iterator]();
  }
}, "PublicSetView");
__name2(PublicSetView, "PublicSetView");
var NoComponent = {isNoComponent: true};
var warnedOnMultipleComponentsOfSameName = false;
var addComponentToMap = /* @__PURE__ */ __name2((map, component, system) => {
  let arr = map.get(component);
  if (!arr) {
    arr = [];
    map.set(component, arr);
  }
  arr.push(system);
}, "addComponentToMap");
var App = /* @__PURE__ */ __name(class {
  constructor() {
    this._entities = new Set();
    this.entities = new PublicSetView(this._entities);
    this.impureSystems = [];
    this.allSystems = [];
    this.mechanisms = [];
    this.lastRender = 0;
    this._time = 0;
    this.componentUpdateMap = new Map();
    this.componentsMap = {};
    this.lastUpdate = 0;
    this.entityId = 0;
    rAF(() => this.render());
  }
  addSystem(system) {
    this.allSystems.push(system);
    if (!system.pure)
      this.impureSystems.push(system);
    const constructor = system.constructor;
    for (const component of constructor.components) {
      addComponentToMap(this.componentUpdateMap, component, system);
      this.registerComponent(component, false);
    }
    if (constructor.components.length === 0)
      addComponentToMap(this.componentUpdateMap, NoComponent, system);
    return this;
  }
  removeSystem(system) {
    let index = this.allSystems.indexOf(system);
    if (index >= 0)
      this.allSystems.splice(index, 1);
    index = this.impureSystems.indexOf(system);
    if (index >= 0)
      this.impureSystems.splice(index, 1);
    system.dispose();
    return this;
  }
  addMechanism(mechanism) {
    this.mechanisms.push(mechanism);
    return this;
  }
  dispose() {
    for (const mechanism of this.mechanisms)
      mechanism.dispose();
    for (const system of this.allSystems)
      system.dispose();
  }
  add(entity) {
    if (this._entities.has(entity))
      return false;
    this._entities.add(entity);
    for (const system of this.impureSystems)
      system.add(entity);
    this.entityComponentUpdated(entity, NoComponent);
    return true;
  }
  remove(entity) {
    if (!this._entities.has(entity))
      return false;
    for (const system of this.allSystems)
      system.remove(entity);
    entity.clear();
    this._entities.delete(entity);
    return true;
  }
  entityComponentUpdated(entity, component) {
    if (!("isNoComponent" in component))
      this.registerComponent(component, false);
    const systems = this.componentUpdateMap.get(component);
    if (!systems)
      return;
    for (const system of systems)
      system.check(entity);
  }
  registerComponent(component, warnOnDuplicate = true) {
    if (warnOnDuplicate && this.componentsMap[component.name] && warnedOnMultipleComponentsOfSameName) {
      warnedOnMultipleComponentsOfSameName = true;
      console.warn(`Multiple components of name ${component.name} registered`, component, this.componentsMap[component.name]);
    }
    this.componentsMap[component.name] = component;
  }
  _render() {
    rAF(() => this.render());
    const thisRender = Date.now() / 1e3;
    const delta = thisRender - this.lastRender;
    for (const mechanism of this.mechanisms)
      mechanism.render(delta, thisRender);
    for (const system of this.allSystems) {
      system.preRender(delta, thisRender);
      if (system.render)
        for (const entity of system)
          system.render(entity, delta, thisRender);
      system.postRender(delta, thisRender);
    }
    this.lastRender = thisRender;
  }
  render() {
    withApp(this, () => this._render());
  }
  _update(e3) {
    this._time = e3.time / 1e3;
    const delta = this._time - this.lastUpdate;
    for (const mechanism of this.mechanisms)
      mechanism.update(delta, this._time);
    for (const system of this.allSystems) {
      system.preUpdate(delta, this._time);
      if (system.update)
        for (const entity of system)
          system.update(entity, delta, this._time);
      system.postUpdate(delta, this._time);
    }
    this.lastUpdate = this._time;
  }
  update(e3) {
    withApp(this, () => this._update(e3));
  }
  get time() {
    return this._time;
  }
}, "App");
__name2(App, "App");
var attackAction = {
  name: "Attack",
  hotkey: "a",
  type: "target",
  localHandler: ({target: target2}) => {
    const game = currentGame();
    const units = game.selectionSystem.selection.filter((s3) => isUnit(s3) && s3.owner === game.localPlayer);
    const attackers = units.filter((u3) => u3.has(DamageComponent) && (isInAttackRange(u3, target2) || u3.speed > 0));
    if (attackers.length)
      game.transmit({
        type: "attack",
        attackers: attackers.map((u3) => u3.id),
        target: target2.id
      });
  },
  syncHandler: ({
    time,
    connection,
    attackers,
    target: targetId
  }) => {
    const game = currentGame();
    game.update({time});
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    const target2 = game.entities.find((s3) => s3.id === targetId);
    if (!target2 || !isSprite(target2))
      return;
    player.sprites.filter((s3) => attackers.includes(s3.id)).filter(isUnit).forEach((s3) => s3.attack(target2));
  }
};
var attackMoveAction = {
  name: "Attack",
  hotkey: "a",
  type: "targetOrPoint",
  localHandler: (props) => {
    const game = currentGame();
    const units = game.selectionSystem.selection.filter((s3) => isUnit(s3) && s3.owner === game.localPlayer);
    const target2 = "target" in props ? props.target : void 0;
    const attackers = target2 ? units.filter((u3) => u3.has(DamageComponent) && (isInAttackRange(u3, target2) || u3.speed > 0)) : [];
    const point = "point" in props ? props.point : void 0;
    const movers = point ? units.filter((u3) => !attackers.includes(u3) && u3.speed > 0) : [];
    if (attackers.length)
      game.transmit({
        type: "attack",
        attackers: attackers.map((u3) => u3.id),
        target: target2.id
      });
    if (movers.length)
      game.transmit({
        type: "move",
        sprites: movers.map((u3) => u3.id),
        ...point
      });
    if (movers.length > 0 && units.some(isObstruction))
      game.selectionSystem.setSelection(units);
  }
};
var buildAction = {
  name: "Build",
  hotkey: "b",
  type: "point",
  localHandler: ({point}) => {
    const game = currentGame();
    const obstructionPlacement = game.obstructionPlacement;
    if (!obstructionPlacement)
      return;
    if (!obstructionPlacement.valid)
      return;
    const obstruction = obstructionPlacement.active;
    const x3 = obstructionPlacement.snap(point.x);
    const y3 = obstructionPlacement.snap(point.y);
    obstructionPlacement.stop();
    const builder = game.selectionSystem.selection.find((s3) => isUnit(s3) && s3.owner === game.localPlayer && s3.builds.includes(obstruction));
    if (!builder)
      return;
    game.transmit({
      type: "build",
      builder: builder.id,
      x: x3,
      y: y3,
      obstruction: obstruction.name
    });
  },
  syncHandler: ({
    x: x3,
    y: y3,
    time,
    connection,
    obstruction,
    builder
  }) => {
    const game = currentGame();
    game.update({time});
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    const unit = player.sprites.find((s3) => s3.id === builder && isUnit(s3) && s3.builds.some((b3) => b3.name === obstruction));
    if (!unit)
      return;
    const obstructionClass = unit.builds.find((o3) => o3.name === obstruction);
    if (!obstructionClass)
      return;
    unit.buildAt({x: x3, y: y3}, obstructionClass);
  }
};
var moveAction = {
  name: "Move",
  hotkey: "m",
  type: "point",
  localHandler: ({point}) => {
    const game = currentGame();
    const units = game.selectionSystem.selection.filter((s3) => isUnit(s3) && s3.owner === game.localPlayer && s3.speed > 0);
    if (units.length)
      game.transmit({
        type: "move",
        sprites: units.map((u3) => u3.id),
        ...point
      });
  },
  syncHandler: ({time, connection, sprites, x: x3, y: y3}) => {
    const game = currentGame();
    game.update({time});
    const player = game.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    player.sprites.filter((s3) => sprites.includes(s3.id)).filter(isUnit).forEach((s3) => s3.walkTo({x: x3, y: y3}));
  }
};
var rightClick = /* @__PURE__ */ __name2(({mouse: mouse2}) => {
  const {x: x3, y: y3} = mouse2.ground;
  const game = currentGame();
  if (mouse2.entity && isWidget(mouse2.entity) || !mouse2.entity)
    attackMoveAction.localHandler({
      player: game.localPlayer,
      target: mouse2.entity,
      point: {x: x3, y: y3}
    });
}, "rightClick");
var leftClick = /* @__PURE__ */ __name2(({mouse: mouse2}) => {
  const game = currentGame();
  const obstructionPlacement = game.obstructionPlacement;
  if (!obstructionPlacement)
    return;
  if (!obstructionPlacement.valid)
    return;
  buildAction.localHandler({
    player: game.localPlayer,
    point: {x: mouse2.ground.x, y: mouse2.ground.y}
  });
}, "leftClick");
var initSpriteLogicListeners = /* @__PURE__ */ __name2((game) => {
  game.mouse.addEventListener("mouseDown", (e3) => {
    if (e3.button === 2 || e3.ctrlDown)
      return rightClick(e3);
    if (e3.button === 0)
      leftClick(e3);
  });
  game.ui.addEventListener("keyDown", (e3) => {
    const hotkey = game.actions.activeActions.find((b3) => b3.hotkey === e3.key);
    if (!hotkey)
      return;
    if (hotkey.type === "custom")
      return hotkey.localHandler({player: game.localPlayer});
    if (hotkey.type === "build") {
      const builder = game.selectionSystem.selection.find((u3) => isUnit(u3) && u3.owner === game.localPlayer && u3.builds.includes(hotkey.obstruction));
      if (builder) {
        const obstructionPlacement = game.obstructionPlacement;
        obstructionPlacement.start(hotkey.obstruction, builder);
      }
    }
  });
  game.addNetworkListener("attack", attackAction.syncHandler);
  game.addNetworkListener("build", buildAction.syncHandler);
  game.addNetworkListener("holdPosition", holdPositionAction.syncHandler);
  game.addNetworkListener("mirror", mirrorAction.syncHandler);
  game.addNetworkListener("move", moveAction.syncHandler);
  game.addNetworkListener("stop", stopAction.syncHandler);
  game.addNetworkListener("upgrade", upgradeSyncHandler);
}, "initSpriteLogicListeners");
function _alea(seed) {
  const mash = Mash();
  const data = {
    c: 1,
    s0: mash(" "),
    s1: mash(" "),
    s2: mash(" "),
    next: () => {
      const t3 = 2091639 * data.s0 + data.c * 23283064365386963e-26;
      data.s0 = data.s1;
      data.s1 = data.s2;
      return data.s2 = t3 - (data.c = t3 | 0);
    }
  };
  data.s0 -= mash(seed);
  if (data.s0 < 0)
    data.s0 += 1;
  data.s1 -= mash(seed);
  if (data.s1 < 0)
    data.s1 += 1;
  data.s2 -= mash(seed);
  if (data.s2 < 0)
    data.s2 += 1;
  return data;
}
__name(_alea, "_alea");
__name2(_alea, "_alea");
function copy(f3, t3) {
  t3.c = f3.c;
  t3.s0 = f3.s0;
  t3.s1 = f3.s1;
  t3.s2 = f3.s2;
  return t3;
}
__name(copy, "copy");
__name2(copy, "copy");
function alea(seed, opts) {
  const xg = _alea(seed);
  const state = opts?.state;
  const prng = xg.next;
  prng.int32 = () => xg.next() * 4294967296 | 0;
  prng.double = () => prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
  prng.quick = prng;
  prng.between = (min, max) => {
    const range = max - min;
    return prng() * range + min;
  };
  if (state) {
    if (typeof state === "object")
      copy(state, xg);
    prng.state = () => copy(xg, {c: 0, s0: 0, s1: 0, s2: 0});
  }
  return prng;
}
__name(alea, "alea");
__name2(alea, "alea");
function Mash() {
  let n2 = 4022871197;
  const mash = /* @__PURE__ */ __name2((data) => {
    for (let i3 = 0; i3 < data.length; i3++) {
      n2 += data.charCodeAt(i3);
      let h11 = 0.02519603282416938 * n2;
      n2 = h11 >>> 0;
      h11 -= n2;
      h11 *= n2;
      n2 = h11 >>> 0;
      h11 -= n2;
      n2 += h11 * 4294967296;
    }
    return (n2 >>> 0) * 23283064365386963e-26;
  }, "mash");
  return mash;
}
__name(Mash, "Mash");
__name2(Mash, "Mash");
var Alliances = /* @__PURE__ */ __name(class extends Mechanism {
  constructor() {
    super(...arguments);
    this.relationships = new WeakMap();
  }
  getPlayerRelationships(player) {
    {
      const playerRelationships2 = this.relationships.get(player);
      if (playerRelationships2)
        return playerRelationships2;
    }
    const playerRelationships = new WeakMap();
    this.relationships.set(player, playerRelationships);
    return playerRelationships;
  }
  set(sourcePlayer, targetPlayer, allianceState, mutual = true) {
    const sourcePlayerRelationships = this.getPlayerRelationships(sourcePlayer);
    sourcePlayerRelationships.set(targetPlayer, allianceState);
    if (mutual) {
      const targetPlayerRelationships = this.getPlayerRelationships(targetPlayer);
      targetPlayerRelationships.set(sourcePlayer, allianceState);
    }
  }
  allianceState(sourcePlayer, targetPlayer) {
    if (sourcePlayer === targetPlayer)
      return "ally";
    return this.relationships.get(sourcePlayer)?.get(targetPlayer) ?? "neutral";
  }
  isAlly(sourcePlayer, targetPlayer) {
    return this.allianceState(sourcePlayer, targetPlayer) === "ally";
  }
  isEnemy(sourcePlayer, targetPlayer) {
    return this.allianceState(sourcePlayer, targetPlayer) === "enemy";
  }
  toJSON() {
    const state = {};
    const players = currentGame().players;
    for (const sourcePlayer of players) {
      const playerRelationships = this.relationships.get(sourcePlayer);
      if (!playerRelationships)
        continue;
      for (const targetPlayer of players) {
        if (sourcePlayer === targetPlayer)
          continue;
        const allianceState = playerRelationships.get(targetPlayer);
        if (allianceState) {
          if (!state[sourcePlayer.id])
            state[sourcePlayer.id] = {};
          state[sourcePlayer.id][targetPlayer.id] = allianceState;
        }
      }
    }
    return state;
  }
  fromJSON(state) {
    const players = currentGame().players;
    for (const sourcePlayerId in state) {
      const sourcePlayer = players.find((p3) => p3.id === parseInt(sourcePlayerId));
      if (!sourcePlayer)
        throw new Error(`Could not hydrate Alliances due to missing player ${sourcePlayerId}`);
      for (const targetPlayerId in state[sourcePlayerId]) {
        const targetPlayer = players.find((p3) => p3.id === parseInt(targetPlayerId));
        if (!targetPlayer)
          throw new Error(`Could not hydrate Alliances due to missing player ${targetPlayerId}`);
        this.set(sourcePlayer, targetPlayer, state[sourcePlayerId][targetPlayerId], false);
      }
    }
  }
}, "Alliances");
__name2(Alliances, "Alliances");
var FPSMonitor = /* @__PURE__ */ __name(class extends Mechanism {
  constructor() {
    super(...arguments);
    this.renders = [];
  }
  get fps() {
    return this.renders.length / 5;
  }
  render(_2, time) {
    this.renders.push(time);
    const fiveSecondsAgo = time - 5;
    while (this.renders.length && this.renders[0] < fiveSecondsAgo)
      this.renders.shift();
  }
}, "FPSMonitor");
__name2(FPSMonitor, "FPSMonitor");
var edgeSnap = /* @__PURE__ */ __name2((v3) => Math.round(v3), "edgeSnap");
var midSnap = /* @__PURE__ */ __name2((v3) => Math.floor(v3) + 0.5, "midSnap");
var PlacementEntity = /* @__PURE__ */ __name(class extends Widget {
}, "PlacementEntity");
__name2(PlacementEntity, "PlacementEntity");
var ObstructionPlacement = /* @__PURE__ */ __name(class extends Mechanism {
  constructor(game) {
    super();
    this.pathable = false;
    this.grids = [];
    this.gridEntity = new PlacementEntity({
      id: "ENTITY_PLACEMENT",
      x: 0,
      y: 0
    });
    this.added = false;
    this.game = game;
    this.mouse = game.mouse;
    game.mouse.addEventListener("mouseMove", () => {
      if (this.plannedObstruction)
        this.updatePosition();
    });
  }
  snap(v3) {
    const snapFunc = !this.plannedObstruction || this.plannedObstruction.defaults.collisionRadius % 1 === 0 ? edgeSnap : midSnap;
    return snapFunc(v3);
  }
  getGrid() {
    return this.gridEntity.get(ThreeObjectComponent)[0]?.object;
  }
  newGrid(width, height) {
    const grid = new Grid(width, height);
    grid.material = new MeshPhongMaterial({
      vertexColors: true,
      flatShading: true,
      depthTest: false
    });
    grid.renderOrder = 100;
    grid.material.opacity = 0.5;
    grid.material.transparent = true;
    return grid;
  }
  updateCells() {
    if (!this.plannedObstruction)
      return;
    const unit = this.game.localPlayer.getPrimarySelectedUnit();
    if (!unit)
      return;
    const pathing = this.plannedObstruction.defaults.requiresPathing;
    const collisionRadius = this.plannedObstruction.defaults.collisionRadius;
    const xStart = this.snap(this.mouse.ground.x) - collisionRadius;
    const yStart = this.snap(this.mouse.ground.y) - collisionRadius;
    const oldGrid = this.getGrid();
    if (!this.grids[collisionRadius * 2])
      this.grids[collisionRadius * 2] = [];
    const newGrid = this.grids[collisionRadius * 2][collisionRadius * 2] ?? (this.grids[collisionRadius * 2][collisionRadius * 2] = this.newGrid(collisionRadius * 2, collisionRadius * 2));
    if (newGrid !== oldGrid) {
      this.gridEntity.clear(ThreeObjectComponent);
      new ThreeObjectComponent(this.gridEntity, newGrid);
    }
    const pathingSystem = currentGame().pathingSystem;
    pathingSystem.withoutEntity(unit, () => {
      const xFinal = xStart + collisionRadius * 2;
      const yFinal = yStart + collisionRadius * 2;
      let overallPathable = true;
      const pathingGrid = pathingSystem.grid;
      for (let y3 = yStart; y3 < yFinal; y3 += 1)
        for (let x3 = xStart; x3 < xFinal; x3 += 1) {
          const pathable = pathingGrid[y3 * 2]?.[x3 * 2]?.pathable(pathing) && pathingGrid[y3 * 2]?.[x3 * 2 + 1]?.pathable(pathing) && pathingGrid[y3 * 2 + 1]?.[x3 * 2]?.pathable(pathing) && pathingGrid[y3 * 2 + 1]?.[x3 * 2 + 1]?.pathable(pathing);
          if (pathable)
            newGrid.setColor(x3 - xStart, yFinal - y3 - 1, 0.25, 1, 0.5);
          else {
            newGrid.setColor(x3 - xStart, yFinal - y3 - 1, 1, 0.25, 0.25);
            overallPathable = false;
          }
        }
      this.pathable = overallPathable;
    });
  }
  render() {
    this.updateCells();
  }
  x() {
    return this.snap(this.mouse.ground.x);
  }
  y() {
    return this.snap(this.mouse.ground.y);
  }
  updatePosition() {
    if (!this.plannedObstruction)
      return;
    const x3 = this.x();
    const y3 = this.y();
    if (this.gridEntity)
      Position.setXY(this.gridEntity, x3, y3);
    this.blueprint?.position.setXY(x3, y3);
  }
  updateSize() {
    if (!this.plannedObstruction)
      return;
    this.updateCells();
    this.updatePosition();
  }
  start(obstruction, builder) {
    if (obstruction.defaults.cost) {
      const check = this.game.localPlayer.checkResources(obstruction.defaults.cost);
      if (check.length) {
        appendErrorMessage(`Not enough ${check.join(" or ")}`);
        return;
      }
    }
    this._builder = builder;
    this.plannedObstruction = obstruction;
    if (!this.added) {
      this.game.add(this.gridEntity);
      this.added = true;
    }
    if (this.blueprint)
      this.blueprint.remove();
    const blueprint = new Blueprint({
      obstruction,
      x: this.x(),
      y: this.y()
    });
    this.blueprint = blueprint;
    this.game.add(blueprint);
    this.updateSize();
  }
  stop() {
    if (!this.plannedObstruction)
      return;
    this.plannedObstruction = void 0;
    this.game.remove(this.gridEntity);
    this.added = false;
    if (this.blueprint) {
      this.blueprint.remove();
      this.game.remove(this.blueprint);
    }
  }
  get active() {
    return this.plannedObstruction;
  }
  get valid() {
    return !!this.plannedObstruction && this.pathable;
  }
  get builder() {
    return this._builder;
  }
}, "ObstructionPlacement");
__name2(ObstructionPlacement, "ObstructionPlacement");
var colorsArr = [
  {index: 0, name: "red", hex: "#FF0000"},
  {index: 1, name: "blue", hex: "#4385FF"},
  {index: 2, name: "cyan", hex: "#64FFFF"},
  {index: 3, name: "purple", hex: "#820096"},
  {index: 4, name: "yellow", hex: "#FFEA00"},
  {index: 5, name: "orange", hex: "#FF9900"},
  {index: 6, name: "lime", hex: "#BEFF00"},
  {index: 7, name: "magenta", hex: "#FF00FF"},
  {index: 8, name: "grey", hex: "#808080"},
  {index: 9, name: "mint", hex: "#AAFFC3"},
  {index: 10, name: "green", hex: "#00BE00"},
  {index: 11, name: "brown", hex: "#AA6E28"},
  {index: 12, name: "maroon", hex: "#800000"},
  {index: 13, name: "navy", hex: "#000080"},
  {index: 14, name: "olive", hex: "#808000"},
  {index: 15, name: "teal", hex: "#008080"},
  {index: 16, name: "lavender", hex: "#E6BEFF"},
  {index: 17, name: "pink", hex: "#FFC9DE"},
  {index: 18, name: "coral", hex: "#FFD8B1"},
  {index: 19, name: "beige", hex: "#FFFAC8"},
  {index: 20, name: "white", hex: "#FFFFFF"},
  {index: 21, name: "black", hex: "#000000"}
].map((color) => {
  const red = parseInt(color.hex.slice(1, 3), 16);
  const green = parseInt(color.hex.slice(3, 5), 16);
  const blue = parseInt(color.hex.slice(5, 7), 16);
  return {...color, r: red, g: green, b: blue, red, green, blue, taken: 0};
});
var colors = Object.assign(colorsArr, ...colorsArr.map((c3) => ({[c3.name]: c3})));
var nextColor = /* @__PURE__ */ __name2(() => {
  const nextColor2 = colors.find((color) => !color.taken);
  if (!nextColor2)
    throw new Error("ran out of colors");
  return takeColor(nextColor2);
}, "nextColor");
var takeColor = /* @__PURE__ */ __name2((color) => {
  if (typeof color === "number")
    color = colors[color];
  color.taken += 1;
  return color;
}, "takeColor");
var releaseColor = /* @__PURE__ */ __name2((color) => {
  if (typeof color === "number")
    color = colors[color];
  color.taken -= 1;
  return color;
}, "releaseColor");
var Player = /* @__PURE__ */ __name(class {
  constructor({game, ...data}) {
    this.sprites = [];
    this.isHere = true;
    this.resources = {};
    this.username = "tim";
    this.id = -1;
    this.game = game;
    Object.assign(this, data);
    if (!data.username || parseInt(data.username) === data.id)
      Object.defineProperty(this, "username", {
        get: () => this.color ? this.color.name : this.id
      });
    game.players.push(this);
  }
  checkResources(resources) {
    const low = [];
    for (const resource in resources)
      if ((this.resources[resource] ?? 0) < resources[resource])
        low.push(resource);
    return low;
  }
  subtractResources(resources) {
    for (const resource in resources)
      this.resources[resource] = (this.resources[resource] ?? 0) - (resources[resource] ?? 0);
  }
  get enemies() {
    const game = currentGame();
    return game.players.filter((p3) => game.alliances.isEnemy(this, p3));
  }
  isEnemy(player) {
    return currentGame().alliances.isEnemy(this, player);
  }
  getEnemySprites() {
    return this.enemies.map((p3) => p3.sprites.filter((s3) => s3.isAlive)).flat();
  }
  get uid() {
    return `${this.username}#${this.id}`;
  }
  getPrimarySelectedUnit(entities) {
    const universe = entities ?? this.game.selectionSystem.selection;
    const units = universe.filter(isUnit);
    if (!units.length)
      return;
    let activeUnit = units[0];
    for (let i3 = 1; i3 < units.length; i3++)
      if (units[i3].priority > activeUnit.priority)
        activeUnit = units[i3];
    return units[0];
  }
  toJSON() {
    return {
      color: this.color ? colors.indexOf(this.color) : void 0,
      id: this.id,
      username: this.username
    };
  }
}, "Player");
__name2(Player, "Player");
var initPlayerLogic = /* @__PURE__ */ __name2((game) => {
  game.addNetworkListener("connection", (data) => {
    logLine("updating random seed", data.time.toString());
    game.random = alea(data.time.toString());
    game.update(data);
    const player = game.onPlayerJoin(data);
    if (game.localPlayer === void 0 && !game.isHost)
      game.localPlayer = player;
    else if (game.players.length > 1)
      game.newPlayers = true;
  });
  game.addNetworkListener("disconnection", ({time, connection}) => {
    const playerIndex = game.players.findIndex((p3) => p3.id === connection);
    if (playerIndex === -1)
      return;
    game.update({time});
    game.onPlayerLeave(game.players[playerIndex]);
  });
}, "initPlayerLogic");
var AnimationSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return Animation.has(entity) && ThreeObjectComponent.has(entity);
  }
  render(entity, delta) {
    const objectComponent = entity.get(ThreeObjectComponent)[0];
    if (!objectComponent)
      return this.remove(entity);
    objectComponent.mixer.update(delta);
  }
  onAddEntity(entity) {
    const animation = entity.get(Animation)[0];
    if (!animation)
      return this.remove(entity);
    const objectComponent = entity.get(ThreeObjectComponent)[0];
    if (!objectComponent)
      return this.remove(entity);
    const clip = AnimationClip.findByName(objectComponent.object.animations, animation.animation);
    if (!clip)
      return console.warn(`Attempted to play aniamtion '${animation.animation}' on ${objectComponent.object.name}, but it wasn't found`);
    const action = objectComponent.mixer.clipAction(clip);
    action.clampWhenFinished = true;
    action.reset().play();
  }
}, "AnimationSystem");
AnimationSystem.components = [Animation, ThreeObjectComponent];
__name2(AnimationSystem, "AnimationSystem");
var TEXT_OVERSIZE = 10;
var TEXT_SCALE = 40 * TEXT_OVERSIZE;
var createCanvasAndContext = /* @__PURE__ */ __name2((text, size, color) => {
  const canvas = doc.createElement("canvas");
  const context3 = canvas.getContext("2d");
  context3.scale(win.devicePixelRatio, win.devicePixelRatio);
  const height = size * TEXT_OVERSIZE;
  context3.font = size * TEXT_OVERSIZE + "pt Verdana";
  const width = context3.measureText(text).width;
  canvas.width = width * win.devicePixelRatio;
  canvas.height = height * win.devicePixelRatio;
  context3.textAlign = "center";
  context3.textBaseline = "middle";
  context3.font = size * TEXT_OVERSIZE + "pt Verdana";
  context3.fillStyle = "black";
  context3.fillText(text, canvas.width / 2 - TEXT_OVERSIZE / 6, canvas.height / 2 - TEXT_OVERSIZE / 6);
  context3.fillStyle = "black";
  context3.fillText(text, canvas.width / 2 + TEXT_OVERSIZE / 3, canvas.height / 2 + TEXT_OVERSIZE / 2);
  context3.fillStyle = color;
  context3.fillText(text, canvas.width / 2, canvas.height / 2);
  return canvas;
}, "createCanvasAndContext");
var TextTag = /* @__PURE__ */ __name(class extends Widget {
  constructor({size = 12, text, color = "white", ...props}) {
    super({...props, zOffset: 0.5});
    this.speed = 0.1;
    const canvas = createCanvasAndContext(text, size, color);
    const texture = new CanvasTexture(canvas);
    const material = new MeshBasicMaterial({
      map: texture,
      alphaTest: 0.5,
      depthTest: false
    });
    const mesh = new Mesh(new PlaneGeometry(canvas.width / TEXT_SCALE, canvas.height / TEXT_SCALE), material);
    mesh.renderOrder = 0;
    new ThreeObjectComponent(this, mesh);
    const game = currentGame();
    game.setTimeout(() => game.remove(this), 1.5);
    game.add(this);
  }
}, "TextTag");
__name2(TextTag, "TextTag");
var doDamage = /* @__PURE__ */ __name2((entity, attackTarget, weapon) => {
  const isTargetInRange = isInAttackRange(entity, attackTarget.target, true);
  if (!isTargetInRange) {
    if (entity.has(Position))
      new TextTag({
        color: "red",
        text: "miss",
        x: entity.position.x,
        y: entity.position.y
      });
    return;
  }
  const damage = entity.isIllusion ? 0 : weapon.damage;
  const actualDamage = attackTarget.target.damage(damage);
  if (weapon.onDamage)
    weapon.onDamage(attackTarget.target, actualDamage, entity);
  if (attackTarget.target.health <= 0 || attackTarget.target.invulnerable) {
    MoveTarget.clear(entity);
    AttackTarget.clear(entity);
  }
}, "doDamage");
var AttackSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = false;
  }
  test(entity) {
    return AttackTarget.has(entity) && isUnit(entity);
  }
  update(entity) {
    const damageComponent = entity.get(DamageComponent)[0];
    if (!damageComponent) {
      AttackTarget.clear(entity);
      return;
    }
    const weapon = damageComponent.weapons[0];
    const attackTarget = entity.get(AttackTarget)[0];
    if (!attackTarget)
      return this.remove(entity);
    if (attackTarget.target.health <= 0 || attackTarget.target.invulnerable) {
      MoveTarget.clear(entity);
      AttackTarget.clear(entity);
      return;
    }
    const isTargetInRange = isInAttackRange(entity, attackTarget.target);
    if (!isTargetInRange && !MoveTarget.has(entity) && !weapon.swinging) {
      AttackTarget.clear(entity);
      return;
    }
    const lastUpdate = currentGame().lastUpdate;
    if (!isTargetInRange || weapon.last + weapon.cooldown > lastUpdate)
      return;
    if (weapon.projectile === "instant")
      doDamage(entity, attackTarget, weapon);
    else if (weapon.projectile === "swing") {
      weapon.swinging = true;
      const oldMoveTarget = entity.get(MoveTarget)[0];
      if (oldMoveTarget)
        entity.clear(oldMoveTarget);
      currentGame().setTimeout(() => {
        weapon.swinging = false;
        if (!attackTarget.target.isAlive || attackTarget.target.invulnerable) {
          AttackTarget.clear(entity);
          return;
        }
        if (oldMoveTarget)
          new MoveTarget({entity, target: oldMoveTarget.entity});
        doDamage(entity, attackTarget, weapon);
      }, weapon.damagePoint ?? 0);
    } else
      weapon.projectile(attackTarget.target, entity);
    const meshBuilderComponent = entity.get(MeshBuilderComponent)[0];
    if (meshBuilderComponent)
      new Animation(entity, "attack", 0.75);
    weapon.last = lastUpdate;
  }
}, "AttackSystem");
AttackSystem.components = [AttackTarget];
__name2(AttackSystem, "AttackSystem");
var AutoAttackSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = false;
  }
  test(entity) {
    const damageComponent = entity.get(DamageComponent)[0];
    return !!damageComponent && damageComponent.autoAttack && isUnit(entity) && entity.idle;
  }
  update(entity) {
    if (!entity.idle)
      return this.remove(entity);
    const {
      position: {x: x3, y: y3}
    } = entity;
    const damageComponent = entity.get(DamageComponent)[0];
    if (!damageComponent)
      return this.remove(entity);
    const weapon = damageComponent.weapons[0];
    const pool = entity.owner.getEnemySprites().filter((s3) => Number.isFinite(s3.health) && (entity.speed > 0 || isInAttackRange(entity, s3))).sort((a3, b3) => {
      if (a3.priority !== b3.priority)
        return b3.priority - a3.priority;
      return (a3.position.x - x3) ** 2 + (a3.position.y - y3) ** 2 - ((b3.position.x - x3) ** 2 + (b3.position.y - y3) ** 2);
    });
    const pathingSystem = currentGame().pathingSystem;
    const nearest = pool.find((u3) => {
      const distanceToTarget = Math.sqrt((u3.position.x - entity.position.x) ** 2 + (u3.position.y - entity.position.y) ** 2);
      if (distanceToTarget < weapon.range + entity.collisionRadius + u3.collisionRadius)
        return true;
      if (entity.speed) {
        const endPoint = pathingSystem.withoutEntity(u3, () => pathingSystem.path(entity, u3.position)).pop();
        if (!endPoint)
          return false;
        const distance = Math.sqrt((endPoint.x - u3.position.x) ** 2 + (endPoint.y - u3.position.y) ** 2);
        if (distance < weapon.range + entity.collisionRadius + u3.collisionRadius)
          return true;
      }
      return false;
    }) ?? pool[0];
    if (nearest)
      entity.attack(nearest);
  }
}, "AutoAttackSystem");
AutoAttackSystem.components = [
  MoveTarget,
  AttackTarget,
  HoldPositionComponent,
  GerminateComponent,
  DamageComponent,
  ActiveComponent
];
__name2(AutoAttackSystem, "AutoAttackSystem");
var BlueprintSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = false;
  }
  test(entity) {
    return entity.has(BuildTarget) && isUnit(entity);
  }
  update(entity) {
    const buildTarget = entity.get(BuildTarget)[0];
    const moveTarget = entity.get(MoveTarget)[0];
    if (!buildTarget) {
      BuildTarget.clear(entity);
      return;
    }
    if (moveTarget)
      return;
    BuildTarget.clear(entity);
    if (distanceBetweenPoints(entity.position, buildTarget.target) > BUILD_DISTANCE)
      return;
    if (buildTarget.obstructionClass.defaults.cost) {
      const check = entity.owner.checkResources(buildTarget.obstructionClass.defaults.cost);
      if (check?.length) {
        appendErrorMessage(`Not enough ${check.join(" ")}`);
        return;
      }
      entity.owner.subtractResources(buildTarget.obstructionClass.defaults.cost);
    }
    const obstruction = new buildTarget.obstructionClass({
      x: buildTarget.target.x,
      y: buildTarget.target.y,
      owner: entity.owner
    });
    const game = currentGame();
    const pathingSystem = game.pathingSystem;
    pathingSystem.withoutEntity(entity, () => {
      if (pathingSystem.pathable(obstruction, buildTarget.target.x, buildTarget.target.y)) {
        new PathingComponent(obstruction);
        entity.obstructions.push(obstruction);
      } else
        obstruction.kill({removeImmediately: true});
      const newPos = pathingSystem.nearestSpiralPathing(entity.position.x, entity.position.y, entity);
      entity.position.setXY(newPos.x, newPos.y);
      game.dispatchEvent("build", entity, obstruction);
    });
  }
}, "BlueprintSystem");
BlueprintSystem.components = [BuildTarget, MoveTarget];
__name2(BlueprintSystem, "BlueprintSystem");
var GerminateSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = false;
  }
  test(entity) {
    return GerminateComponent.has(entity) && typeof entity.buildTime === "number";
  }
  update(entity, delta) {
    const germinateComponent = entity.get(GerminateComponent)[0];
    if (!germinateComponent)
      return;
    if (!entity.isAlive) {
      entity.clear(germinateComponent);
      return;
    }
    const newProgress = Math.min(1, germinateComponent.progress + delta / entity.buildTime);
    const deltaProgress = newProgress - germinateComponent.progress;
    germinateComponent.progress = newProgress;
    entity.health = Math.min(entity.health + deltaProgress * entity.maxHealth, entity.maxHealth);
    if (newProgress === 1)
      GerminateComponent.clear(entity);
  }
}, "GerminateSystem");
GerminateSystem.components = [GerminateComponent];
__name2(GerminateSystem, "GerminateSystem");
var hasSpeed = /* @__PURE__ */ __name2((entity) => "speed" in entity && typeof entity.speed === "number", "hasSpeed");
var GraphicMoveSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return ThreeObjectComponent.has(entity) && Position.has(entity) && MoveTarget.has(entity);
  }
  render(entity, delta) {
    const object = entity.model.object;
    const moveTarget = entity.get(MoveTarget)[0];
    const game = currentGame();
    if (moveTarget && hasSpeed(entity)) {
      moveTarget.renderProgress += entity.speed * delta;
      const {x: x3, y: y3} = moveTarget.path(moveTarget.renderProgress);
      object.position.x = x3;
      object.position.y = y3;
      object.position.z = object.position.z * 0.8 + (game.terrain.groundHeight(x3, y3) + entity.position.zOffset) * 0.2;
    } else {
      const position = entity.position;
      object.position.x = position.x;
      object.position.y = position.y;
      object.position.z = game.terrain.groundHeight(position.x, position.y) + entity.position.zOffset;
    }
    [Selected, Hover].forEach((Circle2) => {
      const circle = entity.get(Circle2)[0]?.circle;
      if (circle) {
        circle.model.object.position.copy(object.position);
        circle.model.object.position.z += SELECTION_CRICLE_ZOFFSET;
      }
    });
  }
}, "GraphicMoveSystem");
GraphicMoveSystem.components = [ThreeObjectComponent, Position, MoveTarget];
__name2(GraphicMoveSystem, "GraphicMoveSystem");
var GraphicTrackPosition = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return ThreeObjectComponent.has(entity) && Position.has(entity);
  }
  updatePosition(entity) {
    const position = entity.position;
    const object = entity.model.object;
    const game = currentGame();
    object.position.x = position.x;
    object.position.y = position.y;
    object.position.z = game.terrain.groundHeight(position.x, position.y) + entity.position.zOffset;
    [Selected, Hover].forEach((Circle2) => {
      const circle = entity.get(Circle2)[0]?.circle;
      if (circle)
        circle.position.setXY(position.x, position.y, position.zOffset + SELECTION_CRICLE_ZOFFSET);
    });
  }
  onAddEntity(entity) {
    this.updatePosition(entity);
  }
  modified(entity) {
    this.updatePosition(entity);
  }
}, "GraphicTrackPosition");
GraphicTrackPosition.components = [ThreeObjectComponent, Position];
__name2(GraphicTrackPosition, "GraphicTrackPosition");
var getColor = /* @__PURE__ */ __name2((entity, meshBuilder) => {
  const rawColor = meshBuilder.color ?? entity.color ?? entity.owner?.color?.hex ?? "white";
  if (meshBuilder.colorFilter)
    return meshBuilder.colorFilter(new Color(rawColor));
  return rawColor;
}, "getColor");
var getMat = /* @__PURE__ */ __name2((entity, meshBuilder) => new MeshPhongMaterial({
  color: getColor(entity, meshBuilder),
  opacity: meshBuilder.opacity,
  transparent: meshBuilder.opacity < 1
}), "getMat");
var createSphere = /* @__PURE__ */ __name2((entity, meshBuilder) => {
  const geometry = new SphereGeometry(meshBuilder.scale);
  geometry.translate(0, 0, meshBuilder.scale);
  return new Mesh(geometry, getMat(entity, meshBuilder));
}, "createSphere");
var createBox = /* @__PURE__ */ __name2((entity, meshBuilder) => {
  const geometry = new BoxGeometry(meshBuilder.scale * 2, meshBuilder.scale * 2, meshBuilder.scale * 3 / 2);
  geometry.translate(0, 0, meshBuilder.scale * 3 / 4);
  geometry.rotateZ(entity.facing);
  return new Mesh(geometry, getMat(entity, meshBuilder));
}, "createBox");
var MeshBuilder = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return MeshBuilderComponent.has(entity);
  }
  onAddEntity(entity) {
    const meshBuilder = entity.get(MeshBuilderComponent)[0];
    if (!meshBuilder)
      return;
    const builder = meshBuilder.shape === "circle" ? createSphere : createBox;
    const mesh = builder(entity, meshBuilder);
    if (meshBuilder.shadows) {
      mesh.castShadow = true;
      mesh.receiveShadow = true;
    }
    mesh.position.x = entity.position.x;
    mesh.position.y = entity.position.y;
    meshBuilder.mutator?.(mesh);
    mesh.entity = entity;
    mesh.animations.push(new AnimationClip("attack", 0.75, [
      new VectorKeyframeTrack(".scale", [0, 0.35, 0.5, 0.75], [1, 1, 1, 1.25, 1.25, 1.25, 0.8, 0.8, 0.8, 1, 1, 1])
    ]), new AnimationClip("cast", 0.5, [
      new VectorKeyframeTrack(".scale", [0, 0.25, 0.35, 0.5], [1, 1, 1, 0.8, 0.8, 0.8, 1.25, 1.25, 1.25, 1, 1, 1])
    ]), new AnimationClip("explode", 0.25, [
      new VectorKeyframeTrack(".scale", [0, 0.25], [1, 1, 1, 5, 5, 5]),
      new NumberKeyframeTrack(".material.opacity", [0, 0.25], [1, 0]),
      new BooleanKeyframeTrack(".material.transparent", [0], [true])
    ]));
    new ThreeObjectComponent(entity, mesh);
  }
  onRemoveEntity(entity) {
    ThreeObjectComponent.clear(entity);
  }
}, "MeshBuilder");
MeshBuilder.components = [MeshBuilderComponent];
__name2(MeshBuilder, "MeshBuilder");
var MouseButton;
(function(MouseButton3) {
  MouseButton3[MouseButton3["LEFT"] = 0] = "LEFT";
  MouseButton3[MouseButton3["WHEEL"] = 1] = "WHEEL";
  MouseButton3[MouseButton3["RIGHT"] = 2] = "RIGHT";
  MouseButton3[MouseButton3["BACK"] = 3] = "BACK";
  MouseButton3[MouseButton3["FORWARD"] = 4] = "FORWARD";
})(MouseButton || (MouseButton = {}));
var Mouse = /* @__PURE__ */ __name(class extends System {
  constructor(graphics, ui) {
    super();
    this.pure = true;
    this.intersections = [];
    this.raycaster = new Raycaster();
    this.mouseMoved = false;
    emitter(this);
    this.graphics = graphics;
    this.ui = ui;
    this.client = new Vector2();
    this.screen = new Vector2();
    this.ground = new Vector3();
    this.mouseMoveListener = (e3) => {
      this.client.x = e3.x;
      this.client.y = e3.y;
      this.screen.x = e3.x / win.innerWidth * 2 - 1;
      this.screen.y = -(e3.y / win.innerHeight) * 2 + 1;
      this.target = e3.target ?? void 0;
      this.mouseMoved = true;
    };
    ui.addEventListener("mouseMove", this.mouseMoveListener);
    this.mouseDownListener = (e3) => {
      this.client.x = e3.x;
      this.client.y = e3.y;
      this.screen.x = e3.x / win.innerWidth * 2 - 1;
      this.screen.y = -(e3.y / win.innerHeight) * 2 + 1;
      this.target = e3.target ?? void 0;
      this.raycast();
      this.dispatchEvent("mouseDown", {
        mouse: this,
        button: e3.button,
        ctrlDown: e3.ctrlDown
      });
    };
    ui.addEventListener("mouseDown", this.mouseDownListener);
  }
  dispose() {
    this.ui.removeEventListener("mouseMove", this.mouseMoveListener);
  }
  test(entity) {
    return ThreeObjectComponent.has(entity) && !isSelectionCircle(entity);
  }
  raycast() {
    this.raycaster.setFromCamera(this.screen, this.graphics.camera);
    this.intersections = this.raycaster.intersectObjects(Array.from(this).map((e3) => e3.get(ThreeObjectComponent)[0]?.object).filter((e3) => e3 !== void 0), true);
    for (let i3 = this.intersections.length - 1; i3 >= 0; i3--)
      if (this.intersections[i3].object.parent instanceof Terrain) {
        this.ground = this.intersections[i3].point;
        break;
      }
    let foundEntity = false;
    for (let i3 = 0; i3 < this.intersections.length; i3++) {
      const object = this.intersections[i3].object;
      const entity = object?.entity;
      if (entity && (!isSprite(entity) || entity.selectable)) {
        foundEntity = true;
        if (this.entity !== entity) {
          if (this.entity)
            Hover.clear(this.entity);
          this.entity = entity;
          new Hover(entity);
        }
        break;
      }
    }
    if (!foundEntity && this.entity) {
      Hover.clear(this.entity);
      this.entity = void 0;
    }
  }
  preRender() {
    this.raycast();
    if (this.mouseMoved) {
      this.dispatchEvent("mouseMove", {mouse: this});
      this.mouseMoved = false;
    }
  }
}, "Mouse");
Mouse.components = [ThreeObjectComponent];
__name2(Mouse, "Mouse");
var withoutTarget = /* @__PURE__ */ __name2((pathingSystem, target2, fn) => {
  if (isSprite(target2))
    return pathingSystem.withoutEntity(target2, fn);
  return fn();
}, "withoutTarget");
var MoveSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = false;
  }
  test(entity) {
    return entity.has(MoveTarget) && typeof entity.speed === "number" && entity.speed > 0;
  }
  update(entity, delta, time, retry = true) {
    const moveTarget = entity.get(MoveTarget)[0];
    if (!moveTarget)
      return this.remove(entity);
    const pathingSystem = currentGame().pathingSystem;
    moveTarget.progress += delta * entity.speed;
    const {x: x3, y: y3} = moveTarget.path(moveTarget.progress);
    if (isNaN(x3) || isNaN(y3)) {
      entity.clear(moveTarget);
      throw new Error(`Returning NaN location x=${x3} y=${y3}`);
    }
    const pathable = pathingSystem.pathable(entity, x3, y3);
    if (pathable)
      entity.position.setXY(x3, y3);
    if (moveTarget.path.distance < moveTarget.progress) {
      entity.clear(moveTarget);
      return;
    }
    if (entity.requiresPathing && (!pathable || moveTarget.ticks++ % 5 === 4 || !withoutTarget(pathingSystem, moveTarget.target, () => pathingSystem.recheck(moveTarget.path.points, entity, delta * entity.speed * 6)))) {
      moveTarget.recalc();
      if (moveTarget.path.distance === 0)
        entity.clear(moveTarget);
      if (!pathable && retry)
        this.update(entity, delta, time, false);
    }
  }
}, "MoveSystem");
MoveSystem.components = [MoveTarget];
__name2(MoveSystem, "MoveSystem");
var SelectedMovingCircles = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return Selected.has(entity) && MoveTarget.has(entity);
  }
  update(entity) {
    const circle = entity.get(Selected)[0]?.circle;
    if (!circle)
      return;
    const xy = getXY(entity);
    Position.setXY(circle, xy ? xy.x : 0, xy ? xy.y : 0);
  }
}, "SelectedMovingCircles");
SelectedMovingCircles.components = [MoveTarget, Selected];
__name2(SelectedMovingCircles, "SelectedMovingCircles");
var HoverMovingCircles = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return Hover.has(entity) && MoveTarget.has(entity);
  }
  update(entity) {
    const circle = entity.get(Hover)[0]?.circle;
    if (!circle)
      return;
    const xy = getXY(entity);
    Position.setXY(circle, xy ? xy.x : 0, xy ? xy.y : 0);
  }
}, "HoverMovingCircles");
HoverMovingCircles.components = [MoveTarget, Hover];
__name2(HoverMovingCircles, "HoverMovingCircles");
var circleSystems = [SelectedMovingCircles, HoverMovingCircles];
var ProjectileSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return isProjectile(entity);
  }
  update(projectile) {
    if (MoveTarget.has(projectile))
      return;
    projectile.owner.getEnemySprites().filter((s3) => Number.isFinite(s3.health)).forEach((target2) => {
      if (distanceBetweenPoints(target2.position, projectile.position) > projectile.splash)
        return;
      const actualDamage = target2.damage(projectile.damageAmount);
      if (projectile.onDamage)
        projectile.onDamage(target2, actualDamage, projectile.producer, projectile);
    });
    projectile.remove();
  }
}, "ProjectileSystem");
__name2(ProjectileSystem, "ProjectileSystem");
var SelectedSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super();
    this.pure = true;
    this.data = new WeakMap();
    const game = currentGame();
    game.mouse.addEventListener("mouseDown", ({button, mouse: {entity}}) => {
      if (button === MouseButton.LEFT && entity && !game.obstructionPlacement.active)
        this.setSelection([entity]);
    });
  }
  test(entity) {
    return Selected.has(entity);
  }
  onAddEntity(entity) {
    const selected = entity.get(Selected);
    if (!selected || !selected[0])
      throw new Error("expected Selected component");
    this.data.set(entity, selected[0]);
    currentGame().dispatchEvent("selection", Array.from(this));
  }
  onRemoveEntity(entity) {
    const selected = this.data.get(entity);
    if (!selected)
      return;
    currentGame().dispatchEvent("selection", Array.from(this));
  }
  get selection() {
    return Array.from(this);
  }
  select(entity) {
    if (this.test(entity))
      return false;
    const game = currentGame();
    new Selected(entity, {
      color: isUnit(entity) && game && entity.owner.isEnemy(game.localPlayer) ? "#FF0000" : "#00FF00"
    });
    return true;
  }
  setSelection(entities) {
    const curIds = [];
    for (const curSelected of this)
      curIds.push(curSelected.id);
    const newIds = entities.map((e3) => e3.id);
    if (curIds.length === newIds.length && curIds.every((v3, i3) => v3 === newIds[i3]))
      return;
    for (const curSelected of this)
      Selected.clear(curSelected);
    const game = currentGame();
    for (const newSelected of entities)
      new Selected(newSelected, {
        color: isUnit(newSelected) && game && newSelected.owner.isEnemy(game.localPlayer) ? "#FF0000" : "#00FF00"
      });
  }
}, "SelectedSystem");
SelectedSystem.components = [Selected];
__name2(SelectedSystem, "SelectedSystem");
var createCanvas = /* @__PURE__ */ __name2(() => {
  const canvas = doc.createElement("canvas");
  doc.body.prepend(canvas);
  return canvas;
}, "createCanvas");
var createRenderer = /* @__PURE__ */ __name2((canvas) => {
  const renderer = new WebGLRenderer({
    antialias: win.devicePixelRatio > 1 ? false : true,
    canvas
  });
  renderer.setClearColor(0);
  renderer.setPixelRatio(win.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = PCFSoftShadowMap;
  if (!renderer.domElement.parentElement)
    doc.body.prepend(renderer.domElement);
  return renderer;
}, "createRenderer");
var sunTilt = new Vector3(-10, -15, 25);
var updateLight = /* @__PURE__ */ __name2((camera, sun, container2) => {
  sun.position.copy(camera.position).add(sunTilt);
  const height = sun.position.z;
  sun.shadow.camera.near = 0;
  sun.shadow.camera.far = height * 5 + 100;
  sun.shadow.camera.left = -height * 1;
  sun.shadow.camera.right = height * 0.6;
  sun.shadow.camera.top = height * 1;
  sun.shadow.camera.bottom = -height * 0.4;
  if (container2) {
    sun.shadow.mapSize.width = 2 ** Math.floor(Math.log2(container2.offsetWidth));
    sun.shadow.mapSize.height = 2 ** Math.floor(Math.log2(container2.offsetHeight));
  }
}, "updateLight");
var createScene = /* @__PURE__ */ __name2((camera, container2) => {
  const scene = new Scene();
  scene.add(new HemisphereLight(16777147, 526368, 1));
  const sun = new DirectionalLight(16777215, 1);
  sun.target = camera;
  updateLight(camera, sun, container2);
  sun.castShadow = true;
  scene.add(sun);
  return {scene, sun};
}, "createScene");
var createCamera = /* @__PURE__ */ __name2((renderer) => {
  const size = new Vector2();
  renderer.getSize(size);
  const camera = new PerspectiveCamera(75, size.x / size.y, 0.1, 1e4);
  camera.position.z = parseFloat(storage.getItem("zoom") ?? "10");
  camera.position.y = -7;
  camera.rotation.x = 0.6;
  return camera;
}, "createCamera");
var ThreeGraphics = /* @__PURE__ */ __name(class extends System {
  constructor(game) {
    super();
    this.pure = true;
    this.entityData = new Map();
    this.game = game;
    const canvas = createCanvas();
    this.renderer = createRenderer(canvas);
    this.camera = createCamera(this.renderer);
    const {scene, sun} = createScene(this.camera, this.renderer.domElement.parentElement ?? void 0);
    this.scene = scene;
    this.sun = sun;
    (async () => this.updateSize())();
    win.addEventListener("resize", () => {
      this.updateSize();
      this.updateCamera();
    });
  }
  updateSize() {
    const container2 = this.renderer.domElement.parentElement;
    if (!container2)
      return;
    this.renderer.setSize(container2.offsetWidth, container2.offsetHeight);
    this.camera.aspect = container2.offsetWidth / container2.offsetHeight;
    this.camera.updateProjectionMatrix();
  }
  test(entity) {
    return ThreeObjectComponent.has(entity);
  }
  onAddEntity(entity) {
    const object = entity.get(ThreeObjectComponent)[0].object;
    this.scene.add(object);
    const data = {knownObject: object};
    this.entityData.set(entity, data);
  }
  onRemoveEntity(entity) {
    const object = this.entityData.get(entity)?.knownObject;
    if (object)
      this.scene.remove(object);
    this.entityData.delete(entity);
  }
  panTo(point, duration = 0.125) {
    this.activePan = Object.assign(tweenPoints([
      {x: this.camera.position.x, y: this.camera.position.y},
      {x: point.x, y: point.y - 7}
    ]), {duration});
    this.updateCamera();
  }
  updateCamera(delta = 17 / 1e3) {
    const activePan = this.activePan;
    if (activePan) {
      const {x: x3, y: y3} = activePan.step(delta * activePan.distance / activePan.duration);
      this.camera.position.x = x3;
      this.camera.position.y = y3;
      updateLight(this.camera, this.sun, this.renderer.domElement.parentElement ?? void 0);
      if (activePan.remaining === 0)
        this.activePan = void 0;
    }
  }
  postRender(delta) {
    this.updateCamera(delta);
    this.renderer.render(this.scene, this.camera);
  }
}, "ThreeGraphics");
ThreeGraphics.components = [ThreeObjectComponent];
__name2(ThreeGraphics, "ThreeGraphics");
var TimerSystem = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return Timer.has(entity);
  }
  update(entity, delta, time) {
    entity.get(Timer).forEach((timer) => {
      if (!timer)
        return;
      if (timer.next > time)
        return;
      try {
        timer.fn();
      } catch (err) {
        console.error(err);
      }
      if (timer.periodic) {
        timer.next = timer.oncePerUpdate ? time + timer.timeout : timer.next + timer.timeout;
        return;
      }
      entity.clear(timer);
    });
  }
}, "TimerSystem");
TimerSystem.components = [Timer];
__name2(TimerSystem, "TimerSystem");
var TimerWindows = /* @__PURE__ */ __name(class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return Timer.has(entity) && TimerWindow.has(entity);
  }
  getTimerWindows() {
    return Array.from(this).map((entity) => ({
      entity,
      timerWindow: entity.get(TimerWindow)[0],
      timer: entity.get(Timer)[0]
    }));
  }
}, "TimerWindows");
TimerWindows.components = [Timer, TimerWindow];
__name2(TimerWindows, "TimerWindows");
var centerAction = {
  name: "Center",
  hotkey: " ",
  type: "custom",
  localHandler: ({player}) => {
    const selectionSystem = player.game.selectionSystem;
    const selection = selectionSystem.selection;
    if (selection.length === 0 && player.sprites.length)
      return selectionSystem.setSelection([player.sprites[0]]);
    const {xSum, ySum} = selection.filter(isSprite).reduce(({xSum: xSum2, ySum: ySum2}, {position: {x: x22, y: y22}}) => ({
      xSum: xSum2 + x22,
      ySum: ySum2 + y22
    }), {xSum: 0, ySum: 0});
    const x3 = xSum / selection.length;
    const y3 = ySum / selection.length;
    player.game.graphics.panTo({x: x3, y: y3});
  }
};
var container = doc.getElementById("hotkeys");
var qwertySort = "qwertyuiopasdfghjklzxcvbnm".split("");
qwertySort.push("Escape");
var genNode = /* @__PURE__ */ __name2((action) => {
  const elem2 = doc.createElement("div");
  elem2.classList.add("hotkey");
  const key = doc.createElement("span");
  key.classList.add("key");
  key.textContent = action.hotkey.toUpperCase();
  elem2.appendChild(key);
  const tooltip = doc.createElement("div");
  tooltip.classList.add("tooltip");
  const title = doc.createElement("div");
  title.classList.add("title");
  const hotkeyIndex = action.name.toLowerCase().indexOf(action.hotkey);
  const casedHotkey = hotkeyIndex >= 0 ? action.name[hotkeyIndex] : action.hotkey.toUpperCase();
  const highlight = `<span class="highlight">${casedHotkey}</span>`;
  title.innerHTML = hotkeyIndex >= 0 ? action.name.slice(0, hotkeyIndex) + highlight + action.name.slice(hotkeyIndex + 1) : action.name + ` (${highlight})`;
  tooltip.appendChild(title);
  if ("cost" in action && action.cost) {
    const cost = Object.entries(action.cost).filter(([, v3]) => v3 > 0);
    if (cost.length > 0) {
      const container2 = doc.createElement("div");
      container2.classList.add("resources");
      for (const [key2, value] of cost) {
        const resource = doc.createElement("div");
        resource.classList.add("resource", key2);
        resource.textContent = value.toString();
        resource.title = `${key2[0].toUpperCase()}${key2.slice(1)}: ${value}`;
        container2.appendChild(resource);
      }
      tooltip.appendChild(container2);
    }
  }
  const description = doc.createElement("div");
  description.classList.add("description");
  if (action.description)
    description.textContent = action.description;
  tooltip.appendChild(description);
  elem2.appendChild(tooltip);
  action.elem = elem2;
  return elem2;
}, "genNode");
var aCharCode = "a".charCodeAt(0);
var zCharCode = "z".charCodeAt(0);
var Hotkeys = /* @__PURE__ */ __name(class extends Mechanism {
  constructor() {
    super();
    this.activeActions = [];
    currentGame().addEventListener("selection", (entities) => this.onSelection(entities));
  }
  onSelection(entities) {
    emptyElement(container);
    this.activeActions.splice(0);
    this.activeActions.push(centerAction);
    const game = currentGame();
    const activeUnit = game.localPlayer.getPrimarySelectedUnit(entities);
    if (!activeUnit)
      return;
    const actions = activeUnit.actions.filter((v3) => activeUnit.owner === game.localPlayer || v3.available?.());
    const sortedActions = qwertySort.map((k3) => actions.find((b3) => b3.hotkey === k3)).filter(defined);
    this.activeActions.push(...sortedActions);
    this.activeActions.forEach((action) => {
      const charCode = action.hotkey.charCodeAt(0);
      if (charCode < aCharCode || charCode > zCharCode || action.hotkey.length > 1)
        return;
      const elem2 = action.elem ?? genNode(action);
      container.appendChild(elem2);
    });
  }
}, "Hotkeys");
__name2(Hotkeys, "Hotkeys");
var CAMERA_SPEED = 25;
var ZOOM_SPEED = 1 / 500;
var uiElem2 = doc.getElementById("ui");
var keyboard = {};
var emptyMouse = /* @__PURE__ */ __name2((mouse2) => {
  const empty = {right: false, left: false, down: false, up: false};
  if (!mouse2)
    return empty;
  return Object.assign(mouse2, empty);
}, "emptyMouse");
var mouse = emptyMouse();
var requestedAnimationFrame;
var pan;
var setMouseAndRender = /* @__PURE__ */ __name2((direction) => {
  if (mouse[direction])
    return;
  if (pan)
    pan = void 0;
  mouse[direction] = true;
  renderCamera();
}, "setMouseAndRender");
var setZoom = /* @__PURE__ */ __name2((zoom) => {
  const camera = currentGame().graphics.camera;
  if (camera)
    camera.position.z = zoom;
  localStorage.setItem("zoom", zoom.toString());
}, "setZoom");
var initCameraListeners = /* @__PURE__ */ __name2((ui) => {
  ui.addEventListener("keyDown", ({key}) => {
    if (key.startsWith("Arrow") && !keyboard[key]) {
      if (pan)
        pan = void 0;
      keyboard[key] = true;
      if (!requestedAnimationFrame)
        renderCamera();
    }
  });
  ui.addEventListener("keyUp", ({key}) => {
    if (key.startsWith("Arrow"))
      keyboard[key] = false;
  });
  ui.addEventListener("mouseMove", ({target: target2, x: x3, y: y3}) => {
    if (target2 && target2 instanceof Element && uiElem2.contains(target2))
      return emptyMouse(mouse);
    if (x3 > win.innerWidth - 48)
      setMouseAndRender("right");
    else if (x3 > win.innerWidth / 2)
      mouse.right = false;
    else if (x3 > 48)
      mouse.left = false;
    else
      setMouseAndRender("left");
    if (y3 > win.innerHeight - 48)
      setMouseAndRender("down");
    else if (y3 > win.innerHeight / 2)
      mouse.down = false;
    else if (y3 > 48)
      mouse.up = false;
    else
      setMouseAndRender("up");
  });
  ui.addEventListener("mouseOut", ({relatedTarget}) => {
    if (relatedTarget)
      return;
    emptyMouse(mouse);
  });
  ui.addEventListener("wheel", ({deltaY}) => {
    const camera = currentGame().graphics.camera;
    if (camera)
      setZoom(camera.position.z + deltaY * ZOOM_SPEED);
  });
}, "initCameraListeners");
var lastRender = 0;
var renderCamera = /* @__PURE__ */ __name2((time) => {
  const delta = (lastRender && time ? time - lastRender : 17) / 1e3;
  lastRender = time;
  const game = currentGame();
  const graphics = game.graphics;
  if (pan) {
    const {x: x3, y: y3} = pan.step(delta * pan.distance / pan.duration);
    if (x3 !== pan.target.x || y3 !== pan.target.y)
      requestedAnimationFrame = rAF(wrapGame(game, renderCamera));
    else
      requestedAnimationFrame = void 0;
  } else {
    let y3 = 0;
    let x3 = 0;
    if (keyboard.ArrowDown)
      y3 -= delta * CAMERA_SPEED;
    if (keyboard.ArrowUp)
      y3 += delta * CAMERA_SPEED;
    if (keyboard.ArrowRight)
      x3 += delta * CAMERA_SPEED;
    if (keyboard.ArrowLeft)
      x3 -= delta * CAMERA_SPEED;
    if (mouse.up)
      y3 += delta * CAMERA_SPEED;
    if (mouse.down)
      y3 -= delta * CAMERA_SPEED;
    if (mouse.left)
      x3 -= delta * CAMERA_SPEED;
    if (mouse.right)
      x3 += delta * CAMERA_SPEED;
    graphics.panTo({
      x: graphics.camera.position.x + x3,
      y: graphics.camera.position.y + 7 + y3
    }, 0);
    if (mouse.up)
      if (mouse.left)
        doc.body.style.cursor = "nw-resize";
      else if (mouse.right)
        doc.body.style.cursor = "ne-resize";
      else
        doc.body.style.cursor = "n-resize";
    else if (mouse.down)
      if (mouse.left)
        doc.body.style.cursor = "sw-resize";
      else if (mouse.right)
        doc.body.style.cursor = "se-resize";
      else
        doc.body.style.cursor = "s-resize";
    else if (mouse.left)
      doc.body.style.cursor = "w-resize";
    else if (mouse.right)
      doc.body.style.cursor = "e-resize";
    else
      doc.body.style.cursor = "";
    if (Object.values(keyboard).some(Boolean) || Object.values(mouse).some(Boolean))
      requestedAnimationFrame = rAF(wrapGame(game, renderCamera));
    else
      requestedAnimationFrame = void 0;
  }
}, "renderCamera");
registerCommand({
  name: "zoom",
  comment: "Zooms in or out. Initial 10",
  args: [{required: true, name: "level"}],
  handler: (_2, zoom) => setZoom(parseFloat(zoom))
});
var initListeners = /* @__PURE__ */ __name2((ui) => {
  ui.addEventListener("keyDown", ({key, ctrlDown}) => {
    if (key !== "h" || !ctrlDown)
      return;
    const hotkeys = doc.getElementById("hotkeys");
    const showHotkeysUI = hotkeys.style.visibility === "hidden";
    hotkeys.style.visibility = showHotkeysUI ? "visible" : "hidden";
    storage.setItem("showHotkeysUI", showHotkeysUI.toString());
  });
}, "initListeners");
registerCommand({
  name: "hideHotkeys",
  comment: "Hides the hotkey icons at the bottom of the window\nToggle via Ctrl+H",
  handler: () => {
    const hotkeys = doc.getElementById("hotkeys");
    hotkeys.style.visibility = "hidden";
    storage.setItem("showHotkeysUI", "false");
  }
});
registerCommand({
  name: "showHotkeys",
  comment: "Shows the hotkey icons at the bottom of the window\nToggle via Ctrl+H",
  handler: () => {
    const hotkeys = doc.getElementById("hotkeys");
    hotkeys.style.visibility = "visible";
    storage.setItem("showHotkeysUI", "true");
  }
});
{
  const showHotkeysUI = storage.getItem("showHotkeysUI") === "true";
  const hotkeys = doc.getElementById("hotkeys");
  if (hotkeys && !showHotkeysUI)
    hotkeys.style.visibility = "hidden";
}
var elem = doc.getElementById("waiting-splash");
var initSplashListeners = /* @__PURE__ */ __name2((game) => {
  if (!elem)
    return;
  game.addNetworkListener("init", ({connections}) => {
    if (connections !== 0)
      elem.style.visibility = "visible";
  });
  game.addNetworkListener("state", () => {
    elem.style.visibility = "hidden";
  });
}, "initSplashListeners");
var MouseButton2;
(function(MouseButton3) {
  MouseButton3[MouseButton3["LEFT"] = 0] = "LEFT";
  MouseButton3[MouseButton3["WHEEL"] = 1] = "WHEEL";
  MouseButton3[MouseButton3["RIGHT"] = 2] = "RIGHT";
  MouseButton3[MouseButton3["BACK"] = 3] = "BACK";
  MouseButton3[MouseButton3["FORWARD"] = 4] = "FORWARD";
})(MouseButton2 || (MouseButton2 = {}));
var Game = q(void 0);
var useEventListener = /* @__PURE__ */ __name2((eventTarget, eventName, callback) => {
  const savedHandler = s2();
  y2(() => {
    savedHandler.current = callback;
  }, [callback]);
  y2(() => {
    eventTarget.addEventListener(eventName, savedHandler.current);
    return () => eventTarget.removeEventListener(eventName, savedHandler.current);
  }, [eventName, eventTarget]);
}, "useEventListener");
var formatSeconds = /* @__PURE__ */ __name2((time) => {
  time = Math.floor(time);
  const seconds = Math.max(time % 60, 0).toString();
  time = Math.floor(time / 60);
  const minutes = Math.max(time % 60, 0).toString();
  return minutes.padStart(2, "0") + ":" + seconds.padStart(2, "0");
}, "formatSeconds");
var Clock = /* @__PURE__ */ __name2(() => {
  const [time, setTime] = l2(0);
  const game = F(Game);
  useEventListener(game, "update", setTime);
  return /* @__PURE__ */ a("span", null, game.round && formatSeconds(game.round.expireAt - time));
}, "Clock");
var useForceRender = /* @__PURE__ */ __name2(() => p2(() => ({}), {})[1], "useForceRender");
var attached = new Set();
var FPS = /* @__PURE__ */ __name2(() => {
  const game = F(Game);
  const forceRender = useForceRender();
  if (!attached.has(game)) {
    game.addMechanism(new class extends Mechanism {
      render() {
        forceRender();
      }
    }());
    attached.add(game);
  }
  const fps = game.fpsMonitor.fps.toFixed(0);
  return /* @__PURE__ */ a("span", {
    className: "diagnostic"
  }, fps, "fps");
}, "FPS");
var Button = /* @__PURE__ */ __name2(({
  buttonRef,
  type,
  children,
  ...props
}) => /* @__PURE__ */ a("button", {
  ...props,
  ref: buttonRef,
  type: type ?? "button"
}, children), "Button");
var classNames = /* @__PURE__ */ __name2((...args) => args.filter(Boolean).join(" "), "classNames");
var styles = /* @__PURE__ */ __name2((...args) => {
  const final = {};
  for (const style of args)
    for (const rule in style)
      final[rule] = style[rule];
  return final;
}, "styles");
var Group2 = /* @__PURE__ */ __name2(({
  spacing = 0,
  direction = "horizontal",
  children,
  className,
  style,
  innerStyle,
  ...props
}) => {
  const wrappedChildren = w(children).map((child, i3) => {
    const visible = typeof child !== "object" || !("hidden" in child.props) || !child.props.hidden;
    return /* @__PURE__ */ a("div", {
      key: i3,
      style: styles(innerStyle, visible ? {
        "margin-left": spacing,
        "margin-top": spacing
      } : void 0)
    }, child);
  });
  return /* @__PURE__ */ a("div", {
    ...props,
    className: classNames(className, "group", `group--direction-${direction}`),
    style: styles(style, {
      "margin-left": -spacing,
      "margin-top": -spacing
    })
  }, wrappedChildren);
}, "Group");
var Input = /* @__PURE__ */ __name2(({
  error,
  inputRef,
  ...props
}) => {
  const input = inputRef ?? s2();
  y2(() => {
    input.current.setCustomValidity(error ?? "");
    input.current.reportValidity();
    if (error)
      input.current.focus();
  }, [error]);
  return /* @__PURE__ */ a("input", {
    ref: input,
    ...props
  });
}, "Input");
var activeHost = loc.port ? `${loc.hostname}:${8080}` : `ws.${loc.hostname}`;
var networkEvents = {
  init: (data) => {
  },
  state: (data) => {
  },
  update: (data) => {
  },
  build: (data) => {
  },
  move: (data) => {
  },
  attack: (data) => {
  },
  holdPosition: (data) => {
  },
  stop: (data) => {
  },
  mirror: (data) => {
  },
  upgrade: (data) => {
  },
  chat: (data) => {
  },
  disconnection: (data) => {
  },
  connection: (data) => {
  },
  ping: (data) => {
  }
};
var isNetworkEvent = /* @__PURE__ */ __name2((json, networkEvents22) => typeof json === "object" && typeof json.type === "string" && json.type.length && json.type in networkEvents22, "isNetworkEvent");
var Network = /* @__PURE__ */ __name(class {
  constructor() {
    emitter(this);
  }
  send(data) {
    if (!this.connection)
      throw new Error("Network has not been connected");
    this.connection.send(JSON.stringify(Object.assign(data, {sent: performance.now()})));
  }
  connect(token) {
    this.connection = new WebSocket(`${loc.protocol === "https:" ? "wss:" : "ws:"}//${activeHost}?${encodeURIComponent(token)}`);
    this.connection.addEventListener("message", (message) => this.onMessage(message));
  }
  onMessage(message) {
    const json = JSON.parse(message.data);
    if (isNetworkEvent(json, this.constructor.networkEvents)) {
      const event = json;
      if (event.type === "connection")
        this.onConnection(event);
      if ("connection" in event && "sent" in event && this.localPlayerId === event.connection && typeof event.sent === "number")
        this.dispatchEvent("ping", {
          type: "ping",
          eventType: event.type,
          ping: performance.now() - event.sent
        });
      this.dispatchEvent(event.type, event);
    } else
      console.warn("untyped event", json);
  }
  onConnection(message) {
    if (this.localPlayerId === void 0 && !this.isHost)
      this.localPlayerId = message.connection;
  }
  get isHost() {
    return !this.connection;
  }
}, "Network");
Network.networkEvents = networkEvents;
__name2(Network, "Network");
var wrappedFetch = /* @__PURE__ */ __name2(async (url, body, options = {}) => {
  if (!url.match(/^\w+:\/\//))
    url = `//${activeHost}/${url.replace(/^\//, "")}`;
  if (!options.headers)
    options.headers = {};
  if (!options.headers["Content-Type"])
    options.headers["Content-Type"] = "application/json";
  if (body && typeof body !== "string")
    options.body = JSON.stringify(body);
  if (options.body && options.method === void 0)
    options.method = "POST";
  const result = await fetch(url, options);
  return {
    status: result.status,
    ok: result.ok,
    body: await result.json()
  };
}, "wrappedFetch");
var initial = Object.freeze({
  status: "initial",
  isInitial: true,
  isPending: false,
  isCompleted: false,
  isErrored: false,
  data: void 0,
  error: void 0
});
var pending = Object.freeze({
  status: "pending",
  isInitial: false,
  isPending: true,
  isCompleted: false,
  isErrored: false,
  data: void 0,
  error: void 0
});
var completed = /* @__PURE__ */ __name2((data) => ({
  status: "completed",
  isInitial: false,
  isPending: false,
  isCompleted: true,
  isErrored: false,
  data,
  error: void 0
}), "completed");
var errored = /* @__PURE__ */ __name2((error) => ({
  status: "errored",
  isInitial: false,
  isPending: false,
  isCompleted: false,
  isErrored: true,
  data: void 0,
  error
}), "errored");
var useFetch = /* @__PURE__ */ __name2(({
  url,
  body,
  options
}) => {
  const [fetchState, setFetchState] = l2(initial);
  const performFetch = A2(async ({
    url: finalUrl = url,
    body: finalBody = body,
    options: finalOptions = options
  }) => {
    setFetchState(pending);
    try {
      const args = [
        finalUrl,
        finalBody,
        finalOptions
      ];
      for (let i3 = args.length - 1; i3 >= 0 && !args[i3]; i3--)
        args.length--;
      const result = await wrappedFetch(...args);
      if (!result.ok) {
        const newFetchState2 = errored(result.body);
        setFetchState(newFetchState2);
        return newFetchState2;
      }
      const newFetchState = completed(result.body);
      setFetchState(newFetchState);
      return newFetchState;
    } catch (error) {
      const newFetchState = errored({
        code: -1,
        message: String(error.message)
      });
      setFetchState(newFetchState);
      return newFetchState;
    }
  }, [url, body, options]);
  return {...fetchState, performFetch};
}, "useFetch");
var useLogin = /* @__PURE__ */ __name2(() => {
  const fetch2 = useFetch({
    url: "auth/login"
  });
  const performFetch = /* @__PURE__ */ __name2((username, password, register = false, room) => fetch2.performFetch({
    url: password ? register ? "auth/register" : "auth/login" : "auth/anon",
    body: {username, password, ...room ? {room} : null}
  }), "performFetch");
  return {...fetch2, performFetch};
}, "useLogin");
var RegisterButton = /* @__PURE__ */ __name2((props) => /* @__PURE__ */ a(Button, {
  ...props
}, "Reserve username"), "RegisterButton");
var Login = /* @__PURE__ */ __name2(({
  onSuccess
}) => {
  const game = F(Game);
  const [mode, setMode] = l2("init");
  const [username, setUsername] = l2(storage.getItem("username") ?? "");
  const [password, setPassword] = l2(void 0);
  const [verifyPassword, setVerifyPassword] = l2(void 0);
  const usernameInput = s2();
  const passwordInput = s2();
  const verifyPasswordInput = s2();
  const [dirty, setDirty] = l2(false);
  const login = useLogin();
  y2(() => setDirty(true), [username, password, verifyPassword]);
  const onSubmit = A2(async (e3) => {
    e3.preventDefault();
    if (login.isPending)
      return;
    setDirty(false);
    if (mode === "register" && password !== verifyPassword) {
      verifyPasswordInput.current.focus();
      return;
    }
    const result = await login.performFetch(username, password, mode === "register", game.protocol);
    if (result.isCompleted) {
      game.connect(result.data.token);
      setMode("done");
      onSuccess();
      return;
    }
    if (result.isErrored) {
      if (result.error.code === 0 && mode === "init") {
        setMode("login");
        passwordInput.current.focus();
      } else if (result.error.code === 1)
        passwordInput.current.focus();
      else if (result.error.code === 2)
        usernameInput.current.focus();
    }
  }, [login, mode, password, verifyPassword, game]);
  return /* @__PURE__ */ a("form", {
    style: {visibility: mode === "done" ? "hidden" : "default"},
    onSubmit
  }, /* @__PURE__ */ a(Group2, {
    spacing: 8
  }, /* @__PURE__ */ a("h2", null, game.displayName), /* @__PURE__ */ a(Input, {
    "data-test": "username",
    inputRef: usernameInput,
    value: username,
    maxLength: 16,
    placeholder: "username",
    onInput: (e3) => {
      setUsername(e3.currentTarget.value);
      storage.setItem("username", e3.currentTarget.value);
    },
    error: !dirty && login.isErrored && login.error.code === 2 ? login.error.message : void 0,
    disabled: login.isPending,
    autoFocus: true
  }), /* @__PURE__ */ a(Input, {
    "data-test": "password",
    inputRef: passwordInput,
    placeholder: "password",
    type: "password",
    autoComplete: "password",
    onInput: (e3) => setPassword(e3.currentTarget.value),
    hidden: mode === "init",
    style: mode === "init" ? {padding: 0, height: 0, overflow: "hidden"} : void 0,
    error: !dirty && login.isErrored && login.error.code === 1 ? login.error.message : void 0,
    disabled: login.isPending,
    tabIndex: mode === "init" ? -1 : void 0
  }), (mode === "init" || mode === "login") && /* @__PURE__ */ a(Button, {
    "data-test": "login",
    type: "submit",
    disabled: login.isPending
  }, "Login"), mode !== "register" && /* @__PURE__ */ a(RegisterButton, {
    "data-test": "register-1",
    onClick: () => {
      setMode("register");
      if (username.trim().length > 0)
        passwordInput.current.focus();
      else
        usernameInput.current.focus();
    },
    disabled: login.isPending
  }), mode === "register" && /* @__PURE__ */ a(Group2, {
    spacing: 8
  }, /* @__PURE__ */ a(Input, {
    "data-test": "verify-password",
    inputRef: verifyPasswordInput,
    placeholder: "verify password",
    type: "password",
    autoComplete: "password",
    onInput: (e3) => setVerifyPassword(e3.currentTarget.value),
    disabled: login.isPending,
    error: !dirty && password !== verifyPassword ? "Passwords don't match" : void 0
  }), /* @__PURE__ */ a(RegisterButton, {
    "data-test": "register-2",
    type: "submit",
    disabled: login.isPending
  })), mode !== "init" && /* @__PURE__ */ a(Button, {
    "data-test": "cancel",
    disabled: login.isPending,
    onClick: () => {
      setMode("init");
      usernameInput.current.focus();
    }
  }, "Cancel"), /* @__PURE__ */ a("div", {
    "data-test": "error"
  }, login.isErrored && ![0, 1, 2].includes(login.error.code) && login.error.message)));
}, "Login");
var useGameNetworkListener = /* @__PURE__ */ __name2((eventName, callback) => {
  const game = F(Game);
  const savedHandler = s2();
  y2(() => {
    savedHandler.current = callback;
  }, [callback]);
  y2(() => {
    game.addNetworkListener(eventName, savedHandler.current);
    return () => game.removeNetworkListener(eventName, savedHandler.current);
  }, [eventName, callback, game]);
}, "useGameNetworkListener");
var Ping = /* @__PURE__ */ __name2(() => {
  const pings = s2([]).current;
  const forceRender = useForceRender();
  useGameNetworkListener("ping", A2((ping) => {
    pings.push(ping);
    if (pings.length === 6)
      pings.shift();
    forceRender();
  }, []));
  const median = [...pings].sort((a3, b3) => a3.ping - b3.ping)[Math.min(2, pings.length - 1)];
  const title = [...pings].reverse().map(({eventType, ping}) => `${eventType}: ${ping.toFixed(1)}ms`).join("\n");
  return median && /* @__PURE__ */ a("span", {
    title,
    className: "diagnostic"
  }, median.ping.toFixed(1), "ms");
}, "Ping");
var Resources = /* @__PURE__ */ __name2(() => {
  const [, setTime] = l2(0);
  const game = F(Game);
  useEventListener(game, "update", setTime);
  if (!game.localPlayer)
    return /* @__PURE__ */ a(y, null);
  return /* @__PURE__ */ a(y, null, Object.entries(game.localPlayer.resources).filter(([, value]) => typeof value === "number").map(([key, value]) => /* @__PURE__ */ a("span", {
    className: `resource ${key}`,
    key,
    title: key[0].toUpperCase() + key.slice(1)
  }, game.localPlayer && Math.floor(value ?? 0))));
}, "Resources");
var formatSeconds2 = /* @__PURE__ */ __name2((time) => {
  time = Math.floor(time);
  const seconds = Math.max(time % 60, 0).toString();
  time = Math.floor(time / 60);
  const minutes = Math.max(time % 60, 0).toString();
  return minutes.padStart(2, "0") + ":" + seconds.padStart(2, "0");
}, "formatSeconds");
var TimerWindows2 = /* @__PURE__ */ __name2(() => {
  const [time, setTime] = l2(0);
  const game = F(Game);
  useEventListener(game, "update", setTime);
  return /* @__PURE__ */ a("span", {
    className: "timer-windows"
  }, game.timerWindows.getTimerWindows().map(({entity, timerWindow, timer}) => /* @__PURE__ */ a("span", {
    key: entity.id,
    className: "timer-window"
  }, /* @__PURE__ */ a("span", {
    className: "title"
  }, timerWindow.title), /* @__PURE__ */ a("span", {
    className: "time"
  }, formatSeconds2(timer.next - time)))));
}, "TimerWindows");
var UI = /* @__PURE__ */ __name(class {
  constructor() {
    emitter(this);
    const game = currentGame();
    win.addEventListener("keydown", wrapGame(game, (e3) => {
      if (e3.key === "f" && e3.ctrlKey)
        e3.preventDefault();
      this.dispatchEvent("keyDown", {
        ctrlDown: e3.ctrlKey,
        game,
        key: e3.key,
        target: e3.target
      });
    }));
    win.addEventListener("keyup", wrapGame(game, (e3) => {
      this.dispatchEvent("keyUp", {
        ctrlDown: e3.ctrlKey,
        game,
        key: e3.key
      });
    }));
    win.addEventListener("mousemove", wrapGame(game, (e3) => {
      this.dispatchEvent("mouseMove", {
        target: e3.target,
        x: e3.clientX,
        y: e3.clientY
      });
    }));
    win.addEventListener("mouseout", wrapGame(game, (e3) => {
      this.dispatchEvent("mouseOut", {
        relatedTarget: e3.relatedTarget
      });
    }));
    win.addEventListener("mousedown", wrapGame(game, (e3) => {
      this.dispatchEvent("mouseDown", {
        button: e3.button,
        ctrlDown: e3.ctrlKey,
        game,
        target: e3.target,
        x: e3.clientX,
        y: e3.clientY
      });
    }));
    win.addEventListener("wheel", wrapGame(game, (e3) => {
      this.dispatchEvent("wheel", {
        deltaY: e3.deltaY
      });
    }));
    initCameraListeners(this);
    initListeners(this);
    initChatListeners(game, this);
    initSplashListeners(game);
    const loadApp = /* @__PURE__ */ __name2(async () => {
      const {initialize} = await Promise.resolve().then(() => require_App());
      initialize(game);
    }, "loadApp");
    if (doc.readyState === "complete" || doc.readyState === "interactive")
      loadApp();
    else
      win.addEventListener("DOMContentLoaded", loadApp);
  }
}, "UI");
__name2(UI, "UI");
var Game2 = /* @__PURE__ */ __name(class extends App {
  constructor(network) {
    super();
    this.players = [];
    this.synchronizationState = "synchronizing";
    this.newPlayers = false;
    this.random = alea("");
    this.lastUpdate = 0;
    this.intervals = [];
    this.nextIntervalId = 0;
    this.timeouts = [];
    this.nextTimeoutId = 0;
    withGame(this, () => {
      emitter(this);
      this.addSystem(new MoveSystem());
      this.addSystem(new AttackSystem());
      this.addSystem(new BlueprintSystem());
      this.addSystem(new ProjectileSystem());
      this.addSystem(new GerminateSystem());
      this.addSystem(new AutoAttackSystem());
      this.addSystem(new AnimationSystem());
      this.addSystem(new MeshBuilder());
      this.addSystem(new TimerSystem());
      this.fpsMonitor = new FPSMonitor().addToApp(this);
      this.timerWindows = new TimerWindows().addToApp(this);
      this.graphics = new ThreeGraphics(this).addToApp(this);
      this.addSystem(new GraphicMoveSystem());
      this.addSystem(new GraphicTrackPosition());
      circleSystems.forEach((CircleSystem) => this.addSystem(new CircleSystem()));
      this.actions = new Hotkeys().addToApp(this);
      this.network = network;
      this.addNetworkListener = (event, callback) => this.network.addEventListener(event, wrapGame(this, callback));
      this.removeNetworkListener = (event, callback) => this.network.removeEventListener(event, wrapGame(this, callback));
      this.connect = this.network.connect.bind(this.network);
      this.addNetworkListener("update", (e3) => this.update(e3));
      this.ui = new UI();
      this.mouse = new Mouse(this.graphics, this.ui).addToApp(this);
      this.obstructionPlacement = new ObstructionPlacement(this).addToApp(this);
      this.selectionSystem = new SelectedSystem().addToApp(this);
      this.alliances = new Alliances().addToApp(this);
      initPlayerLogic(this);
      initSpriteLogicListeners(this);
    });
  }
  get displayName() {
    return this.constructor.displayName;
  }
  get protocol() {
    return this.constructor.protocol;
  }
  get __UNSAFE_network() {
    return this.network;
  }
  transmit(data) {
    this.network.send(data);
  }
  get isHost() {
    return this.network.isHost;
  }
  setInterval(fn, interval = 0.05, oncePerUpdate = true) {
    const id = this.nextIntervalId;
    this.intervals.push({
      fn,
      next: this.time + interval,
      interval,
      oncePerUpdate,
      id
    });
    this.nextIntervalId = id + 1;
    return id;
  }
  clearInterval(id) {
    const index = this.intervals.findIndex((i3) => i3.id === id);
    if (index >= 0)
      this.intervals.splice(index, 1);
  }
  setTimeout(fn, timeout = 0.05) {
    const id = this.nextTimeoutId;
    this.timeouts.push({fn, next: this.time + timeout, id});
    this.nextTimeoutId = id + 1;
    return id;
  }
  clearTimeout(id) {
    const index = this.timeouts.findIndex((i3) => i3.id === id);
    if (index >= 0)
      this.timeouts.splice(index, 1);
  }
  updateIntervals(time) {
    this.intervals.sort((a3, b3) => a3.next - b3.next);
    const intervals = [...this.intervals];
    let intervalIndex = 0;
    while (intervals[intervalIndex] && intervals[intervalIndex].next < time) {
      const interval = intervals[intervalIndex];
      interval.next = interval.oncePerUpdate ? time + interval.interval : interval.next + interval.interval;
      interval.fn();
      if (interval.oncePerUpdate || interval.next > time)
        intervalIndex++;
    }
  }
  updateTimeouts(time) {
    this.timeouts.sort((a3, b3) => a3.next - b3.next);
    const timeouts = [...this.timeouts];
    let timeoutIndex = 0;
    while (timeouts[timeoutIndex] && timeouts[timeoutIndex].next < time) {
      const timeout = timeouts[timeoutIndex];
      timeout.fn();
      timeoutIndex++;
      const index = this.timeouts.indexOf(timeout);
      if (index >= 0)
        this.timeouts.splice(index, 1);
    }
  }
  onPlayerJoin(data) {
    return new Player({
      color: nextColor(),
      game: this,
      id: data.connection,
      username: data.username
    });
  }
  onPlayerLeave(player) {
    this.players.splice(this.players.indexOf(player), 1);
    player.isHere = false;
    const color = player.color;
    if (color)
      releaseColor(color);
  }
  remove(entity) {
    if (!this._entities.has(entity))
      return false;
    for (const system of this.allSystems)
      system.remove(entity);
    entity.clear();
    if (isSprite(entity))
      entity.remove(true);
    if (this.obstructionPlacement.builder === entity)
      this.obstructionPlacement.stop();
    this._entities.delete(entity);
    return true;
  }
  render() {
    withGame(this, () => this._render());
  }
  _update(e3) {
    super._update(e3);
    const time = e3.time / 1e3;
    this.lastUpdate = time;
    this.updateIntervals(time);
    this.updateTimeouts(time);
  }
  update(e3) {
    withGame(this, () => this._update(e3));
  }
  toJSON() {
    return {
      lastUpdate: this.lastUpdate,
      players: this.players.map((p3) => p3.toJSON()),
      entityId: this.entityId
    };
  }
}, "Game2");
Game2.isGame = true;
Game2.displayName = "Untitled Game";
Game2.protocol = "unknown";
__name2(Game2, "Game");
var PathingEntity = /* @__PURE__ */ __name(class extends Component {
  constructor() {
    super(...arguments);
    this.derived = true;
  }
  initialize({
    collisionRadius,
    blocksPathing,
    blocksTilemap,
    pathing,
    requiresPathing,
    requiresTilemap,
    structure,
    x: x3,
    y: y3
  }) {
    const mutable = this;
    mutable.collisionRadius = collisionRadius;
    mutable.blocksPathing = blocksPathing;
    mutable.blocksTilemap = blocksTilemap;
    mutable.pathing = pathing;
    mutable.requiresPathing = requiresPathing;
    mutable.requiresTilemap = requiresTilemap;
    mutable.structure = structure;
    mutable.xGet = x3;
    mutable.yGet = y3;
  }
  get position() {
    return {x: this.xGet(), y: this.yGet()};
  }
}, "PathingEntity");
__name2(PathingEntity, "PathingEntity");
var BinaryHeap = /* @__PURE__ */ __name(class extends Array {
  constructor(scoreFunc) {
    super();
    this.scoreFunc = scoreFunc;
  }
  push(element) {
    this.bubbleUp(super.push(element) - 1);
    return 0;
  }
  pop() {
    const top = this[0];
    const bottom = super.pop();
    if (this.length > 0) {
      this[0] = bottom;
      this.sinkDown(0);
    }
    return top;
  }
  remove(element) {
    const length = this.length;
    for (let i3 = 0; i3 < length; i3++) {
      if (this[i3] !== element)
        continue;
      const bottom = super.pop();
      if (i3 === length - 1)
        break;
      this[i3] = bottom;
      this.bubbleUp(i3);
      this.sinkDown(i3);
      break;
    }
  }
  bubbleUp(index) {
    const element = this[index];
    const score = this.scoreFunc(element);
    while (index > 0) {
      const parentIndex = Math.floor((index + 1) / 2) - 1, parent = this[parentIndex];
      if (score >= this.scoreFunc(parent))
        break;
      this[parentIndex] = element;
      this[index] = parent;
      index = parentIndex;
    }
  }
  sinkDown(index) {
    const length = this.length;
    const element = this[index];
    const score = this.scoreFunc(element);
    while (true) {
      const rightIndex = (index + 1) * 2;
      const leftIndex = rightIndex - 1;
      let leftScore;
      let swapIndex = void 0;
      if (leftIndex < length) {
        const left = this[leftIndex];
        leftScore = this.scoreFunc(left);
        if (leftScore < score)
          swapIndex = leftIndex;
      }
      if (rightIndex < length) {
        const right = this[rightIndex];
        if (this.scoreFunc(right) < (swapIndex === void 0 ? score : leftScore))
          swapIndex = rightIndex;
      }
      if (swapIndex === void 0)
        break;
      this[index] = this[swapIndex];
      this[swapIndex] = element;
      index = swapIndex;
    }
  }
}, "BinaryHeap");
__name2(BinaryHeap, "BinaryHeap");
var memoize = /* @__PURE__ */ __name2((fn) => {
  let rootStore;
  const memoized = Object.assign((...args) => {
    if (!rootStore)
      rootStore = typeof args[0] === "object" ? new Map() : {};
    let store = rootStore;
    for (let i3 = 0; i3 < args.length - 1; i3++)
      if (store instanceof Map)
        if (store.has(args[i3]))
          store = store.get(args[i3]);
        else {
          store.set(args[i3], typeof args[i3] === "object" ? new Map() : {});
          store = store.get(args[i3]);
        }
      else if (args[i3] in store)
        store = store[args[i3]];
      else
        store[args[i3]] = store[args[i3]] = typeof args[i3] === "object" ? new Map() : {};
    const lastArg = args[args.length - 1];
    if (store instanceof Map)
      if (store.has(lastArg)) {
        memoized.hits++;
        return store.get(lastArg);
      } else {
        memoized.misses++;
        store.set(lastArg, fn(...args));
        return store.get(lastArg);
      }
    else if (lastArg in store) {
      memoized.hits++;
      return store[lastArg];
    }
    memoized.misses++;
    store[lastArg] = fn(...args);
    return store[lastArg];
  }, {hits: 0, misses: 0});
  return memoized;
}, "memoize");
var debugging = false;
try {
  Object.defineProperty(globalThis, "debugging", {
    set: (value) => debugging = value,
    get: () => debugging
  });
} catch (err) {
}
var DEFAULT_RESOLUTION = 1;
var MAX_TRIES = 8192;
var EPSILON = Number.EPSILON * 100;
var isComplexEntity = /* @__PURE__ */ __name2((entity) => "position" in entity, "isComplexEntity");
var pos = /* @__PURE__ */ __name2((entity) => {
  if (isComplexEntity(entity))
    return entity.position;
  return entity;
}, "pos");
var Tile = /* @__PURE__ */ __name(class {
  constructor(xTile, yTile, xWorld, yWorld, pathing) {
    this.entities = new Map();
    this.x = xTile;
    this.y = yTile;
    this.world = {x: xWorld, y: yWorld};
    this.pathing = this.originalPathing = pathing;
    this.nodes = [];
  }
  addEntity(entity, pathing) {
    this.entities.set(entity, pathing);
    this.recalculatePathing();
  }
  removeEntity(entity) {
    this.entities.delete(entity);
    this.recalculatePathing();
  }
  updateEntity(entity, pathing) {
    if (this.entities.get(entity) === pathing)
      return;
    this.addEntity(entity, pathing);
  }
  recalculatePathing() {
    this.pathing = this.originalPathing;
    this.entities.forEach((pathing) => this.pathing |= pathing);
  }
  pathable(pathing) {
    return (this.pathing & pathing) === 0;
  }
}, "Tile");
__name2(Tile, "Tile");
var PathingMap = /* @__PURE__ */ __name(class {
  constructor({
    pathing,
    resolution = DEFAULT_RESOLUTION,
    layers
  }) {
    this.entities = new Map();
    this.resolution = resolution;
    this.layers = layers;
    this.heightWorld = pathing.length;
    this.widthWorld = pathing[0].length;
    this.heightMap = this.heightWorld * this.resolution;
    this.widthMap = this.widthWorld * this.resolution;
    this.grid = [];
    for (let y3 = 0; y3 < pathing.length; y3++)
      for (let x3 = 0; x3 < pathing[y3].length; x3++)
        for (let y22 = 0; y22 < this.resolution; y22++) {
          if (!this.grid[y3 * this.resolution + y22])
            this.grid[y3 * this.resolution + y22] = [];
          for (let x22 = 0; x22 < this.resolution; x22++) {
            const tile = new Tile(x3 * this.resolution + x22, y3 * this.resolution + y22, x3 + x22 / this.resolution, y3 + y22 / this.resolution, pathing[y3][x3]);
            this.grid[y3 * this.resolution + y22][x3 * this.resolution + x22] = tile;
          }
        }
    for (let y3 = 0; y3 < this.grid.length; y3++)
      for (let x3 = 0; x3 < this.grid[y3].length; x3++) {
        const nodes = this.grid[y3][x3].nodes;
        if (y3 > 0)
          nodes.push(this.grid[y3 - 1][x3]);
        if (x3 > 0)
          nodes.push(this.grid[y3][x3 - 1]);
        if (x3 < this.widthMap - 1)
          nodes.push(this.grid[y3][x3 + 1]);
        if (y3 < this.heightMap - 1)
          nodes.push(this.grid[y3 + 1][x3]);
      }
    if (debugging) {
      const oldPath = this.path;
      this.path = (...args) => {
        const ret = oldPath.call(this, ...args);
        if (debugging)
          console.log("PathingMap#path", ret);
        return ret;
      };
      const oldRecheck = this.recheck;
      this.recheck = (...args) => {
        const ret = oldRecheck.call(this, ...args);
        if (debugging)
          console.log("PathingMap#recheck", ret);
        return ret;
      };
    }
  }
  _pathable(map, xTile, yTile, test) {
    if (xTile < 0 || yTile < 0 || xTile >= this.widthMap || yTile >= this.heightMap)
      return false;
    let i3 = 0;
    for (let y3 = yTile + map.top; y3 < yTile + map.height + map.top; y3++)
      for (let x3 = xTile + map.left; x3 < xTile + map.width + map.left; x3++, i3++)
        if (this.grid[y3]?.[x3] === void 0 || this.grid[y3][x3].pathing & map.map[i3] || test && !test(this.grid[y3][x3]))
          return false;
    return true;
  }
  pathable(entity, xWorld, yWorld) {
    const position = pos(entity);
    if (xWorld === void 0)
      xWorld = position.x;
    if (yWorld === void 0)
      yWorld = position.y;
    const xTile = this.xWorldToTile(xWorld);
    const yTile = this.yWorldToTile(yWorld);
    const map = entity.requiresTilemap ?? this.pointToTilemap(xWorld, yWorld, entity.collisionRadius, {
      type: entity.requiresPathing === void 0 ? entity.pathing : entity.requiresPathing
    });
    return this.withoutEntity(entity, () => this._pathable(map, xTile, yTile));
  }
  withoutEntity(entity, fn) {
    const removed = this.entities.has(entity);
    if (removed)
      this.removeEntity(entity);
    const result = fn();
    if (removed)
      this.addEntity(entity);
    return result;
  }
  nearestPathing(xWorld, yWorld, entity, test) {
    const tile = this.entityToTile(entity, {x: xWorld, y: yWorld});
    if (this._pathable(entity.requiresTilemap || this.pointToTilemap(xWorld, yWorld, entity.collisionRadius, {
      includeOutOfBounds: true,
      type: entity.requiresPathing === void 0 ? entity.pathing : entity.requiresPathing
    }), tile.x, tile.y, test))
      return {x: xWorld, y: yWorld};
    const target2 = {x: xWorld, y: yWorld};
    const pathing = entity.requiresPathing === void 0 ? entity.pathing : entity.requiresPathing;
    if (pathing === void 0)
      throw "entity has no pathing";
    const minimalTilemap = entity.requiresTilemap ?? this.pointToTilemap(entity.collisionRadius, entity.collisionRadius, entity.collisionRadius, {
      type: pathing
    });
    const radiusOffset = entity.collisionRadius % (1 / this.resolution);
    const offset22 = /* @__PURE__ */ __name2((point) => ({
      x: point.x + radiusOffset,
      y: point.y + radiusOffset
    }), "offset");
    const distance = /* @__PURE__ */ __name2((a3, b3) => (b3.x - a3.x) ** 2 + (b3.y - a3.y) ** 2, "distance");
    const tag = Math.random();
    const heap = new BinaryHeap((node) => node.__np ?? 0);
    const start = tile;
    start.__npTag = tag;
    start.__np = distance(target2, offset22(start.world));
    heap.push(start);
    while (heap.length) {
      const current = heap.pop();
      if (current.pathable(pathing) && this._pathable(minimalTilemap, current.x, current.y, test))
        return offset22(current.world);
      current.nodes.forEach((neighbor) => {
        if (neighbor.__npTag === tag)
          return;
        neighbor.__npTag = tag;
        neighbor.__np = distance(target2, offset22(neighbor.world));
        heap.push(neighbor);
      });
    }
    return {x: xWorld, y: yWorld};
  }
  _layer(xTile, yTile) {
    if (!this.layers)
      return;
    if (yTile < 0)
      return;
    xTile = Math.floor(xTile / this.resolution);
    yTile = Math.floor(yTile / this.resolution);
    if (this.layers.length <= yTile)
      return;
    return this.layers[yTile][xTile];
  }
  layer(xWorld, yWorld) {
    if (!this.layers)
      return;
    if (yWorld < 0)
      return;
    xWorld = Math.floor(xWorld);
    yWorld = Math.floor(yWorld);
    if (this.layers.length <= yWorld)
      return;
    return this.layers[yWorld][xWorld];
  }
  nearestSpiralPathing(xWorld, yWorld, entity, layer = this.layer(xWorld, yWorld)) {
    const originalX = xWorld;
    const originalY = yWorld;
    let xTile = this.xWorldToTile(xWorld);
    let yTile = this.yWorldToTile(yWorld);
    let attemptLayer = this._layer(xTile, yTile);
    if (layer === attemptLayer) {
      if (entity.requiresTilemap) {
        if (this._pathable(entity.requiresTilemap, xTile, yTile))
          return {
            x: this.xTileToWorld(xTile),
            y: this.yTileToWorld(yTile)
          };
      } else if (this._pathable(this.pointToTilemap(xWorld, yWorld, entity.collisionRadius, {
        includeOutOfBounds: true,
        type: entity.requiresPathing === void 0 ? entity.pathing : entity.requiresPathing
      }), xTile, yTile))
        return {x: xWorld, y: yWorld};
    }
    const xMiss = Math.abs(xWorld * this.resolution - xTile);
    const yMiss = Math.abs(yWorld * this.resolution - yTile);
    let direction = Math.abs(0.5 - xMiss) > Math.abs(0.5 - yMiss) ? xMiss < 0.5 ? DIRECTION.LEFT : DIRECTION.RIGHT : yMiss < 0.5 && yMiss > 0 ? DIRECTION.UP : DIRECTION.DOWN;
    let steps = 0;
    const stride = entity.structure ? 2 : 1;
    let initialSteps = 0;
    let remainingTries = MAX_TRIES;
    let minimalTilemap;
    let offset22;
    if (entity.requiresTilemap) {
      minimalTilemap = entity.requiresTilemap;
      offset22 = {
        x: entity.requiresTilemap.left / this.resolution,
        y: entity.requiresTilemap.top / this.resolution
      };
    } else {
      minimalTilemap = this.pointToTilemap(entity.collisionRadius, entity.collisionRadius, entity.collisionRadius, {
        type: entity.requiresPathing === void 0 ? entity.pathing : entity.requiresPathing
      });
      offset22 = {
        x: entity.collisionRadius % (1 / this.resolution),
        y: entity.collisionRadius % (1 / this.resolution)
      };
    }
    const tried = [];
    if (this.grid[yTile] && this.grid[yTile][xTile])
      tried.push(this.grid[yTile][xTile]);
    while (!this._pathable(minimalTilemap, xTile, yTile) || layer !== void 0 && attemptLayer !== layer) {
      if (!remainingTries--)
        return {x: originalX, y: originalY};
      switch (direction) {
        case DIRECTION.DOWN:
          yTile += stride;
          break;
        case DIRECTION.RIGHT:
          xTile += stride;
          break;
        case DIRECTION.UP:
          yTile -= stride;
          break;
        case DIRECTION.LEFT:
          xTile -= stride;
          break;
      }
      if (this.grid[yTile] && this.grid[yTile][xTile])
        tried.push(this.grid[yTile][xTile]);
      if (steps === 0) {
        steps = initialSteps;
        if (direction === 0 || direction === 2)
          initialSteps++;
        direction = (direction + 1) % 4;
      } else
        steps--;
      attemptLayer = this._layer(xTile, yTile);
    }
    return {
      x: this.xTileToWorld(xTile) + offset22.x,
      y: this.yTileToWorld(yTile) + offset22.y
    };
  }
  worldToTile(world) {
    return this.grid[this.yWorldToTile(world.y)][this.xWorldToTile(world.x)];
  }
  xWorldToTile(x3) {
    return Math.floor(x3 * this.resolution);
  }
  yWorldToTile(y3) {
    return Math.floor(y3 * this.resolution);
  }
  xTileToWorld(x3) {
    return x3 / this.resolution;
  }
  yTileToWorld(y3) {
    return y3 / this.resolution;
  }
  pointToTilemap(xWorld, yWorld, radius = 0, {type = PATHING_TYPES.WALKABLE, includeOutOfBounds = false} = {}) {
    radius -= EPSILON * radius * this.widthWorld;
    const xTile = this.xWorldToTile(xWorld);
    const yTile = this.yWorldToTile(yWorld);
    const map = [];
    const xMiss = xTile / this.resolution - xWorld;
    const yMiss = yTile / this.resolution - yWorld;
    const minX = Math.max(this.xWorldToTile(xWorld - radius) - xTile, includeOutOfBounds ? -Infinity : -xTile);
    const maxX = Math.min(this.xWorldToTile(xWorld + radius) - xTile, includeOutOfBounds ? Infinity : this.widthMap - xTile - 1);
    const minY = Math.max(this.yWorldToTile(yWorld - radius) - yTile, includeOutOfBounds ? -Infinity : -yTile);
    const maxY = Math.min(this.yWorldToTile(yWorld + radius) - yTile, includeOutOfBounds ? Infinity : this.heightMap - yTile - 1);
    const radiusSquared = radius ** 2;
    for (let tY = minY; tY <= maxY; tY++)
      for (let tX = minX; tX <= maxX; tX++) {
        const yDelta = tY < 0 ? (tY + 1) / this.resolution + yMiss : tY > 0 ? tY / this.resolution + yMiss : 0;
        const xDelta = tX < 0 ? (tX + 1) / this.resolution + xMiss : tX > 0 ? tX / this.resolution + xMiss : 0;
        if (xDelta ** 2 + yDelta ** 2 < radiusSquared)
          map.push(type);
        else
          map.push(0);
      }
    const footprint = {
      map,
      top: minY,
      left: minX,
      width: maxX - minX + 1,
      height: maxY - minY + 1
    };
    return footprint;
  }
  yBoundTile(yIndex) {
    return Math.max(Math.min(yIndex, this.heightMap - 1), 0);
  }
  xBoundTile(xIndex) {
    return Math.max(Math.min(xIndex, this.widthMap - 1), 0);
  }
  path(entity, target2, start = pos(entity)) {
    if (typeof entity.collisionRadius !== "number")
      throw new Error("Can only path find radial entities");
    const cache = {
      _linearPathable: memoize((...args) => this._linearPathable(...args)),
      _pathable: memoize((...args) => this._pathable(...args)),
      pointToTilemap: memoize((...args) => this.pointToTilemap(...args))
    };
    const removed = this.entities.has(entity);
    if (removed)
      this.removeEntity(entity);
    const pathing = entity.requiresPathing === void 0 ? entity.pathing : entity.requiresPathing;
    if (pathing === void 0)
      throw "entity has no pathing";
    const minimalTilemap = cache.pointToTilemap(entity.collisionRadius, entity.collisionRadius, entity.collisionRadius, {type: pathing});
    const offset22 = entity.collisionRadius % (1 / this.resolution);
    const startReal = {
      x: start.x * this.resolution,
      y: start.y * this.resolution
    };
    const startTile = this.entityToTile(entity);
    const targetTile = this.entityToTile(entity, target2);
    const targetPathable = targetTile && targetTile.pathable(pathing) && this.pathable(entity, target2.x, target2.y);
    const endTile = targetPathable ? targetTile : (() => {
      const {x: x3, y: y3} = this.nearestPathing(target2.x, target2.y, entity);
      return this.grid[Math.round((y3 - offset22) * this.resolution)][Math.round((x3 - offset22) * this.resolution)];
    })();
    const endReal = targetPathable ? {x: target2.x * this.resolution, y: target2.y * this.resolution} : endTile;
    if (startTile === endTile && this.pathable(entity)) {
      if (removed)
        this.addEntity(entity);
      return [
        {x: start.x, y: start.y},
        {
          x: endReal.x / this.resolution,
          y: endReal.y / this.resolution
        }
      ];
    }
    const h11 = /* @__PURE__ */ __name2((a3, b3) => Math.sqrt((b3.x - a3.x) ** 2 + (b3.y - a3.y) ** 2), "h");
    const startHeap = new BinaryHeap((node) => node.__startRealPlusEstimatedCost ?? 0);
    const startTag = Math.random();
    let startBest = startTile;
    startHeap.push(startTile);
    startTile.__startTag = startTag;
    startTile.__startRealCostFromOrigin = h11(startReal, startTile);
    startTile.__startEstimatedCostRemaining = h11(startTile, endReal);
    startTile.__startRealPlusEstimatedCost = startTile.__startEstimatedCostRemaining + startTile.__startRealCostFromOrigin;
    startTile.__startVisited = false;
    startTile.__startClosed = false;
    startTile.__startParent = null;
    const endHeap = new BinaryHeap((node) => node.__endRealPlusEstimatedCost ?? 0);
    const endTag = Math.random();
    let endBest = endTile;
    endHeap.push(endTile);
    endTile.__endTag = endTag;
    endTile.__endRealCostFromOrigin = h11(endReal, endTile);
    endTile.__endEstimatedCostRemaining = h11(endTile, startReal);
    endTile.__endRealPlusEstimatedCost = endTile.__endEstimatedCostRemaining + endTile.__endRealCostFromOrigin;
    endTile.__endVisited = false;
    endTile.__endClosed = false;
    endTile.__endParent = null;
    let checksSinceBestChange = 0;
    while (startHeap.length) {
      if (checksSinceBestChange++ > 2500)
        break;
      const startCurrent2 = startHeap.pop();
      if (startCurrent2 === endTile) {
        startBest = endTile;
        break;
      } else if (startCurrent2.__endTag === endTag) {
        startBest = endBest = startCurrent2;
        break;
      }
      startCurrent2.__startClosed = true;
      const startNeighbors = startCurrent2.nodes;
      for (let i3 = 0, length = startNeighbors.length; i3 < length; i3++) {
        const neighbor = startNeighbors[i3];
        if (neighbor.__startTag !== startTag) {
          neighbor.__startTag = startTag;
          neighbor.__startEstimatedCostRemaining = 0;
          neighbor.__startRealPlusEstimatedCost = 0;
          neighbor.__startRealCostFromOrigin = 0;
          neighbor.__startVisited = false;
          neighbor.__startClosed = false;
          neighbor.__startParent = null;
        }
        const wasVisited = neighbor.__startVisited;
        if (!wasVisited) {
          if (neighbor.__startClosed || !neighbor.pathable(pathing))
            continue;
          else if (!cache._pathable(minimalTilemap, neighbor.x, neighbor.y)) {
            neighbor.__startClosed = true;
            continue;
          }
        }
        const gScore = (startCurrent2.__startRealCostFromOrigin ?? 0) + 1;
        if (startCurrent2.__startParent && cache._linearPathable(entity, startCurrent2.__startParent, neighbor)) {
          const gScore2 = (startCurrent2.__startParent.__startRealCostFromOrigin ?? 0) + h11(startCurrent2.__startParent, neighbor);
          if (!neighbor.__startVisited || gScore2 < (neighbor.__startRealCostFromOrigin ?? 0)) {
            neighbor.__startVisited = true;
            neighbor.__startParent = startCurrent2.__startParent;
            neighbor.__startEstimatedCostRemaining = neighbor.__startEstimatedCostRemaining || h11(neighbor, endReal);
            neighbor.__startRealCostFromOrigin = gScore2;
            neighbor.__startRealPlusEstimatedCost = neighbor.__startRealCostFromOrigin + neighbor.__startEstimatedCostRemaining;
            if (neighbor.__startEstimatedCostRemaining < (startBest.__startEstimatedCostRemaining ?? 0) || neighbor.__startEstimatedCostRemaining === startBest.__startEstimatedCostRemaining && neighbor.__startRealCostFromOrigin < (startBest.__startRealCostFromOrigin ?? 0)) {
              startBest = neighbor;
              checksSinceBestChange = 0;
            }
            if (!wasVisited)
              startHeap.push(neighbor);
            else {
              const index = startHeap.indexOf(neighbor);
              if (index >= 0)
                startHeap.sinkDown(index);
            }
          }
        } else if (!neighbor.__startVisited || gScore < (neighbor.__startRealCostFromOrigin ?? 0)) {
          neighbor.__startVisited = true;
          neighbor.__startParent = startCurrent2;
          neighbor.__startEstimatedCostRemaining = neighbor.__startEstimatedCostRemaining || h11(neighbor, endReal);
          neighbor.__startRealCostFromOrigin = gScore;
          neighbor.__startRealPlusEstimatedCost = neighbor.__startRealCostFromOrigin + neighbor.__startEstimatedCostRemaining;
          if (neighbor.__startEstimatedCostRemaining < (startBest.__startEstimatedCostRemaining ?? 0) || neighbor.__startEstimatedCostRemaining === startBest.__startEstimatedCostRemaining && neighbor.__startRealCostFromOrigin < (startBest.__startRealCostFromOrigin ?? 0)) {
            startBest = neighbor;
            checksSinceBestChange = 0;
          }
          if (!wasVisited)
            startHeap.push(neighbor);
          else {
            const index = startHeap.indexOf(neighbor);
            if (index >= 0)
              startHeap.sinkDown(index);
          }
        }
      }
      if (!endHeap.length) {
        const {x: x3, y: y3} = this.nearestPathing(target2.x, target2.y, entity, (tile) => tile.__endTag !== endTag);
        const newEndtile = this.grid[Math.round((y3 - offset22) * this.resolution)][Math.round((x3 - offset22) * this.resolution)];
        endBest = newEndtile;
        endHeap.push(newEndtile);
        newEndtile.__endTag = endTag;
        newEndtile.__endRealCostFromOrigin = h11(endReal, newEndtile);
        newEndtile.__endEstimatedCostRemaining = h11(newEndtile, startReal);
        newEndtile.__endRealPlusEstimatedCost = newEndtile.__endEstimatedCostRemaining + newEndtile.__endRealCostFromOrigin;
        newEndtile.__endVisited = false;
        newEndtile.__endClosed = false;
        newEndtile.__endParent = null;
      }
      const endCurrent = endHeap.pop();
      if (endCurrent === startTile) {
        endBest = startTile;
        break;
      } else if (endCurrent.__startTag === startTag) {
        startBest = endBest = endCurrent;
        break;
      }
      endCurrent.__endClosed = true;
      const endNeighbors = endCurrent.nodes;
      for (let i3 = 0, length = endNeighbors.length; i3 < length; i3++) {
        const neighbor = endNeighbors[i3];
        if (neighbor.__endTag !== endTag) {
          neighbor.__endTag = endTag;
          neighbor.__endEstimatedCostRemaining = 0;
          neighbor.__endRealPlusEstimatedCost = 0;
          neighbor.__endRealCostFromOrigin = 0;
          neighbor.__endVisited = false;
          neighbor.__endClosed = false;
          neighbor.__endParent = null;
        }
        const wasVisited = neighbor.__endVisited;
        if (!wasVisited) {
          if (neighbor.__endClosed || !neighbor.pathable(pathing))
            continue;
          else if (!cache._pathable(minimalTilemap, neighbor.x, neighbor.y)) {
            neighbor.__endClosed = true;
            continue;
          }
        }
        const gScore = (endCurrent.__endRealCostFromOrigin ?? 0) + 1;
        if (endCurrent.__endParent && cache._linearPathable(entity, endCurrent.__endParent, neighbor)) {
          const gScore2 = (endCurrent.__endParent.__endRealCostFromOrigin ?? 0) + h11(endCurrent.__endParent, neighbor);
          if (!neighbor.__endVisited || gScore2 < (neighbor.__endRealCostFromOrigin ?? 0)) {
            neighbor.__endVisited = true;
            neighbor.__endParent = endCurrent.__endParent;
            neighbor.__endEstimatedCostRemaining = neighbor.__endEstimatedCostRemaining || h11(neighbor, startReal);
            neighbor.__endRealCostFromOrigin = gScore2;
            neighbor.__endRealPlusEstimatedCost = neighbor.__endRealCostFromOrigin + neighbor.__endEstimatedCostRemaining;
            if (neighbor.__endEstimatedCostRemaining < (endBest.__endEstimatedCostRemaining ?? 0) || neighbor.__endEstimatedCostRemaining === endBest.__endEstimatedCostRemaining && neighbor.__endRealCostFromOrigin < (endBest.__endRealCostFromOrigin ?? 0)) {
              endBest = neighbor;
              checksSinceBestChange = 0;
            }
            if (!wasVisited)
              endHeap.push(neighbor);
            else {
              const index = endHeap.indexOf(neighbor);
              if (index >= 0)
                endHeap.sinkDown(index);
            }
          }
        } else if (!neighbor.__endVisited || gScore < (neighbor.__endRealCostFromOrigin ?? 0)) {
          neighbor.__endVisited = true;
          neighbor.__endParent = endCurrent;
          neighbor.__endEstimatedCostRemaining = neighbor.__endEstimatedCostRemaining || h11(neighbor, startReal);
          neighbor.__endRealCostFromOrigin = gScore;
          neighbor.__endRealPlusEstimatedCost = neighbor.__endRealCostFromOrigin + neighbor.__endEstimatedCostRemaining;
          if (neighbor.__endEstimatedCostRemaining < (endBest.__endEstimatedCostRemaining ?? 0) || neighbor.__endEstimatedCostRemaining === endBest.__endEstimatedCostRemaining && neighbor.__endRealCostFromOrigin < (endBest.__endRealCostFromOrigin ?? 0)) {
            endBest = neighbor;
            checksSinceBestChange = 0;
          }
          if (!wasVisited)
            endHeap.push(neighbor);
          else {
            const index = endHeap.indexOf(neighbor);
            if (index >= 0)
              endHeap.sinkDown(index);
          }
        }
      }
    }
    const pathTiles = [];
    let startCurrent = startBest;
    while (startCurrent) {
      pathTiles.unshift(startCurrent);
      startCurrent = startCurrent.__startParent;
    }
    if (startBest === endBest) {
      let endCurrent = startBest.__endParent;
      while (endCurrent) {
        pathTiles.push(endCurrent);
        endCurrent = endCurrent.__endParent;
      }
    }
    this._smooth(entity, pathTiles, cache);
    const pathWorld = pathTiles.map((tile) => ({
      x: this.xTileToWorld(tile.x) + offset22,
      y: this.yTileToWorld(tile.y) + offset22
    }));
    const last = pathTiles[pathTiles.length - 1];
    const beginning = pathWorld.length > 1 && (pathWorld[0].x !== start.x || pathWorld[0].y !== start.y) ? this.linearPathable(entity, start, pathWorld[1]) ? [{x: start.x, y: start.y}] : [{x: start.x, y: start.y}, pathWorld[0]] : [pathWorld[0]];
    if (removed)
      this.addEntity(entity);
    const path = last !== targetTile ? [...beginning, ...pathWorld.slice(1)] : [
      ...beginning,
      ...pathWorld.slice(1),
      ...pathWorld[pathWorld.length - 1].x !== endReal.x / this.resolution || pathWorld[pathWorld.length - 1].y !== endReal.y / this.resolution ? [
        {
          x: endReal.x / this.resolution,
          y: endReal.y / this.resolution
        }
      ] : []
    ];
    return path;
  }
  recheck(path, entity, amount = Infinity, offset22 = 0) {
    const removed = this.entities.has(entity);
    if (removed)
      this.removeEntity(entity);
    let cur = 0;
    let distanceSquared = 0;
    const offsetSquared = offset22 ** 2;
    const amountSqaured = offsetSquared + amount ** 2;
    let segmentLength = (path[1].x - path[0].x) ** 2 + (path[1].y - path[0].y) ** 2;
    while (distanceSquared + segmentLength < offsetSquared && cur < path.length - 2) {
      distanceSquared += segmentLength;
      cur++;
      segmentLength = (path[cur + 1].x - path[cur].x) ** 2 + (path[cur + 1].y - path[cur].y) ** 2;
    }
    if (cur === path.length - 1)
      return this.pathable(entity, path[cur].x, path[cur].y);
    while (cur < path.length - 1 && distanceSquared < amountSqaured) {
      if (!this.linearPathable(entity, path[cur], path[cur + 1])) {
        if (removed)
          this.addEntity(entity);
        return false;
      }
      distanceSquared += (path[cur + 1].x - path[cur].x) ** 2 + (path[cur + 1].y - path[cur].y) ** 2;
      cur++;
    }
    if (removed)
      this.addEntity(entity);
    return true;
  }
  _smooth(entity, path, cache = this) {
    for (let skip = path.length - 1; skip > 1; skip--)
      for (let index = 0; index < path.length - skip; index++)
        if (cache._linearPathable(entity, path[index], path[index + skip])) {
          path.splice(index + 1, skip - 1);
          skip = path.length;
          break;
        }
  }
  _linearPathable(entity, startTile, endTile) {
    const radiusOffset = entity.collisionRadius % (1 / this.resolution);
    return this.linearPathable(entity, offset(startTile.world, radiusOffset), offset(endTile.world, radiusOffset));
  }
  entityToTileCoordsBounded(entity, position = pos(entity)) {
    const nudge3 = EPSILON * entity.collisionRadius * this.widthWorld;
    return {
      x: this.xBoundTile(Math.round(position.x * this.resolution - nudge3)),
      y: this.yBoundTile(Math.round(position.y * this.resolution - nudge3))
    };
  }
  entityToTile(entity, position = pos(entity)) {
    const {x: x3, y: y3} = this.entityToTileCoordsBounded(entity, position);
    return this.grid[y3][x3];
  }
  linearPathable(entity, startWorld, endWorld) {
    if (typeof entity.collisionRadius !== "number")
      throw new Error("Can only path find radial entities");
    const radius = entity.collisionRadius * this.resolution - EPSILON * entity.collisionRadius * this.widthWorld * this.resolution;
    const pathing = entity.requiresPathing !== void 0 ? entity.requiresPathing : entity.pathing;
    if (pathing === void 0)
      throw "entity has no pathing";
    [startWorld, endWorld] = startWorld.x <= endWorld.x ? [startWorld, endWorld] : [endWorld, startWorld];
    {
      const startTile = this.worldToTile(startWorld);
      const endTile = this.worldToTile(endWorld);
      if (startTile === endTile) {
        const map = entity.requiresTilemap ?? this.pointToTilemap(startWorld.x, startWorld.y, entity.collisionRadius, {
          type: pathing
        });
        return this.withoutEntity(entity, () => this._pathable(map, startTile.x, startTile.y));
      }
    }
    const startPoint = {
      x: startWorld.x * this.resolution,
      y: startWorld.y * this.resolution
    };
    const endPoint = {
      x: endWorld.x * this.resolution,
      y: endWorld.y * this.resolution
    };
    const angle = Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x);
    const tan = (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y);
    const positiveSlope = endPoint.y > startPoint.y;
    const minY = positiveSlope ? Math.floor(startPoint.y - radius) : Math.floor(endPoint.y - radius);
    const maxY = positiveSlope ? Math.floor(endPoint.y + radius) : Math.floor(startPoint.y + radius);
    const yStart = positiveSlope ? minY : maxY;
    const yStep = positiveSlope ? 1 : -1;
    const ySteps = Math.abs(minY - maxY);
    const minX = Math.floor(startPoint.x - radius);
    const maxX = Math.floor(endPoint.x + radius);
    const leftTangent = polarProject(startPoint, angle - Math.PI / 2, radius);
    const rightTangent = polarProject(startPoint, angle + Math.PI / 2, radius);
    const endLeftTangent = polarProject(endPoint, angle - Math.PI / 2, radius);
    const endRightTangent = polarProject(endPoint, angle + Math.PI / 2, radius);
    const startFloor = positiveSlope ? Math.floor(startPoint.y - radius) + 1 : Math.ceil(startPoint.y + radius) - 1;
    const rightGuide = {
      x: isFinite(tan) ? rightTangent.x + (startFloor - rightTangent.y) * tan : rightTangent.x - radius,
      y: startFloor
    };
    const leftGuide = {
      x: isFinite(tan) ? leftTangent.x - (leftTangent.y - startFloor) * tan : leftTangent.x - radius,
      y: startFloor
    };
    const guide = Math.max(rightGuide.x, leftGuide.x);
    const guideDistance = Math.abs(rightGuide.x - leftGuide.x);
    const absTan = Math.abs(tan);
    const totalShift = isFinite(absTan) ? absTan + guideDistance : guideDistance;
    let xStartRaw = guide - totalShift;
    for (let y3 = 0; y3 <= ySteps; y3++) {
      const xEndRaw = xStartRaw + (isFinite(absTan) ? totalShift : Infinity);
      const xStartTest = Math.floor(xStartRaw);
      const xEndTest = Math.floor(xEndRaw);
      const xStartMin = xStartRaw < startPoint.x && behind(leftTangent, rightTangent, xStartTest + 1, yStart + y3 * yStep) ? trueMinX(startPoint, radius, yStart + y3 * yStep, Math.max(xStartTest, minX)) : -Infinity;
      const xEndMin = xStartRaw < endPoint.x && infront(endLeftTangent, endRightTangent, xStartTest - 1, yStart + y3 * yStep) ? trueMinX(endPoint, radius, yStart + y3 * yStep, Math.max(xStartTest, minX)) : -Infinity;
      const xStart = Math.max(xStartMin, xEndMin, xStartTest, minX);
      const xStartMax = xEndRaw > startPoint.x && behind(leftTangent, rightTangent, xEndTest + 1, yStart + y3 * yStep) ? trueMaxX(startPoint, radius, yStart + y3 * yStep, Math.min(xEndTest, maxX)) : Infinity;
      const xEndMax = xEndRaw > endPoint.x && infront(endLeftTangent, endRightTangent, xEndTest - 1, yStart + y3 * yStep) ? trueMaxX(endPoint, radius, yStart + y3 * yStep, Math.min(xEndTest, maxX)) : Infinity;
      const xEnd = Math.min(xStartMax, xEndMax, xEndTest, maxX);
      for (let x3 = xStart; x3 <= xEnd; x3++)
        if (!this.grid[yStart + y3 * yStep]?.[x3]?.pathable(pathing))
          return false;
      xStartRaw += isFinite(absTan) ? absTan : 0;
    }
    return true;
  }
  addEntity(entity) {
    const tiles = [];
    const position = pos(entity);
    const {map, top, left, width, height} = entity.blocksTilemap ?? this.pointToTilemap(position.x, position.y, entity.collisionRadius, {
      type: entity.blocksPathing === void 0 ? entity.pathing : entity.blocksPathing
    });
    const tileX = this.xWorldToTile(position.x);
    const tileY = this.yWorldToTile(position.y);
    for (let y3 = top; y3 < top + height; y3++)
      for (let x3 = left; x3 < left + width; x3++) {
        tiles.push(this.grid[tileY + y3][tileX + x3]);
        this.grid[tileY + y3][tileX + x3].addEntity(entity, map[(y3 - top) * width + (x3 - left)]);
      }
    this.entities.set(entity, tiles);
  }
  updateEntity(entity) {
    if (!this.entities.has(entity))
      return;
    const oldTiles = this.entities.get(entity) ?? [];
    const newTiles = [];
    const position = pos(entity);
    const {map, top, left, width, height} = entity.blocksTilemap ?? this.pointToTilemap(position.x, position.y, entity.collisionRadius, {
      type: entity.blocksPathing === void 0 ? entity.pathing : entity.blocksPathing
    });
    const tileX = this.xWorldToTile(position.x);
    const tileY = this.yWorldToTile(position.y);
    for (let y3 = top; y3 < top + height; y3++)
      for (let x3 = left; x3 < left + width; x3++)
        newTiles.push(this.grid[tileY + y3][tileX + x3]);
    oldTiles.filter((t3) => !newTiles.includes(t3)).forEach((tile) => tile.removeEntity(entity));
    newTiles.forEach((tile, index) => {
      if (oldTiles.includes(tile))
        tile.updateEntity(entity, map[index]);
      else
        tile.addEntity(entity, map[index]);
    });
    this.entities.set(entity, newTiles);
  }
  removeEntity(entity) {
    const tiles = this.entities.get(entity);
    if (tiles)
      tiles.forEach((tile) => tile.removeEntity(entity));
    this.entities.delete(entity);
  }
}, "PathingMap");
__name2(PathingMap, "PathingMap");
var isPathingMapEntity = /* @__PURE__ */ __name2((entity) => {
  if (!("collisionRadius" in entity) || typeof entity.collisionRadius !== "number")
    return false;
  if (hasPositionProp(entity))
    return true;
  if (!("x" in entity) || typeof entity.x !== "number")
    return false;
  if (!("y" in entity) || typeof entity.y !== "number")
    return false;
  return true;
}, "isPathingMapEntity");
var PathingSystem = /* @__PURE__ */ __name(class extends System {
  constructor(terrain2) {
    super();
    this.pure = true;
    this.componentMap = new Map();
    this.pathingMap = new PathingMap(terrain2);
    this.widthWorld = this.pathingMap.widthWorld;
    this.heightWorld = this.pathingMap.heightWorld;
    this.layer = this.pathingMap.layer.bind(this.pathingMap);
    this.grid = this.pathingMap.grid;
  }
  test(entity) {
    return Position.has(entity) && PathingComponent.has(entity);
  }
  onAddEntity(entity) {
    let sprite;
    if (isSprite(entity))
      sprite = entity;
    let obstruction;
    if (isObstruction(entity))
      obstruction = entity;
    const pathingEntity = entity.get(PathingEntity)[0] ?? new PathingEntity(entity, {
      collisionRadius: sprite?.collisionRadius ?? 0,
      blocksPathing: sprite?.blocksPathing ?? 0,
      blocksTilemap: obstruction?.blocksTilemap,
      requiresPathing: sprite?.requiresPathing ?? 0,
      requiresTilemap: obstruction?.requiresTilemap,
      structure: obstruction?.structure ?? false,
      x: () => entity.get(Position)[0].x,
      y: () => entity.get(Position)[0].y
    });
    this.componentMap.set(entity, pathingEntity);
    this.pathingMap.addEntity(pathingEntity);
  }
  getPathingMapEntity(entity, requirePathingEntity = true) {
    const pathingEntity = entity instanceof Entity ? entity.get(PathingEntity)[0] ?? this.componentMap.get(entity) : void 0;
    if (pathingEntity)
      return pathingEntity;
    if (requirePathingEntity)
      throw new Error("Expected an entity with a PathingEntity component");
    if (isPathingMapEntity(entity))
      return entity;
    throw new Error("Expected an entity with a PathingEntity component or to be a PathingMapEntity");
  }
  onRemoveEntity(entity) {
    const pathingEntities = entity.get(PathingEntity);
    for (const pathingEntity2 of pathingEntities) {
      if (!pathingEntity2)
        continue;
      this.pathingMap.removeEntity(pathingEntity2);
    }
    const pathingEntity = this.componentMap.get(entity);
    if (pathingEntity)
      this.pathingMap.removeEntity(pathingEntity);
    this.componentMap.delete(entity);
  }
  pathable(entity, x3, y3) {
    return this.pathingMap.pathable(this.getPathingMapEntity(entity, false), x3, y3);
  }
  nearestSpiralPathing(xWorld, yWorld, entity, layer) {
    return this.pathingMap.nearestSpiralPathing(xWorld, yWorld, this.getPathingMapEntity(entity, false), layer);
  }
  path(entity, target2, start) {
    return this.pathingMap.path(this.getPathingMapEntity(entity, false), target2, start);
  }
  withoutEntity(entity, fn) {
    return this.pathingMap.withoutEntity(this.getPathingMapEntity(entity), fn);
  }
  recheck(path, entity, amount = Infinity, offset22 = 0) {
    return this.pathingMap.recheck(path, this.getPathingMapEntity(entity), amount, offset22);
  }
}, "PathingSystem");
PathingSystem.components = [Position, PathingComponent];
__name2(PathingSystem, "PathingSystem");

// src/typeguards.ts
var isMazingContest = /* @__PURE__ */ __name((obj) => "isMazingContest" in obj.constructor, "isMazingContest");
var isThunder = /* @__PURE__ */ __name((obj) => "isThunder" in obj, "isThunder");
var isRunner = /* @__PURE__ */ __name((obj) => "isRunner" in obj, "isRunner");
var isCheckpoint = /* @__PURE__ */ __name((obj) => "isCheckpoint" in obj || "isCheckpoint" in obj.constructor, "isCheckpoint");
var isBuilder = /* @__PURE__ */ __name((obj) => "isBuilder" in obj, "isBuilder");

// src/mazingContestContext.ts
var withMazingContest = /* @__PURE__ */ __name((MazingContest2, fn) => withApp(MazingContest2, fn), "withMazingContest");
var currentMazingContest = /* @__PURE__ */ __name(() => {
  const app = currentApp();
  if (!isMazingContest(app))
    throw new Error("Expected a MazingContest context");
  return app;
}, "currentMazingContest");

// src/actions/ready.ts
var readyAction = {
  name: "Ready",
  hotkey: "r",
  type: "custom",
  localHandler: ({player}) => {
    if (player.ready)
      return;
    currentMazingContest().transmit({type: "ready"});
  },
  syncHandler: ({time, connection}) => {
    const mazingContest = currentMazingContest();
    mazingContest.update({time});
    const player = mazingContest.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    if (player.ready)
      return;
    player.ready = true;
    if (mazingContest.players.every((p3) => p3.id < 0 || p3.ready))
      mazingContest.mainLogic.startRunners();
  }
};

// src/actions/selfDestruct.ts
var selfDestructAction = {
  name: "Destroy box",
  description: "Destroys selected boxes",
  hotkey: "x",
  type: "custom",
  localHandler: ({player}) => {
    let tnt = player.resources.tnt ?? 0;
    const obstructions = player.game.selectionSystem.selection.filter((s3) => isObstruction(s3) && (s3.owner === player || tnt-- > 0));
    const builder = player.sprites.find((s3) => isBuilder(s3));
    if (builder)
      player.game.selectionSystem.setSelection([builder]);
    player.game.transmit({
      type: "selfDestruct",
      sprites: obstructions.map((u3) => u3.id)
    });
  },
  syncHandler: ({time, sprites, connection}) => {
    const mazingContest = currentMazingContest();
    mazingContest.update({time});
    if (mazingContest.mainLogic.round?.runnerStart)
      return;
    const player = mazingContest.players.find((p3) => p3.id === connection);
    if (!player)
      return;
    mazingContest.entities.filter((s3) => isSprite(s3) && sprites.includes(s3.id)).forEach((s3) => {
      if (s3.owner !== player) {
        const check = player.checkResources({tnt: 1});
        if (check?.length) {
          appendErrorMessage(`Not enough ${check.join(" ")}`);
          return;
        }
        player.subtractResources({tnt: 1});
      }
      s3.kill();
      if (s3.owner !== player)
        return;
      s3.owner.resources.lumber = (s3.owner.resources.lumber ?? 0) + 1;
      if (isThunder(s3))
        s3.owner.resources.gold = (s3.owner.resources.gold ?? 0) + 1;
    });
  },
  available: () => (currentMazingContest().localPlayer.resources.tnt ?? 0) > 0
};

// src/actions/index.ts
var registerNetworkedActionListeners = /* @__PURE__ */ __name(() => {
  const MazingContest2 = currentMazingContest();
  MazingContest2.addNetworkListener("selfDestruct", selfDestructAction.syncHandler);
  MazingContest2.addNetworkListener("ready", readyAction.syncHandler);
}, "registerNetworkedActionListeners");

// src/components/ForPlayer.ts
var ForPlayer = class extends Component {
  initialize(player) {
    const mutable = this;
    mutable.player = player;
  }
  toJSON() {
    return {type: this.constructor.name, player: this.player.id};
  }
  static fromJSON(entity, {player}) {
    const mazingContest = currentMazingContest();
    return new ForPlayer(entity, mazingContest.players.find((p3) => p3.id === player));
  }
};
__name(ForPlayer, "ForPlayer");

// src/components/IsDone.ts
var IsDone = class extends Component {
  initialize(time) {
    const mutable = this;
    mutable.time = time;
  }
};
IsDone.argMap = ["time"];
__name(IsDone, "IsDone");

// src/components/MainLogictimerHook.ts
var MainLogicTimerHook = class extends Component {
  initialize() {
    currentMazingContest().mainLogic.timer = this.entity;
  }
};
__name(MainLogicTimerHook, "MainLogicTimerHook");

// src/players/Player.ts
var Player2 = class extends Player {
  constructor() {
    super(...arguments);
    this.ready = false;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      resources: this.resources
    };
  }
};
__name(Player2, "Player");
var patchInState = /* @__PURE__ */ __name((game, playersState) => {
  playersState.forEach(({color, id, ...playerData}) => {
    const player = game.players.find((p3) => p3.id === id) ?? new Player2({...playerData, id, game});
    if (color !== void 0 && (!player.color || player.color.index !== color)) {
      if (player.color)
        releaseColor(player.color);
      player.color = takeColor(color);
    }
    player.resources = playerData.resources;
  });
  game.players.sort((a3, b3) => a3.id - b3.id);
}, "patchInState");

// src/players/placeholder.ts
var getAlliedPlaceholderPlayer = /* @__PURE__ */ __name(() => {
  const game = currentMazingContest();
  return game.players.find((p3) => p3.id === -1) ?? new Player2({color: colors.white, id: -1, game});
}, "getAlliedPlaceholderPlayer");
var getEnemyPlaceholderPlayer = /* @__PURE__ */ __name(() => {
  const game = currentMazingContest();
  return game.players.find((p3) => p3.id === -2) ?? new Player2({color: colors.black, id: -2, game});
}, "getEnemyPlaceholderPlayer");

// src/terrain.ts
var repeat = /* @__PURE__ */ __name((map) => {
  const h = trimMap(map).split("\n").map((v3) => Array(5).fill(v3).join("."));
  return Array(4).fill(h.join("\n")).join(`
${".".repeat(h[0].length)}
`);
}, "repeat");
var terrain = processArena({
  name: "Mazing Contest",
  cliffs: stringMapWithRamps(repeat(`
			000000000000000000
			000000000000000000
			000000000000000000
			000222221122222000
			000211111111112000
			00021        12000
			00021        12000
			00021        12000
			00021        12000
			00021        12000
			00021        12000
			00021        12000
			00021        12000
			000211111111112000
			000222221122222000
			000000000000000000
			000000000000000000
			000000000000000000
		`), 1),
  tiles: stringMap2(repeat(`
			000000000000000000
			0                0
			0                0
			0       11       0
			0                0
			0                0
			0                0
			0                0
			0                0
			0                0
			0                0
			0                0
			0                0
			0                0
			0       11       0
			0                0
			0                0
			000000000000000000
		`))
});
var offsetMultiples = [
  {x: 0, y: 0},
  {x: 1, y: 0},
  {x: 0, y: 1},
  {x: 1, y: 1},
  {x: 2, y: 0},
  {x: 0, y: 2},
  {x: 2, y: 1},
  {x: 1, y: 2},
  {x: 2, y: 2},
  {x: 3, y: 0},
  {x: 0, y: 3},
  {x: 3, y: 1},
  {x: 1, y: 3},
  {x: 3, y: 2},
  {x: 2, y: 3},
  {x: 3, y: 3},
  {x: 4, y: 0},
  {x: 4, y: 1},
  {x: 4, y: 2},
  {x: 4, y: 3}
];
var levelSize = {width: 36, height: 36};
var offset2 = /* @__PURE__ */ __name((i3) => ({
  x: offsetMultiples[i3].x * (levelSize.width + 2),
  y: offsetMultiples[i3].y * (levelSize.height + 2)
}), "offset");
var center = /* @__PURE__ */ __name((i3) => {
  const lOffset = offset2(i3);
  return {
    x: lOffset.x + levelSize.width / 2,
    y: lOffset.y + levelSize.height / 2
  };
}, "center");
var spawn = /* @__PURE__ */ __name((i3) => {
  const lCenter = center(i3);
  return {
    x: lCenter.x,
    y: lCenter.y - 10.5
  };
}, "spawn");
var target = /* @__PURE__ */ __name((i3) => {
  const lCenter = center(i3);
  return {
    x: lCenter.x,
    y: lCenter.y + 10.5
  };
}, "target");

// src/helpers.ts
var spawnEntity = {
  collisionRadius: 0.5,
  pathing: PATHING_TYPES.WALKABLE
};
var isPathable = /* @__PURE__ */ __name((i3) => {
  const game = currentMazingContest();
  const finalSpawnEntity = {...spawnEntity, ...spawn(i3)};
  const lTarget = target(i3);
  const checkpoint = getCheckpoint(i3);
  if (!checkpoint)
    return false;
  const checkpointPosition = {
    x: checkpoint.position.x,
    y: checkpoint.position.y
  };
  const path = game.pathingSystem.path(finalSpawnEntity, checkpointPosition);
  const last = path[path.length - 1];
  if (Math.abs(last.x - checkpointPosition.x) > 0.1 || Math.abs(last.y - checkpointPosition.y) > 0.1)
    return false;
  const path2 = game.pathingSystem.path({...spawnEntity, ...spawn(i3)}, lTarget, checkpoint.position);
  const last2 = path2[path2.length - 1];
  return Math.abs(last2.x - lTarget.x) < 0.1 && Math.abs(last2.y - lTarget.y) < 0.1;
}, "isPathable");
var getCheckpoint = /* @__PURE__ */ __name((i3) => getAlliedPlaceholderPlayer().sprites.find((s3) => isCheckpoint(s3) && s3.get(ForPlayer)[0]?.player?.color?.index === i3), "getCheckpoint");
var isConstructor = /* @__PURE__ */ __name((obj) => typeof obj === "function" && !!obj.prototype.constructor.name, "isConstructor");

// src/entities/registry.ts
var _entityRegistry = {};
var entityRegistry = _entityRegistry;
var registerEntity = /* @__PURE__ */ __name((factory, name) => {
  if (!name) {
    if (isConstructor(factory))
      name = factory.name;
  }
  if (!name)
    throw new Error("Expected a name with factory");
  _entityRegistry[name] = factory;
}, "registerEntity");

// src/entities/Obstruction.ts
var Obstruction2 = class extends Obstruction {
  get actions() {
    const mazingContest = currentMazingContest();
    if (mazingContest.mainLogic.round?.runnerStart)
      return [];
    const actions = super.actions;
    actions.push(this.owner === mazingContest.localPlayer ? selfDestructAction : {...selfDestructAction, cost: {tnt: 1}});
    return actions;
  }
};
__name(Obstruction2, "Obstruction");

// src/entities/Thunder.ts
var black = new Color("#000");
var thunderTimeout = /* @__PURE__ */ __name((target2) => currentMazingContest().setTimeout(() => {
  const effectIndex = target2.effects.findIndex((e3) => e3.type === "slow");
  const effect = target2.effects[effectIndex];
  if (isUnit(target2))
    target2.speed = effect.oldSpeed;
  target2.effects.splice(effectIndex, 1);
}, 5), "thunderTimeout");
var _Thunder = class extends Obstruction2 {
  constructor(props) {
    super({..._Thunder.clonedDefaults, ...props});
    this.isThunder = true;
  }
};
var Thunder = _Thunder;
Thunder.defaults = {
  ...Obstruction2.defaults,
  buildHotkey: "n",
  cost: {gold: 1, lumber: 1},
  meshBuilder: {
    ...Obstruction2.defaults.meshBuilder,
    colorFilter: (color) => color.lerp(black, 0.75)
  },
  autoAttack: true,
  weapon: {
    enabled: true,
    damage: 0,
    cooldown: 5,
    last: 0,
    range: 2.5,
    projectile: "instant",
    onDamage: (target2) => {
      if (!isUnit(target2))
        return;
      const existingEffect = target2.effects.find((e3) => e3.type === "slow");
      if (existingEffect) {
        currentMazingContest().clearTimeout(existingEffect.timeout);
        existingEffect.timeout = thunderTimeout(target2);
        return;
      }
      const effect = {
        type: "slow",
        oldSpeed: target2.speed,
        timeout: thunderTimeout(target2)
      };
      target2.speed = target2.speed * 0.6;
      target2.effects.push(effect);
    }
  }
};
__name(Thunder, "Thunder");
registerEntity(Thunder);

// src/entities/Block.ts
var _Block = class extends Obstruction2 {
  constructor(props) {
    super({..._Block.clonedDefaults, ...props});
  }
};
var Block = _Block;
Block.defaults = {
  ...Obstruction2.defaults,
  buildHotkey: "b",
  cost: {lumber: 1},
  upgradesTo: [Thunder]
};
__name(Block, "Block");
registerEntity(Block);

// src/actions/destroyLast.ts
var destroyLast = {
  name: "Destroy last",
  description: "Destroys last created obstruction",
  hotkey: "x",
  type: "custom",
  localHandler: ({player}) => {
    const unit = player.getPrimarySelectedUnit();
    if (!unit)
      return;
    const obstructions = [...unit.obstructions];
    while (obstructions.length) {
      const obstruction = obstructions.pop();
      if (obstruction && obstruction.isAlive) {
        player.game.transmit({
          type: "selfDestruct",
          sprites: [obstruction.id]
        });
        break;
      }
    }
  }
};

// src/entities/Builder.ts
var _Builder = class extends Unit {
  constructor(props) {
    super({..._Builder.clonedDefaults, ...props});
    this.isBuilder = true;
  }
  get actions() {
    const actions = super.actions.filter((a3) => a3.name !== "Hold Position" && a3.name !== "Stop");
    actions.push(destroyLast);
    actions.push(readyAction);
    return actions;
  }
};
var Builder2 = _Builder;
Builder2.defaults = {
  ...Unit.defaults,
  builds: [Block, Thunder],
  collisionRadius: 0.5,
  requiresPathing: 0,
  blocksPathing: 0,
  speed: 25,
  zOffset: 2
};
__name(Builder2, "Builder");
registerEntity(Builder2);

// src/entities/Checkpoint.ts
var _Checkpoint = class extends Obstruction2 {
  constructor(props) {
    super({..._Checkpoint.clonedDefaults, ...props});
    this.isCheckpoint = true;
  }
};
var Checkpoint = _Checkpoint;
Checkpoint.defaults = {
  ...Obstruction2.defaults,
  collisionRadius: 0.5,
  blocksPathing: PATHING_TYPES.BUILDABLE,
  meshBuilder: {
    ...Obstruction2.defaults.meshBuilder,
    mutator: (mesh) => {
      mesh.scale.z = 0.25;
    }
  }
};
__name(Checkpoint, "Checkpoint");
registerEntity(Checkpoint);

// src/entities/Runner.ts
var _Runner = class extends Unit {
  constructor(props) {
    super({..._Runner.clonedDefaults, ...props});
    this.isRunner = true;
    new Component(this);
  }
};
var Runner = _Runner;
Runner.defaults = {
  ...Unit.defaults,
  collisionRadius: 0.5,
  speed: 4
};
__name(Runner, "Runner");

// src/mechanisms/MainLogic.ts
var spawnCheckpoint = /* @__PURE__ */ __name((game) => {
  const firstPlayer = game.players.find((p3) => p3.id >= 0);
  const firstPlayerIndex = firstPlayer.color.index;
  const lCenter = center(firstPlayerIndex);
  const x3 = lCenter.x + Math.round(game.random.between(-9, 8)) + 0.5;
  const y3 = lCenter.y + Math.round(game.random.between(-9, 8)) + 0.5;
  const entity = new Checkpoint({
    x: x3,
    y: y3,
    owner: getAlliedPlaceholderPlayer()
  });
  new ForPlayer(entity, firstPlayer);
  const newPos = game.pathingSystem.nearestSpiralPathing(x3, y3, entity);
  if (game.pathingSystem.pathable(entity, x3, y3)) {
    entity.position.setXY(newPos.x, newPos.y);
    new PathingComponent(entity);
    for (const player of game.players) {
      if (player.id <= firstPlayer.id)
        continue;
      const lOffset = offset2(player.color.index);
      const clone2 = new Checkpoint({
        x: newPos.x + lOffset.x,
        y: newPos.y + lOffset.y,
        owner: entity.owner
      });
      new ForPlayer(clone2, player);
      new PathingComponent(clone2);
    }
  } else
    throw new Error("Unable to place Checkpooint!");
}, "spawnCheckpoint");
var spawnUnits = /* @__PURE__ */ __name((game, count, factory) => {
  const firstPlayer = game.players.find((p3) => p3.id >= 0);
  const firstPlayerIndex = firstPlayer.color.index;
  const lCenter = center(firstPlayerIndex);
  while (count--) {
    const x3 = lCenter.x + Math.round(game.random.between(-9, 8));
    const y3 = lCenter.y + Math.round(game.random.between(-9, 8));
    const entity = factory({
      x: x3,
      y: y3,
      owner: getAlliedPlaceholderPlayer()
    });
    const newPos = game.pathingSystem.nearestSpiralPathing(x3, y3, entity);
    if (game.pathingSystem.pathable(entity, newPos.x, newPos.y)) {
      entity.position.setXY(newPos.x, newPos.y);
      new PathingComponent(entity);
      if (!isPathable(firstPlayerIndex))
        entity.remove();
      else {
        new ForPlayer(entity, firstPlayer);
        for (const player of game.players) {
          if (player.id <= firstPlayer.id)
            continue;
          const lOffset = offset2(player.color.index);
          const clone2 = factory({
            x: newPos.x + lOffset.x,
            y: newPos.y + lOffset.y,
            owner: getAlliedPlaceholderPlayer()
          });
          new ForPlayer(clone2, player);
          new PathingComponent(clone2);
        }
      }
    } else
      entity.remove();
  }
}, "spawnUnits");
var spawnBlocks = /* @__PURE__ */ __name((game) => {
  const count = Math.floor(game.random() * game.random() * 25);
  spawnUnits(game, count, (props) => new Block(props));
}, "spawnBlocks");
var spawnThunders = /* @__PURE__ */ __name((game) => {
  const count = Math.floor(game.random() * game.random() * 4);
  spawnUnits(game, count, (props) => new Thunder(props));
}, "spawnThunders");
var derivedCallback = /* @__PURE__ */ __name(() => {
  const mazingContest = currentMazingContest();
  return () => mazingContest.mainLogic.startRunners();
}, "derivedCallback");
var MainLogic = class extends Mechanism {
  constructor() {
    super();
    this.phase = "idle";
    this.derivedCallback = Timer.registerDerviedCallback(derivedCallback);
  }
  startRunners() {
    if (!this.timer || !this.round)
      return;
    const game = currentMazingContest();
    logLine("startRunners", game.time);
    game.remove(this.timer);
    this.round.runnerStart = game.time;
    game.players.forEach((p3) => {
      if (p3.id < 0)
        return;
      const builder = p3.sprites.find((s3) => s3 instanceof Builder2);
      if (builder)
        builder.kill();
    });
    for (const player of game.players) {
      if (!this.round.players.includes(player.id))
        continue;
      const u3 = new Runner({
        ...spawn(player.color.index),
        owner: getEnemyPlaceholderPlayer()
      });
      new ForPlayer(u3, player);
      new PathingComponent(u3);
      let lTarget = target(player.color.index);
      const checkpoint = getCheckpoint(player.color.index);
      if (checkpoint)
        lTarget = {
          x: checkpoint.position.x,
          y: checkpoint.position.y
        };
      u3.walkTo(lTarget);
    }
  }
  startRound(time, game) {
    logLine("startRound", time);
    this.round = {
      buildStart: time,
      players: game.players.map((p3) => p3.id).filter((v3) => v3 >= 0)
    };
    const gold = Math.floor((game.random() * game.random()) ** (1 / 2) * 4);
    const lumber = Math.ceil((game.random() * game.random()) ** (1 / 2) * 35);
    const tnt = Math.floor((game.random() * game.random()) ** (1 / 2) * 3);
    const alliedPlaceholderPlayer = getAlliedPlaceholderPlayer();
    const enemyPlaceholderPlayer = getEnemyPlaceholderPlayer();
    game.alliances.set(alliedPlaceholderPlayer, enemyPlaceholderPlayer, "enemy", true);
    for (const owner of game.players) {
      if (owner.id < 0)
        continue;
      owner.ready = false;
      owner.resources.gold = gold;
      owner.resources.lumber = lumber;
      owner.resources.tnt = tnt;
      game.alliances.set(owner, alliedPlaceholderPlayer, "ally", true);
      game.alliances.set(owner, enemyPlaceholderPlayer, "enemy", true);
      const u3 = new Builder2({
        ...center(owner.color.index),
        owner
      });
      new PathingComponent(u3);
      if (owner === game.localPlayer) {
        game.selectionSystem.select(u3);
        game.graphics.panTo(u3.position, 0);
      }
    }
    spawnCheckpoint(game);
    spawnBlocks(game);
    spawnThunders(game);
    this.timer = new Entity();
    new Timer(this.timer, derivedCallback(), 30, false, true, void 0, this.derivedCallback);
    new TimerWindow(this.timer, "Time remaining: ");
    new MainLogicTimerHook(this.timer);
    game.add(this.timer);
  }
  endRound(game) {
    if (!this.round)
      return;
    if (this.round.runnerStart)
      logLine("endRound", game.time - this.round.runnerStart, game.entities.filter((e3) => isRunner(e3)).map((e3) => e3.get(IsDone)[0].time - this.round.runnerStart));
    this.round = void 0;
    game.entities.forEach((v3) => isUnit(v3) && v3.kill());
  }
  update(delta, time) {
    const game = currentMazingContest();
    if (this.round?.runnerStart && game.runnerTracker.done)
      this.endRound(game);
    if (!this.round && game.players.some((p3) => p3.id >= 0))
      this.startRound(time, game);
  }
};
__name(MainLogic, "MainLogic");

// src/systems/BuildWatcher.ts
var BuildWatcher = class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return isObstruction(entity) && !isCheckpoint(entity);
  }
  onAddEntity(obstruction) {
    currentMazingContest().setTimeout(() => {
      if (isCheckpoint(obstruction) || !obstruction.isAlive)
        return;
      const pId = obstruction.owner.id >= 0 ? obstruction.owner.color.index : obstruction.get(ForPlayer)[0]?.player.color.index;
      if (pId === void 0)
        throw new Error("Expected obstruction to be a real player or have a ForPlayer");
      if (isPathable(pId))
        return;
      obstruction.kill();
      obstruction.owner.resources.lumber = (obstruction.owner.resources.lumber ?? 0) + 1;
      if (isThunder(obstruction))
        obstruction.owner.resources.gold = (obstruction.owner.resources.gold ?? 0) + 1;
    });
  }
};
BuildWatcher.components = [];
__name(BuildWatcher, "BuildWatcher");

// src/components/HitCheckpoint.ts
var HasHitCheckpoint = class extends Component {
};
__name(HasHitCheckpoint, "HasHitCheckpoint");

// src/systems/RunnerTracker.ts
var RunnerTracker = class extends System {
  constructor() {
    super(...arguments);
    this.pure = true;
  }
  test(entity) {
    return isRunner(entity);
  }
  modified(entity) {
    if (!entity.idle || entity.has(HasHitCheckpoint))
      return;
    new HasHitCheckpoint(entity);
    const pIdx = entity.get(ForPlayer)[0]?.player.color?.index;
    if (pIdx !== void 0)
      entity.walkTo(target(pIdx));
  }
  get done() {
    let done = true;
    for (const runner of this)
      if (runner.idle && runner.has(HasHitCheckpoint)) {
        if (!runner.has(IsDone))
          new IsDone(runner, currentMazingContest().time);
      } else
        done = false;
    return done;
  }
};
RunnerTracker.components = [MoveTarget];
__name(RunnerTracker, "RunnerTracker");

// src/MazingContest.ts
var MazingContest = class extends Game2 {
  constructor(network) {
    super(network);
    this.players = [];
    this.onInit = ({
      connections,
      state: {round, entityId, players, entities, alliances}
    }) => {
      if (connections === 0)
        this.synchronizationState = "synchronized";
      this.mainLogic.round = round;
      this.entityId = entityId;
      patchInState(this, players);
      getAlliedPlaceholderPlayer();
      getEnemyPlaceholderPlayer();
      this.alliances.fromJSON(alliances);
      for (const entity of entities) {
        if (entity.id === "TERRAIN")
          continue;
        if (typeof entity.type === "string") {
          const factory = entityRegistry[entity.type];
          if (!factory)
            continue;
          if (isConstructor(factory)) {
            if ("fromJSON" in factory)
              if (typeof factory.fromJSON === "function")
                factory.fromJSON(entity);
              else
                new factory(entity);
          } else
            factory(entity);
        } else
          this.add(Entity.fromJSON(entity));
      }
    };
    this.onState = ({
      time,
      state: {players}
    }) => {
      this.update({time});
      patchInState(this, players);
      logLine("synchronized");
      this.synchronizationState = "synchronized";
    };
    logLine("Creating MazingContest");
    withMazingContest(this, () => {
      this.addNetworkListener("init", (e3) => this.onInit(e3));
      this.addNetworkListener("state", (e3) => this.onState(e3));
      this.terrain = new Terrain2(terrain);
      this.add(this.terrain);
      this.graphics.panTo({x: levelSize.height / 2, y: levelSize.width / 2 - 7}, 0);
      this.pathingSystem = new PathingSystem({
        pathing: terrain.pathing,
        layers: terrain.pathingCliffs.slice().reverse(),
        resolution: 2
      }).addToApp(this);
      this.mainLogic = new MainLogic().addToApp(this);
      this.runnerTracker = new RunnerTracker().addToApp(this);
      this.addSystem(new BuildWatcher());
      registerNetworkedActionListeners();
      this.registerComponent(ForPlayer);
      this.registerComponent(MainLogicTimerHook);
      this.registerComponent(IsDone);
    });
  }
  onPlayerJoin(data) {
    const player = new Player2({
      color: nextColor(),
      game: this,
      id: data.connection,
      username: data.username
    });
    return player;
  }
  onPlayerLeave(player) {
    super.onPlayerLeave(player);
    player.sprites.forEach((s3) => s3.remove());
    if (this.players.every((s3) => s3.id < 0)) {
      logLine("abort round");
      for (const entity of this.entities)
        if (entity.id !== "TERRAIN")
          this.remove(entity);
      this.mainLogic.round = void 0;
    }
    for (const entity of this.entities) {
      const forPlayer = entity.get(ForPlayer)[0];
      if (forPlayer && forPlayer.player === player)
        this.remove(entity);
    }
  }
  _update(e3) {
    super._update(e3);
    const time = e3.time / 1e3;
    this.dispatchEvent("update", time);
  }
  render() {
    withMazingContest(this, () => this._render());
  }
  update(e3) {
    withMazingContest(this, () => this._update(e3));
  }
  toJSON() {
    return {
      ...super.toJSON(),
      players: this.players.map((p3) => p3.toJSON()),
      entities: this.entities.map((e3) => e3.toJSON()),
      round: this.mainLogic.round,
      alliances: this.alliances.toJSON()
    };
  }
};
MazingContest.isMazingContest = true;
MazingContest.displayName = "Mazing Contest";
MazingContest.protocol = "mazingcontest";
__name(MazingContest, "MazingContest");

// src/MazingContestNetwork.ts
var networkEvents2 = {
  ...Network.networkEvents,
  init: (data) => {
  },
  state: (data) => {
  },
  selfDestruct: (data) => {
  },
  ready: (data) => {
  }
};
var MazingContestNetwork = class extends Network {
};
MazingContestNetwork.networkEvents = networkEvents2;
__name(MazingContestNetwork, "MazingContestNetwork");
//# sourceMappingURL=server.cjs.map
